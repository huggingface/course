# Construire votre premi√®re d√©mo

<CourseFloatingBanner chapter={9}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "English", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter9/section2.ipynb"},
    {label: "Fran√ßais", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/fr/chapter9/section2.ipynb"},
    {label: "English", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter9/section2.ipynb"},
    {label: "Fran√ßais", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/fr/chapter9/section2.ipynb"},
]} />

Commen√ßons par installer *Gradio* ! Comme il s'agit d'un *package* Python, il suffit de l'ex√©cuter :

`$ pip install gradio `

Vous pouvez ex√©cuter *Gradio* n'importe o√π, que ce soit dans votre IDE Python pr√©f√©r√©, dans des *notebooks* ou m√™me dans Google Colab ü§Ø !
Alors installez *Gradio* partout o√π vous ex√©cutez Python !

Commen√ßons par un exemple simple de type ¬´ *Hello World* ¬ª pour nous familiariser avec la syntaxe de *Gradio*  :

```py
import gradio as gr


def greet(name):
    return "Hello " + name


demo = gr.Interface(fn=greet, inputs="text", outputs="text")

demo.launch()
```

Parcourons le code ci-dessus :

- D'abord, nous d√©finissons une fonction appel√©e `greet()`. Dans ce cas, c'est une simple fonction qui ajoute ¬´ *Hello* ¬ª devant votre nom, mais cela peut √™tre *n'importe quelle* fonction Python en g√©n√©ral. Par exemple, dans les applications d'apprentissage automatique, cette fonction pourrait *appeler un mod√®le pour faire une pr√©diction* sur une entr√©e et retourner la sortie.
- Ensuite, nous cr√©ons une `Interface` *Gradio* avec trois arguments, `fn`, `inputs`, et `outputs`. Ces arguments d√©finissent la fonction de pr√©diction, ainsi que le _type_ de composants d'entr√©e et de sortie que nous souhaitons. Dans notre cas, les deux composants sont de simples bo√Ætes de texte. 
- Nous appelons ensuite la m√©thode `launch()` sur l'`Interface` que nous avons cr√©√©e. 

Si vous ex√©cutez ce code, l'interface ci-dessous appara√Ætra automatiquement dans un *notebook* Jupyter/Colab ou dans un navigateur sur **[http://localhost:7860](http://localhost:7860/)** si vous l'ex√©cutez √† partir d'un script.

<iframe src="https://course-demos-hello-world.hf.space" frameBorder="0" height="250" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

Essayez d'utiliser cette interface maintenant avec votre propre nom ou une autre entr√©e !

Vous remarquerez que dedans, *Gradio* a automatiquement d√©duit le nom du param√®tre d'entr√©e (`name`) et l'a appliqu√© comme √©tiquette au dessus de la zone de texte. Que faire si vous souhaitez changer cela ?
Ou si vous souhaitez personnaliser la zone de texte d'une autre mani√®re ? Dans ce cas, vous pouvez instancier un objet de classe repr√©sentant le composant de saisie. 

Jetez un coup d'≈ìil √† l'exemple ci-dessous :

```py
import gradio as gr


def greet(name):
    return "Hello " + name


# Nous instancions la classe Textbox
textbox = gr.Textbox(label="Type your name here:", placeholder="John Doe", lines=2)

gr.Interface(fn=greet, inputs=textbox, outputs="text").launch()
```

<iframe src="https://course-demos-hello-world-custom.hf.space" frameBorder="0" height="300" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

Ici, nous avons cr√©√© une zone de texte d'entr√©e avec une √©tiquette, un espace r√©serv√© et un nombre de lignes d√©fini.
Vous pourriez faire la m√™me chose pour la zone de texte de sortie, mais nous allons laisser cela pour le moment.

Nous avons vu qu'avec seulement quelques lignes de code, *Gradio* vous permet de cr√©er une interface simple autour de n'importe quelle fonction 
avec n'importe quel type d'entr√©es ou de sorties. Dans cette section, nous avons commenc√© par une simple bo√Æte de texte mais dans les sections suivantes, nous couvrirons d'autres types d'entr√©es et de sorties. Voyons maintenant comment inclure un peu de NLP dans une application *Gradio*.


## ü§ñ Inclure les pr√©dictions du mod√®le

Construisons maintenant une interface simple qui permet de faire une d√©mo d'un mod√®le de **g√©n√©ration de texte** comme le GPT-2.

Nous allons charger notre mod√®le en utilisant la fonction `pipeline()` de ü§ó *Transformers*. 
Si vous avez besoin d'un rafra√Æchissement rapide, vous pouvez revenir √† [cette section du chapitre 1](/course/fr/chapter1/3#text-generation).   

Tout d'abord, nous d√©finissons une fonction de pr√©diction qui prend une invite de texte et renvoie la compl√©tion du texte :

```py
from transformers import pipeline

model = pipeline("text-generation")


def predict(prompt):
    completion = model(prompt)[0]["generated_text"]
    return completion
```

Cette fonction compl√®te le texte que vous fournissez, et vous pouvez l'ex√©cuter avec les votres pour voir comment elle fonctionne. Voici un exemple (vous obtiendrez peut-√™tre un r√©sultat diff√©rent) :


```
predict("My favorite programming language is") # Mon langage de programmation pr√©f√©r√© est
```

```
>> My favorite programming language is Haskell. I really enjoyed the Haskell language, but it doesn't have all the features that can be applied to any other language. For example, all it does is compile to a byte array.
#  Mon langage de programmation pr√©f√©r√© est Haskell. J'ai vraiment appr√©ci√© le langage Haskell, mais il n'a pas toutes les caract√©ristiques que l'on peut appliquer √† n'importe quel autre langage. Par exemple, il ne fait que compiler un tableau d'octets.
```

Maintenant que nous avons une fonction pour g√©n√©rer des pr√©dictions, nous pouvons cr√©er et lancer une `Interface` de la m√™me mani√®re que nous l'avons fait pr√©c√©demment :

```py
import gradio as gr

gr.Interface(fn=predict, inputs="text", outputs="text").launch()
```


C'est fait ! Vous pouvez maintenant utiliser cette interface pour g√©n√©rer du texte en utilisant le mod√®le GPT-2 comme indiqu√© ci-dessous ü§Ø.

<iframe src="https://course-demos-gpt-2.hf.space" frameBorder="0" height="250" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

Continuez votre lecture du cours pour voir comment construire d'autres types de d√©mos avec *Gradio* !
