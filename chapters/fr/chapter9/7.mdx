# Introduction √† la classe <i>Blocks</i>

Dans les sections pr√©c√©dentes, nous avons explor√© et cr√©√© des d√©mos en utilisant la classe `Interface`. Dans cette section, nous allons pr√©senter une **nouvelle** API de bas niveau appel√©e `gradio.Blocks`.

Quelle est la diff√©rence entre `Interface` et `Blocks` ?

- ‚ö° `Interface` : une API de haut niveau qui vous permet de cr√©er une d√©mo compl√®te d'apprentissage automatique simplement en fournissant une liste d'entr√©es et de sorties.

- üß± `Blocks` : une API de bas niveau qui vous permet d'avoir un contr√¥le total sur les flux de donn√©es et la disposition de votre application. Vous pouvez construire des applications tr√®s complexes, en plusieurs √©tapes, en utilisant `Blocks`.


### Pourquoi <i>Blocks</i> üß± ?

Comme nous l'avons vu dans les sections pr√©c√©dentes, la classe `Interface` vous permet de cr√©er facilement des d√©mos d'apprentissage automatique √† part enti√®re avec seulement quelques lignes de code. L'API `Interface` est extr√™mement facile √† utiliser, mais elle n'a pas la flexibilit√© qu'offre l'API `Blocks`. Par exemple, vous pourriez vouloir :

- regrouper des d√©mos connexes sous forme d'onglets multiples dans une application web,
- modifier la mise en page de votre d√©mo, par exemple pour sp√©cifier l'emplacement des entr√©es et des sorties,
- disposer d'interfaces multi-√©tapes dans lesquelles la sortie d'un mod√®le devient l'entr√©e du mod√®le suivant ou avoir des flux de donn√©es plus flexibles en g√©n√©ral,
- modifier les propri√©t√©s d'un composant (par exemple, les choix dans une liste d√©roulante) ou sa visibilit√© en fonction des entr√©es de l'utilisateur.

Nous allons explorer tous ces concepts ci-dessous.

### Cr√©ation d'une d√©mo simple en utilisant <i>Blocks</i>

Apr√®s avoir install√© *Gradio*, ex√©cutez le code ci-dessous sous forme de script Python, de *notebook* Jupyter ou de *notebook* Colab.

```py
import gradio as gr


def flip_text(x):
    return x[::-1]


demo = gr.Blocks()

with demo:
    gr.Markdown(
        """
    # Flip Text!
    Start typing below to see the output.
    """
    )
    input = gr.Textbox(placeholder="Flip this text")
    output = gr.Textbox()

    input.change(fn=flip_text, inputs=input, outputs=output)

demo.launch()
```

<iframe src="https://hf.space/gradioiframe/course-demos/flip_text/+" frameBorder="0" height="400" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

Ce simple exemple ci-dessus introduit 4 concepts qui sous-tendent les *Blocks* :

1. Les *Blocks* vous permettent de construire des applications web qui combinent Markdown, HTML, boutons et composants interactifs simplement en instanciant des objets en Python dans un contexte `with gradio.Blocks`. 

<Tip>
üôãSi vous n'√™tes pas familier avec l'instruction `with` en Python, nous vous recommandons de consulter l'excellent <a href="https://realpython.com/python-with-statement/">tutoriel</a> de Real Python. Revenez ici apr√®s l'avoir lu ü§ó
</Tip>

L'ordre dans lequel vous instanciez les composants est important car chaque √©l√©ment est restitu√© dans l'application Web dans l'ordre o√π il a √©t√© cr√©√©. (Les mises en page plus complexes sont abord√©es ci-dessous)

2. Vous pouvez d√©finir des fonctions Python ordinaires n'importe o√π dans votre code et les ex√©cuter avec des entr√©es utilisateur en utilisant les `Blocks`. Dans notre exemple, nous avons une fonction simple qui inverse le texte entr√© mais vous pouvez √©crire n'importe quelle fonction Python, du simple calcul au traitement des pr√©dictions d'un mod√®le d'apprentissage automatique.

3. Vous pouvez assigner des √©v√©nements √† n'importe quel composant `Blocks`. Ainsi, votre fonction sera ex√©cut√©e lorsque le composant sera cliqu√©, modifi√©, etc. Lorsque vous assignez un √©v√©nement, vous passez trois param√®tres : 
- `fn` : la fonction qui doit √™tre appel√©e,  
- `inputs` : la (liste) des composants d'entr√©e  
- `outputs` : la (liste) des composants de sortie qui doivent √™tre appel√©s.  
   Dans l'exemple ci-dessus, nous ex√©cutons la fonction `flip_text()` lorsque la valeur de la `Textbox` nomm√©e input `input` change. L'√©v√©nement lit la valeur dans `input`, la passe comme param√®tre de nom √† `flip_text()`, qui renvoie alors une valeur qui est assign√©e √† notre seconde `Textbox` nomm√©e `output`.
   Pour voir la liste des √©v√©nements que chaque composant supporte, consultez la [documentation](https://www.gradio.app/docs/) de *Gradio*.

4. *Blocks* d√©termine automatiquement si un composant doit √™tre interactif (accepter les entr√©es de l'utilisateur) ou non, en fonction des d√©clencheurs d'√©v√©nements que vous d√©finissez. Dans notre exemple, la premi√®re zone de texte est interactive, puisque sa valeur est utilis√©e par la fonction `flip_text()`. La deuxi√®me zone de texte n'est pas interactive, puisque sa valeur n'est jamais utilis√©e comme entr√©e. Dans certains cas, vous voudrez peut-√™tre passer outre, ce que vous pouvez faire en passant un bool√©en au param√®tre `interactive` du composant (par exemple, `gr.Textbox(placeholder="Flip this text", interactive=True)`).


### Personnaliser la mise en page de votre d√©mo

Comment pouvons-nous utiliser `Blocks` pour personnaliser la mise en page de notre d√©mo ? Par d√©faut, `Blocks` affiche verticalement dans une colonne les composants que vous cr√©ez. Vous pouvez changer cela en cr√©ant des colonnes suppl√©mentaires `avec gradio.Column():` ou des lignes `avec gradio.Row():` et en cr√©ant des composants dans ces contextes.

Voici ce que vous devez garder √† l'esprit : tout composant cr√©√© sous une `Column` (c'est aussi le d√©faut) sera dispos√© verticalement. Tout composant cr√©√© sous une `Row` sera dispos√© horizontalement, comme le [mod√®le flexbox dans le d√©veloppement web](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox).

Enfin, vous pouvez √©galement cr√©er des onglets pour votre d√©mo en utilisant le gestionnaire de contexte `with gradio.Tabs()`. Dans ce contexte, vous pouvez cr√©er plusieurs onglets en sp√©cifiant des enfants `with gradio.TabItem(name_of_tab):`. Tout composant cr√©√© dans un contexte `with gradio.TabItem(name_of_tab):` appara√Æt dans cet onglet.

Maintenant, ajoutons une fonction `flip_image()` √† notre d√©mo et ajoutons un nouvel onglet qui retourne les images. Vous trouverez ci-dessous un exemple avec 2 onglets et utilisant √©galement une `Row` :

```py
import numpy as np
import gradio as gr

demo = gr.Blocks()


def flip_text(x):
    return x[::-1]


def flip_image(x):
    return np.fliplr(x)


with demo:
    gr.Markdown("Flip text or image files using this demo.")
    with gr.Tabs():
        with gr.TabItem("Flip Text"):
            with gr.Row():
                text_input = gr.Textbox()
                text_output = gr.Textbox()
            text_button = gr.Button("Flip")
        with gr.TabItem("Flip Image"):
            with gr.Row():
                image_input = gr.Image()
                image_output = gr.Image()
            image_button = gr.Button("Flip")

    text_button.click(flip_text, inputs=text_input, outputs=text_output)
    image_button.click(flip_image, inputs=image_input, outputs=image_output)

demo.launch()
```

<iframe src="https://hf.space/gradioiframe/course-demos/flip_text_image/+" frameBorder="0" height="450" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>


Vous remarquerez que dans cet exemple, nous avons √©galement cr√©√© un composant `Button` dans chaque onglet et avons assign√© un √©v√©nement de clic √† chaque bouton qui est l'√©l√©ment qui ex√©cute r√©ellement la fonction.

### Exploration des √©v√©nements et de l'√©tat

De la m√™me mani√®re que vous pouvez contr√¥ler la mise en page, `Blocks` vous donne un contr√¥le fin sur les √©v√©nements qui d√©clenchent les appels de fonction. Chaque composant et de nombreux layouts ont des √©v√©nements sp√©cifiques qu'ils supportent.

Par exemple, le composant `Textbox` a 2 √©v√©nements : `change()` (lorsque la valeur contenue dans la zone de texte change), et `submit()` (lorsqu'un utilisateur appuie sur la touche Entr√©e alors qu'il est concentr√© sur la zone de texte). Les composants plus complexes peuvent avoir encore plus d'√©v√©nements : par exemple, le composant `Audio` a aussi des √©v√©nements s√©par√©s pour quand le fichier audio est jou√©, effac√©, mis en pause, etc. Consultez la documentation pour conna√Ætre les √©v√©nements pris en charge par chaque composant.

Vous pouvez attacher un d√©clencheur d'√©v√©nement √† aucun, un ou plusieurs de ces √©v√©nements. Vous cr√©ez un d√©clencheur d'√©v√©nement en appelant le nom de l'√©v√©nement sur l'instance du composant comme une fonction. Par exemple, `textbox.change(...)` ou `btn.click(...)`. La fonction prend trois param√®tres, comme indiqu√© ci-dessus :

- `fn` : la fonction √† ex√©cuter
- `inputs` : une (liste de) composante(s) dont les valeurs doivent √™tre fournies comme param√®tres d'entr√©e √† la fonction. La valeur de chaque composant est mise en correspondance avec le param√®tre de fonction correspondant, dans l'ordre. Ce param√®tre peut √™tre `None` si la fonction ne prend aucun param√®tre.
- `outputs` : un (liste de) composant(s) dont les valeurs doivent √™tre mises √† jour en fonction des valeurs retourn√©es par la fonction. Chaque valeur de retour met √† jour la valeur du composant correspondant, dans l'ordre. Ce param√®tre peut √™tre None si la fonction ne retourne rien.

Vous pouvez m√™me faire en sorte que le composant d'entr√©e et de sortie soit le m√™me composant, comme nous le faisons dans cet exemple qui utilise un mod√®le GPT pour compl√©ter du texte :

```py
import gradio as gr

api = gr.Interface.load("huggingface/EleutherAI/gpt-j-6B")


def complete_with_gpt(text):
    # Utilise les 50 derniers caract√®res du texte comme contexte.
    return text[:-50] + api(text[-50:])


with gr.Blocks() as demo:
    textbox = gr.Textbox(placeholder="Type here and press enter...", lines=4)
    btn = gr.Button("Generate")

    btn.click(complete_with_gpt, textbox, textbox)

demo.launch()
```

<iframe src="https://hf.space/gradioiframe/course-demos/blocks_gpt/+" frameBorder="0" height="300" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

### Cr√©ation de d√©mos multi-√©tapes

Dans certains cas, vous pouvez vouloir une _d√©mo multi-√©tapes_, dans laquelle vous r√©utilisez la sortie d'une fonction comme entr√©e de la suivante. C'est tr√®s facile √† faire avec les `Blocks`, car vous pouvez utiliser un composant pour l'entr√©e d'un d√©clencheur d'√©v√©nement mais la sortie d'un autre. Regardez le composant texte dans l'exemple ci-dessous, sa valeur est le r√©sultat d'un mod√®le de conversion de la parole en texte, mais il est √©galement transmis √† un mod√®le d'analyse des sentiments :

```py
from transformers import pipeline

import gradio as gr

asr = pipeline("automatic-speech-recognition", "facebook/wav2vec2-base-960h")
classifier = pipeline("text-classification")


def speech_to_text(speech):
    text = asr(speech)["text"]
    return text


def text_to_sentiment(text):
    return classifier(text)[0]["label"]


demo = gr.Blocks()

with demo:
    audio_file = gr.Audio(type="filepath")
    text = gr.Textbox()
    label = gr.Label()

    b1 = gr.Button("Recognize Speech")
    b2 = gr.Button("Classify Sentiment")

    b1.click(speech_to_text, inputs=audio_file, outputs=text)
    b2.click(text_to_sentiment, inputs=text, outputs=label)

demo.launch()
```

<iframe src="https://hf.space/gradioiframe/course-demos/blocks_multi_step/+" frameBorder="0" height="550" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

### Mise √† jour des propri√©t√©s des composants

Jusqu'√† pr√©sent, nous avons vu comment cr√©er des √©v√©nements pour mettre √† jour la valeur d'un autre composant. Mais que se passe-t-il si vous voulez modifier d'autres propri√©t√©s d'un composant, comme la visibilit√© d'une zone de texte ou les choix dans un groupe de boutons radio ? Vous pouvez le faire en renvoyant la m√©thode `update()` d'une classe de composant au lieu d'une valeur de retour normale de votre fonction.

L'exemple le plus facile √† illustrer est le suivant :

```py
import gradio as gr


def change_textbox(choice):
    if choice == "short":
        return gr.Textbox.update(lines=2, visible=True)
    elif choice == "long":
        return gr.Textbox.update(lines=8, visible=True)
    else:
        return gr.Textbox.update(visible=False)


with gr.Blocks() as block:
    radio = gr.Radio(
        ["short", "long", "none"], label="What kind of essay would you like to write?"
    )
    text = gr.Textbox(lines=2, interactive=True)

    radio.change(fn=change_textbox, inputs=radio, outputs=text)
    block.launch()
```

<iframe src="https://hf.space/gradioiframe/course-demos/blocks_update_component_properties/+" frameBorder="0" height="300" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

Nous venons d'explorer tous les concepts de base des `Blocks` ! Tout comme avec `Interface`, vous pouvez cr√©er des d√©mos sympas qui peuvent √™tre partag√©es en utilisant `share=True` dans la m√©thode `launch()` ou d√©ploy√©es sur [*Spaces*](https://huggingface.co/spaces).