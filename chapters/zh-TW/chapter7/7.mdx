<FrameworkSwitchCourse {fw} />

# å•ç­”

{#if fw === 'pt'}

<DocNotebookDropdown
  classNames="absolute z-10 right-0 top-0"
  options={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter7/section7_pt.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter7/section7_pt.ipynb"},
]} />

{:else}

<DocNotebookDropdown
  classNames="absolute z-10 right-0 top-0"
  options={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter7/section7_tf.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter7/section7_tf.ipynb"},
]} />

{/if}

æ˜¯æ™‚å€™çœ‹å•ç­”äº†! é€™é …ä»»å‹™æœ‰å¤šç¨®å½¢å¼, ä½†æˆ‘å€‘å°‡åœ¨æœ¬ç¯€ä¸­é—œæ³¨çš„ä¸€é …ç¨±ç‚º*æå–*çš„å•ç­”ã€‚å•é¡Œçš„ç­”æ¡ˆå°±åœ¨ _çµ¦å®šçš„æ–‡æª”_ ä¹‹ä¸­ã€‚

<Youtube id="ajPx5LwJD-I"/>

æˆ‘å€‘å°‡ä½¿ç”¨ [SQuAD æ•¸æ“šé›†](https://rajpurkar.github.io/SQuAD-explorer/) å¾®èª¿ä¸€å€‹BERTæ¨¡å‹, å…¶ä¸­åŒ…æ‹¬ç¾¤çœ¾å·¥ä½œè€…å°ä¸€çµ„ç¶­åŸºç™¾ç§‘æ–‡ç« æå‡ºçš„å•é¡Œã€‚ä»¥ä¸‹æ˜¯ä¸€å€‹å°çš„æ¸¬è©¦æ¨£ä¾‹:

<iframe src="https://course-demos-bert-finetuned-squad.hf.space" frameBorder="0" height="450" title="Gradio app" class="block dark:hidden container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>
<iframe src="https://course-demos-bert-finetuned-squad-darkmode.hf.space" frameBorder="0" height="450" title="Gradio app" class="hidden dark:block container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

æœ¬ç¯€ä½¿ç”¨çš„ä»£ç¢¼å·²ç¶“ä¸Šå‚³åˆ°äº†Hubã€‚ä½ å¯ä»¥åœ¨ [é€™è£¡](https://huggingface.co/huggingface-course/bert-finetuned-squad?context=%F0%9F%A4%97+Transformers+is+backed+by+the+three+most+popular+deep+learning+libraries+%E2%80%94+Jax%2C+PyTorch+and+TensorFlow+%E2%80%94+with+a+seamless+integration+between+them.+It%27s+straightforward+to+train+your+models+with+one+before+loading+them+for+inference+with+the+other.&question=Which+deep+learning+libraries+back+%F0%9F%A4%97+Transformers%3F) æ‰¾åˆ°å®ƒä¸¦å˜—è©¦ç”¨å®ƒé€²è¡Œé æ¸¬ã€‚

<Tip>

ğŸ’¡ åƒ BERT é€™æ¨£çš„ç´”ç·¨ç¢¼å™¨æ¨¡å‹å¾€å¾€å¾ˆæ“…é•·æå–è«¸å¦‚ "èª°ç™¼æ˜äº† Transformer æ¶æ§‹?"ä¹‹é¡çš„äº‹å¯¦æ€§å•é¡Œçš„ç­”æ¡ˆã€‚ä½†åœ¨çµ¦å‡ºè«¸å¦‚ "ç‚ºä»€éº¼å¤©ç©ºæ˜¯è—è‰²çš„?" ä¹‹é¡çš„é–‹æ”¾å¼å•é¡Œæ™‚è¡¨ç¾ä¸ä½³ã€‚åœ¨é€™äº›æ›´å…·æŒ‘æˆ°æ€§çš„æƒ…æ³ä¸‹, T5 å’Œ BART ç­‰ç·¨ç¢¼å™¨-è§£ç¢¼å™¨æ¨¡å‹é€šå¸¸ä½¿ç”¨ä»¥èˆ‡ [æ–‡æœ¬æ‘˜è¦](/course/chapter7/5) éå¸¸ç›¸ä¼¼çš„æ–¹å¼åˆæˆä¿¡æ¯ã€‚å¦‚æœä½ å°é€™ç¨®é¡å‹çš„*ç”Ÿæˆå¼*å•ç­”æ„Ÿèˆˆè¶£, æˆ‘å€‘å»ºè­°æ‚¨æŸ¥çœ‹æˆ‘å€‘åŸºæ–¼ [ELI5 æ•¸æ“šé›†](https://huggingface.co/datasets/eli5) çš„ [æ¼”ç¤º](https://yjernite.github.io/lfqa.html)ã€‚

</Tip>

## æº–å‚™æ•¸æ“š

æœ€å¸¸ç”¨ä½œæŠ½å–å¼å•ç­”çš„å­¸è¡“åŸºæº–çš„æ•¸æ“šé›†æ˜¯ [SQuAD](https://rajpurkar.github.io/SQuAD-explorer/), æ‰€ä»¥é€™å°±æ˜¯æˆ‘å€‘å°‡åœ¨é€™è£¡ä½¿ç”¨çš„ã€‚é‚„æœ‰ä¸€å€‹æ›´é›£çš„ [SQuAD v2](https://huggingface.co/datasets/squad_v2) åŸºæº–, å…¶ä¸­åŒ…æ‹¬æ²’æœ‰ç­”æ¡ˆçš„å•é¡Œã€‚åªè¦ä½ è‡ªå·±çš„æ•¸æ“šé›†åŒ…å«ä¸Šä¸‹æ–‡åˆ—ã€å•é¡Œåˆ—å’Œç­”æ¡ˆåˆ—, ä½ å°±æ‡‰è©²èƒ½å¤ èª¿æ•´ä»¥ä¸‹æ­¥é©Ÿã€‚

### SQuAD æ•¸æ“šé›†

åƒå¾€å¸¸ä¸€æ¨£, æˆ‘å€‘åªéœ€ä¸€æ­¥å°±å¯ä»¥ä¸‹è¼‰å’Œç·©å­˜æ•¸æ“šé›†, é€™è¦æ­¸åŠŸæ–¼ `load_dataset()`:

```py
from datasets import load_dataset

raw_datasets = load_dataset("squad")
```

ç„¶å¾Œæˆ‘å€‘å¯ä»¥æŸ¥çœ‹é€™å€‹å°è±¡ä»¥, ç­è§£æœ‰é—œ SQuAD æ•¸æ“šé›†çš„æ›´å¤šä¿¡æ¯:

```py
raw_datasets
```

```python out
DatasetDict({
    train: Dataset({
        features: ['id', 'title', 'context', 'question', 'answers'],
        num_rows: 87599
    })
    validation: Dataset({
        features: ['id', 'title', 'context', 'question', 'answers'],
        num_rows: 10570
    })
})
```

çœ‹èµ·ä¾†æˆ‘å€‘æ“æœ‰æ‰€éœ€çš„ `context` ã€`question` å’Œ `answers` å­—æ®µ, æ‰€ä»¥è®“æˆ‘å€‘æ‰“å°è¨“ç·´é›†çš„ç¬¬ä¸€å€‹å…ƒç´ :

```py
print("Context: ", raw_datasets["train"][0]["context"])
print("Question: ", raw_datasets["train"][0]["question"])
print("Answer: ", raw_datasets["train"][0]["answers"])
```

```python out
Context: 'Architecturally, the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend "Venite Ad Me Omnes". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive (and in a direct line that connects through 3 statues and the Gold Dome), is a simple, modern stone statue of Mary.'
Question: 'To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France?'
Answer: {'text': ['Saint Bernadette Soubirous'], 'answer_start': [515]}
```

`context` å’Œ `question` å­—æ®µä½¿ç”¨èµ·ä¾†éå¸¸ç°¡å–®ã€‚ä½†æ˜¯ `answers` å­—æ®µæœ‰é»æ£˜æ‰‹, å› ç‚ºå®ƒå°‡å­—å…¸èˆ‡å…©å€‹éƒ½æ˜¯åˆ—è¡¨çš„å­—æ®µçµ„æˆã€‚é€™æ˜¯åœ¨è©•ä¼°éç¨‹ä¸­ `squad` æŒ‡æ¨™æ‰€æœŸæœ›çš„æ ¼å¼; å¦‚æœä½ ä½¿ç”¨çš„æ˜¯è‡ªå·±çš„æ•¸æ“š, å‰‡ä¸å¿…æ“”å¿ƒå°‡ç­”æ¡ˆæ¡ç”¨ç›¸åŒçš„æ ¼å¼ã€‚`text` å­—æ®µæ¯”è¼ƒæ˜é¡¯, è€Œ `answer_start` å­—æ®µåŒ…å«ä¸Šä¸‹æ–‡ä¸­æ¯å€‹ç­”æ¡ˆçš„èµ·å§‹å­—ç¬¦ç´¢å¼•ã€‚

åœ¨è¨“ç·´æœŸé–“, åªæœ‰ä¸€ç¨®å¯èƒ½çš„ç­”æ¡ˆã€‚æˆ‘å€‘å¯ä»¥ä½¿ç”¨ `Dataset.filter()` æ–¹æ³•:

```py
raw_datasets["train"].filter(lambda x: len(x["answers"]["text"]) != 1)
```

```python out
Dataset({
    features: ['id', 'title', 'context', 'question', 'answers'],
    num_rows: 0
})
```

ç„¶è€Œ, å°æ–¼è©•ä¼°, æ¯å€‹æ¨£æœ¬éƒ½æœ‰å¹¾å€‹å¯èƒ½çš„ç­”æ¡ˆ, å®ƒå€‘å¯èƒ½ç›¸åŒæˆ–ä¸åŒ:

```py
print(raw_datasets["validation"][0]["answers"])
print(raw_datasets["validation"][2]["answers"])
```

```python out
{'text': ['Denver Broncos', 'Denver Broncos', 'Denver Broncos'], 'answer_start': [177, 177, 177]}
{'text': ['Santa Clara, California', "Levi's Stadium", "Levi's Stadium in the San Francisco Bay Area at Santa Clara, California."], 'answer_start': [403, 355, 355]}
```

æˆ‘å€‘ä¸æœƒæ·±å…¥ç ”ç©¶è©•ä¼°è…³æœ¬, å› ç‚ºå®ƒéƒ½æœƒè¢«ä¸€å€‹ ğŸ¤— Datasets æŒ‡æ¨™åŒ…è£¹èµ·ä¾†, ä½†ç°¡çŸ­çš„ç‰ˆæœ¬æ˜¯ä¸€äº›å•é¡Œæœ‰å¹¾å€‹å¯èƒ½çš„ç­”æ¡ˆ, é€™å€‹è…³æœ¬æœƒå°‡é æ¸¬çš„ç­”æ¡ˆèˆ‡æ‰€æœ‰â€‹â€‹çš„å¯æ¥å—çš„ç­”æ¡ˆä¸¦ç²å¾—æœ€é«˜åˆ†ã€‚ä¾‹å¦‚, æˆ‘å€‘çœ‹ä¸€ä¸‹ç´¢å¼• 2 è™•çš„æ¨£æœ¬e:

```py
print(raw_datasets["validation"][2]["context"])
print(raw_datasets["validation"][2]["question"])
```

```python out
'Super Bowl 50 was an American football game to determine the champion of the National Football League (NFL) for the 2015 season. The American Football Conference (AFC) champion Denver Broncos defeated the National Football Conference (NFC) champion Carolina Panthers 24â€“10 to earn their third Super Bowl title. The game was played on February 7, 2016, at Levi\'s Stadium in the San Francisco Bay Area at Santa Clara, California. As this was the 50th Super Bowl, the league emphasized the "golden anniversary" with various gold-themed initiatives, as well as temporarily suspending the tradition of naming each Super Bowl game with Roman numerals (under which the game would have been known as "Super Bowl L"), so that the logo could prominently feature the Arabic numerals 50.'
'Where did Super Bowl 50 take place?'
```

æˆ‘å€‘å¯ä»¥çœ‹åˆ°, ç­”æ¡ˆç¢ºå¯¦å¯ä»¥æ˜¯æˆ‘å€‘ä¹‹å‰çœ‹åˆ°çš„ä¸‰ç¨®å¯èƒ½æ€§ä¹‹ä¸€ã€‚

### è™•ç†è¨“ç·´æ•¸æ“š

<Youtube id="qgaM0weJHpA"/>

è®“æˆ‘å€‘å¾é è™•ç†è¨“ç·´æ•¸æ“šé–‹å§‹ã€‚å›°é›£çš„éƒ¨åˆ†å°‡æ˜¯ç‚ºå•é¡Œçš„ç­”æ¡ˆç”Ÿæˆæ¨™ç±¤, é€™å°‡æ˜¯èˆ‡ä¸Šä¸‹æ–‡ä¸­çš„ç­”æ¡ˆç›¸å°æ‡‰çš„æ¨™è¨˜çš„é–‹å§‹å’ŒçµæŸä½ç½®ã€‚

ä½†æ˜¯, æˆ‘å€‘ä¸è¦è¶…è¶Šè‡ªå·±ã€‚é¦–å…ˆ, æˆ‘å€‘éœ€è¦ä½¿ç”¨åˆ†è©å™¨å°‡è¼¸å…¥ä¸­çš„æ–‡æœ¬è½‰æ›ç‚ºæ¨¡å‹å¯ä»¥ç†è§£çš„ ID:

```py
from transformers import AutoTokenizer

model_checkpoint = "bert-base-cased"
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)
```

å¦‚å‰æ‰€è¿°, æˆ‘å€‘å°‡å° BERT æ¨¡å‹é€²è¡Œå¾®èª¿, ä½†ä½ å¯ä»¥ä½¿ç”¨ä»»ä½•å…¶ä»–æ¨¡å‹é¡å‹, åªè¦å®ƒå¯¦ç¾äº†å¿«é€Ÿæ¨™è¨˜å™¨å³å¯ã€‚ä½ å¯ä»¥åœ¨ [this big table](https://huggingface.co/transformers/#supported-frameworks) ä¸­çœ‹åˆ°æ‰€æœ‰å¿«é€Ÿç‰ˆæœ¬çš„æ¶æ§‹, ä¸¦æª¢æŸ¥ä½ æ­£åœ¨ä½¿ç”¨çš„ `tokenizer` å°è±¡ç¢ºå¯¦ç”± ğŸ¤— Tokenizers æ”¯æŒ, ä½ å¯ä»¥æŸ¥çœ‹å®ƒçš„ `is_fast` å±¬æ€§:

```py
tokenizer.is_fast
```

```python out
True
```

æˆ‘å€‘å¯ä»¥å°‡å•é¡Œå’Œä¸Šä¸‹æ–‡ä¸€èµ·å‚³éçµ¦æˆ‘å€‘çš„æ¨™è¨˜å™¨, å®ƒæœƒæ­£ç¢ºæ’å…¥ç‰¹æ®Šæ¨™è¨˜ä»¥å½¢æˆå¦‚ä¸‹å¥å­:

```
[CLS] question [SEP] context [SEP]
```

è®“æˆ‘å€‘ä»”ç´°æª¢æŸ¥ä¸€ä¸‹:

```py
context = raw_datasets["train"][0]["context"]
question = raw_datasets["train"][0]["question"]

inputs = tokenizer(question, context)
tokenizer.decode(inputs["input_ids"])
```

```python out
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Architecturally, '
'the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin '
'Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms '
'upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred '
'Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a '
'replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette '
'Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 statues '
'and the Gold Dome ), is a simple, modern stone statue of Mary. [SEP]'
```

ç„¶å¾Œæ¨™ç±¤å°‡æˆç‚ºé–‹å§‹å’ŒçµæŸç­”æ¡ˆçš„æ¨™è¨˜çš„ç´¢å¼•, ä¸¦ä¸”æ¨¡å‹çš„ä»»å‹™æ˜¯é æ¸¬è¼¸å…¥ä¸­æ¯å€‹æ¨™è¨˜çš„é–‹å§‹å’ŒçµæŸ logit, ç†è«–æ¨™ç±¤å¦‚ä¸‹:

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/qa_labels.svg" alt="One-hot encoded labels for question answering."/>
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/qa_labels-dark.svg" alt="One-hot encoded labels for question answering."/>
</div>

åœ¨é€™ç¨®æƒ…æ³ä¸‹, ä¸Šä¸‹æ–‡ä¸æœƒå¤ªé•·, ä½†æ˜¯æ•¸æ“šé›†ä¸­çš„ä¸€äº›ç¤ºä¾‹çš„ä¸Šä¸‹æ–‡å¾ˆé•·, æœƒè¶…éæˆ‘å€‘è¨­ç½®çš„æœ€å¤§é•·åº¦(åœ¨é€™ç¨®æƒ…æ³ä¸‹ç‚º 384)ã€‚æ­£å¦‚æˆ‘å€‘åœ¨ [ç¬¬å…­ç« ](/course/chapter6/4) ä¸­æ‰€çœ‹åˆ°çš„, ç•¶æˆ‘å€‘æ¢ç´¢ `question-answering` ç®¡é“çš„å…§éƒ¨çµæ§‹æ™‚, æˆ‘å€‘å°‡é€šéå¾æˆ‘å€‘çš„æ•¸æ“šé›†çš„ä¸€å€‹æ¨£æœ¬ä¸­å‰µå»ºå¹¾å€‹è¨“ç·´ç‰¹å¾µä¾†è™•ç†é•·ä¸Šä¸‹æ–‡, å®ƒå€‘ä¹‹é–“æœ‰ä¸€å€‹æ»‘å‹•çª—å£ã€‚

è¦ä½¿ç”¨ç•¶å‰ç¤ºä¾‹æŸ¥çœ‹å…¶å·¥ä½œåŸç†, æˆ‘å€‘å¯ä»¥å°‡é•·åº¦é™åˆ¶ç‚º 100, ä¸¦ä½¿ç”¨ 50 å€‹æ¨™è¨˜çš„æ»‘å‹•çª—å£ã€‚æé†’ä¸€ä¸‹, æˆ‘å€‘ä½¿ç”¨:

- `max_length` è¨­ç½®æœ€å¤§é•·åº¦ (æ­¤è™•ç‚º 100)
- `truncation="only_second"` ç”¨æ–¼ç•¶å¸¶æœ‰ä¸Šä¸‹æ–‡çš„å•é¡Œå¤ªé•·æ™‚, æˆªæ–·ä¸Šä¸‹æ–‡t (ä½æ–¼ç¬¬äºŒå€‹ä½ç½®) 
- `stride` è¨­ç½®å…©å€‹é€£çºŒå¡Šä¹‹é–“çš„é‡ç–Šæ¨™è¨˜æ•¸ (é€™è£¡ç‚º 50)
- `return_overflowing_tokens=True` è®“æ¨™è¨˜å™¨çŸ¥é“æˆ‘å€‘æƒ³è¦æº¢å‡ºçš„æ¨™è¨˜

```py
inputs = tokenizer(
    question,
    context,
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
)

for ids in inputs["input_ids"]:
    print(tokenizer.decode(ids))
```

```python out
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Architecturally, the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basi [SEP]'
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin [SEP]'
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 [SEP]'
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP]. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 statues and the Gold Dome ), is a simple, modern stone statue of Mary. [SEP]'
```

å¦‚æˆ‘å€‘æ‰€è¦‹, æˆ‘å€‘çš„ç¤ºä¾‹è¢«åˆ†æˆå››å€‹è¼¸å…¥, æ¯å€‹è¼¸å…¥éƒ½åŒ…å«å•é¡Œå’Œä¸Šä¸‹æ–‡çš„ä¸€éƒ¨åˆ†ã€‚ è«‹æ³¨æ„, å•é¡Œçš„ç­”æ¡ˆ ("Bernadette Soubirous") åƒ…å‡ºç¾åœ¨ç¬¬ä¸‰å€‹ä¹Ÿæ˜¯æœ€å¾Œä¸€å€‹è¼¸å…¥ä¸­, å› æ­¤é€šéä»¥é€™ç¨®æ–¹å¼è™•ç†é•·ä¸Šä¸‹æ–‡, æˆ‘å€‘å°‡å‰µå»ºä¸€äº›ç­”æ¡ˆä¸åŒ…å«åœ¨ä¸Šä¸‹æ–‡ä¸­çš„è¨“ç·´ç¤ºä¾‹ã€‚å°æ–¼é€™äº›ç¤ºä¾‹, æ¨™ç±¤å°‡æ˜¯ `start_position = end_position = 0` (æ‰€ä»¥æˆ‘å€‘é æ¸¬ `[CLS]` æ¨™è¨˜)ã€‚æˆ‘å€‘é‚„å°‡åœ¨ç­”æ¡ˆè¢«æˆªæ–·çš„ä¸å¹¸æƒ…æ³ä¸‹è¨­ç½®é€™äº›æ¨™ç±¤, ä»¥ä¾¿æˆ‘å€‘åªæœ‰å®ƒçš„é–‹å§‹(æˆ–çµæŸ)ã€‚å°æ–¼ç­”æ¡ˆå®Œå…¨åœ¨ä¸Šä¸‹æ–‡ä¸­çš„ç¤ºä¾‹, æ¨™ç±¤å°‡æ˜¯ç­”æ¡ˆé–‹å§‹çš„æ¨™è¨˜çš„ç´¢å¼•å’Œç­”æ¡ˆçµæŸçš„æ¨™è¨˜çš„ç´¢å¼•ã€‚

æ•¸æ“šé›†ç‚ºæˆ‘å€‘æä¾›äº†ä¸Šä¸‹æ–‡ä¸­ç­”æ¡ˆçš„é–‹å§‹å­—ç¬¦, é€šéæ·»åŠ ç­”æ¡ˆçš„é•·åº¦, æˆ‘å€‘å¯ä»¥æ‰¾åˆ°ä¸Šä¸‹æ–‡ä¸­çš„çµæŸå­—ç¬¦ã€‚è¦å°‡å®ƒå€‘æ˜ å°„åˆ°ä»¤ç‰Œç´¢å¼•, æˆ‘å€‘å°‡éœ€è¦ä½¿ç”¨æˆ‘å€‘åœ¨ [ç¬¬å…­ç« ](/course/chapter6/4) ä¸­ç ”ç©¶çš„åç§»æ˜ å°„ã€‚æˆ‘å€‘å¯ä»¥è®“æ¨™è¨˜å™¨é€šéå‚³é `return_offsets_mapping=True` ä¾†è¿”å›é€™äº›å€¼:

```py
inputs = tokenizer(
    question,
    context,
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)
inputs.keys()
```

```python out
dict_keys(['input_ids', 'token_type_ids', 'attention_mask', 'offset_mapping', 'overflow_to_sample_mapping'])
```

å¦‚æˆ‘å€‘æ‰€è¦‹, æˆ‘å€‘å–å›äº†é€šå¸¸çš„è¼¸å…¥ IDã€ä»¤ç‰Œé¡å‹ ID å’Œæ³¨æ„æ©ç¢¼, ä»¥åŠæˆ‘å€‘éœ€è¦çš„åç§»æ˜ å°„å’Œä¸€å€‹é¡å¤–çš„éµ, `overflow_to_sample_mapping`ã€‚ç•¶æˆ‘å€‘åŒæ™‚æ¨™è¨˜å¤šå€‹æ–‡æœ¬æ™‚, ç›¸æ‡‰çš„å€¼å°‡å°æˆ‘å€‘æœ‰ç”¨(æˆ‘å€‘æ‡‰è©²é€™æ¨£åšä»¥å—ç›Šæ–¼æˆ‘å€‘çš„æ¨™è¨˜å™¨ç”± Rust æ”¯æŒçš„äº‹å¯¦)ã€‚ç”±æ–¼ä¸€å€‹æ¨£æœ¬å¯ä»¥æä¾›å¤šå€‹ç‰¹å¾µ, å› æ­¤å®ƒå°‡æ¯å€‹ç‰¹å¾µæ˜ å°„åˆ°å…¶ä¾†æºçš„ç¤ºä¾‹ã€‚å› ç‚ºé€™è£¡æˆ‘å€‘åªæ¨™è¨˜äº†ä¸€å€‹ä¾‹å­, æˆ‘å€‘å¾—åˆ°ä¸€å€‹ `0` çš„åˆ—è¡¨:

```py
inputs["overflow_to_sample_mapping"]
```

```python out
[0, 0, 0, 0]
```

ä½†æ˜¯, å¦‚æœæˆ‘å€‘æ¨™è¨˜æ›´å¤šç¤ºä¾‹, é€™å°‡è®Šå¾—æ›´åŠ æœ‰ç”¨:

```py
inputs = tokenizer(
    raw_datasets["train"][2:6]["question"],
    raw_datasets["train"][2:6]["context"],
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)

print(f"The 4 examples gave {len(inputs['input_ids'])} features.")
print(f"Here is where each comes from: {inputs['overflow_to_sample_mapping']}.")
```

```python out
'The 4 examples gave 19 features.'
'Here is where each comes from: [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3].'
```

æ­£å¦‚æˆ‘å€‘æ‰€çœ‹åˆ°çš„, å‰ä¸‰å€‹ç¤ºä¾‹ (åœ¨è¨“ç·´é›†ä¸­çš„ç´¢å¼• 2ã€3 å’Œ 4 è™•) æ¯å€‹éƒ½çµ¦å‡ºäº†å››å€‹ç‰¹å¾µ, æœ€å¾Œä¸€å€‹ç¤ºä¾‹(åœ¨è¨“ç·´é›†ä¸­çš„ç´¢å¼• 5 è™•) çµ¦å‡ºäº† 7 å€‹ç‰¹å¾µã€‚

æ­¤ä¿¡æ¯å°‡æœ‰åŠ©æ–¼å°‡æˆ‘å€‘ç²å¾—çš„æ¯å€‹ç‰¹å¾µæ˜ å°„åˆ°å…¶ç›¸æ‡‰çš„æ¨™ç±¤ã€‚å¦‚å‰æ‰€è¿°, é€™äº›æ¨™ç±¤æ˜¯:

- `(0, 0)` å¦‚æœç­”æ¡ˆä¸åœ¨ä¸Šä¸‹æ–‡çš„ç›¸æ‡‰ç¯„åœå…§
- `(start_position, end_position)` å¦‚æœç­”æ¡ˆåœ¨ä¸Šä¸‹æ–‡çš„ç›¸æ‡‰ç¯„åœå…§, å‰‡ `start_position` æ˜¯ç­”æ¡ˆé–‹é ­çš„æ¨™è¨˜ç´¢å¼• (åœ¨è¼¸å…¥ ID ä¸­), ä¸¦ä¸” `end_position` æ˜¯ç­”æ¡ˆçµæŸçš„æ¨™è¨˜çš„ç´¢å¼• (åœ¨è¼¸å…¥ ID ä¸­)ã€‚

ç‚ºäº†ç¢ºå®šæ˜¯å“ªç¨®æƒ…æ³ä»¥åŠæ¨™è¨˜çš„ä½ç½®, ä»¥åŠ(å¦‚æœç›¸é—œçš„è©±)æ¨™è¨˜çš„ä½ç½®, æˆ‘å€‘é¦–å…ˆåœ¨è¼¸å…¥ ID ä¸­æ‰¾åˆ°é–‹å§‹å’ŒçµæŸä¸Šä¸‹æ–‡çš„ç´¢å¼•ã€‚æˆ‘å€‘å¯ä»¥ä½¿ç”¨æ¨™è¨˜é¡å‹ ID ä¾†åŸ·è¡Œæ­¤æ“ä½œ, ä½†ç”±æ–¼é€™äº› ID ä¸ä¸€å®šå­˜åœ¨æ–¼æ‰€æœ‰æ¨¡å‹ä¸­ (ä¾‹å¦‚, DistilBERT ä¸éœ€è¦å®ƒå€‘), æˆ‘å€‘å°‡æ”¹ç‚ºä½¿ç”¨æˆ‘å€‘çš„æ¨™è¨˜å™¨è¿”å›çš„ `BatchEncoding` çš„ `sequence_ids()` æ–¹æ³•ã€‚

ä¸€æ—¦æˆ‘å€‘æœ‰äº†é€™äº›æ¨™è¨˜ç´¢å¼•, æˆ‘å€‘å°±æœƒæŸ¥çœ‹ç›¸æ‡‰çš„åç§»é‡, å®ƒå€‘æ˜¯å…©å€‹æ•´æ•¸çš„å…ƒçµ„, è¡¨ç¤ºåŸå§‹ä¸Šä¸‹æ–‡ä¸­çš„å­—ç¬¦ç¯„åœã€‚å› æ­¤, æˆ‘å€‘å¯ä»¥æª¢æ¸¬æ­¤ç‰¹å¾µä¸­çš„ä¸Šä¸‹æ–‡å¡Šæ˜¯åœ¨ç­”æ¡ˆä¹‹å¾Œé–‹å§‹é‚„æ˜¯åœ¨ç­”æ¡ˆé–‹å§‹ä¹‹å‰çµæŸ(åœ¨é€™ç¨®æƒ…æ³ä¸‹, æ¨™ç±¤æ˜¯ `(0, 0)`)ã€‚å¦‚æœä¸æ˜¯é€™æ¨£, æˆ‘å€‘å¾ªç’°æŸ¥æ‰¾ç­”æ¡ˆçš„ç¬¬ä¸€å€‹å’Œæœ€å¾Œä¸€å€‹æ¨™è¨˜:

```py
answers = raw_datasets["train"][2:6]["answers"]
start_positions = []
end_positions = []

for i, offset in enumerate(inputs["offset_mapping"]):
    sample_idx = inputs["overflow_to_sample_mapping"][i]
    answer = answers[sample_idx]
    start_char = answer["answer_start"][0]
    end_char = answer["answer_start"][0] + len(answer["text"][0])
    sequence_ids = inputs.sequence_ids(i)

    # Find the start and end of the context
    idx = 0
    while sequence_ids[idx] != 1:
        idx += 1
    context_start = idx
    while sequence_ids[idx] == 1:
        idx += 1
    context_end = idx - 1

    # If the answer is not fully inside the context, label is (0, 0)
    if offset[context_start][0] > start_char or offset[context_end][1] < end_char:
        start_positions.append(0)
        end_positions.append(0)
    else:
        # Otherwise it's the start and end token positions
        idx = context_start
        while idx <= context_end and offset[idx][0] <= start_char:
            idx += 1
        start_positions.append(idx - 1)

        idx = context_end
        while idx >= context_start and offset[idx][1] >= end_char:
            idx -= 1
        end_positions.append(idx + 1)

start_positions, end_positions
```

```python out
([83, 51, 19, 0, 0, 64, 27, 0, 34, 0, 0, 0, 67, 34, 0, 0, 0, 0, 0],
 [85, 53, 21, 0, 0, 70, 33, 0, 40, 0, 0, 0, 68, 35, 0, 0, 0, 0, 0])
```

è®“æˆ‘å€‘çœ‹ä¸€äº›çµæœä¾†é©—è­‰æˆ‘å€‘çš„æ–¹æ³•æ˜¯å¦æ­£ç¢ºã€‚å°æ–¼æˆ‘å€‘ç™¼ç¾çš„ç¬¬ä¸€å€‹ç‰¹å¾µ, æˆ‘å€‘å°‡ `(83, 85)` ä½œç‚ºæ¨™ç±¤, è®“æˆ‘å€‘å°‡ç†è«–ç­”æ¡ˆèˆ‡å¾ 83 åˆ° 85 (åŒ…æ‹¬)çš„æ¨™è¨˜è§£ç¢¼ç¯„åœé€²è¡Œæ¯”è¼ƒ:

```py
idx = 0
sample_idx = inputs["overflow_to_sample_mapping"][idx]
answer = answers[sample_idx]["text"][0]

start = start_positions[idx]
end = end_positions[idx]
labeled_answer = tokenizer.decode(inputs["input_ids"][idx][start : end + 1])

print(f"Theoretical answer: {answer}, labels give: {labeled_answer}")
```

```python out
'Theoretical answer: the Main Building, labels give: the Main Building'
```

æ‰€ä»¥é€™æ˜¯ä¸€å ´æ¯”è³½! ç¾åœ¨è®“æˆ‘å€‘æª¢æŸ¥ç´¢å¼• 4, æˆ‘å€‘å°‡æ¨™ç±¤è¨­ç½®ç‚º `(0, 0)`, é€™æ„å‘³è‘—ç­”æ¡ˆä¸åœ¨è©²åŠŸèƒ½çš„ä¸Šä¸‹æ–‡å¡Šä¸­

```py
idx = 4
sample_idx = inputs["overflow_to_sample_mapping"][idx]
answer = answers[sample_idx]["text"][0]

decoded_example = tokenizer.decode(inputs["input_ids"][idx])
print(f"Theoretical answer: {answer}, decoded example: {decoded_example}")
```

```python out
'Theoretical answer: a Marian place of prayer and reflection, decoded example: [CLS] What is the Grotto at Notre Dame? [SEP] Architecturally, the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grot [SEP]'
```

äº‹å¯¦ä¸Š, æˆ‘å€‘åœ¨ä¸Šä¸‹æ–‡ä¸­çœ‹ä¸åˆ°ç­”æ¡ˆã€‚

<Tip>

âœï¸ **è¼ªåˆ°ä½ äº†!** ä½¿ç”¨ XLNet æ¶æ§‹æ™‚, åœ¨å·¦å´æ‡‰ç”¨å¡«å……, ä¸¦åˆ‡æ›å•é¡Œå’Œä¸Šä¸‹æ–‡ã€‚å°‡æˆ‘å€‘å‰›å‰›çœ‹åˆ°çš„æ‰€æœ‰ä»£ç¢¼æ”¹ç·¨ç‚º XLNet æ¶æ§‹ (ä¸¦æ·»åŠ  `padding=True`)ã€‚è«‹æ³¨æ„, `[CLS]` æ¨™è¨˜å¯èƒ½ä¸åœ¨æ‡‰ç”¨å¡«å……çš„ 0 ä½ç½®ã€‚

</Tip>

ç¾åœ¨æˆ‘å€‘å·²ç¶“é€æ­¥ç­è§£ç­å¦‚ä½•é è™•ç†æˆ‘å€‘çš„è¨“ç·´æ•¸æ“š, æˆ‘å€‘å¯ä»¥å°‡å…¶åˆ†çµ„åˆ°ä¸€å€‹å‡½æ•¸ä¸­, æˆ‘å€‘å°‡æ‡‰ç”¨æ–¼æ•´å€‹è¨“ç·´æ•¸æ“šé›†ã€‚æˆ‘å€‘æœƒå°‡æ¯å€‹ç‰¹å¾µå¡«å……åˆ°æˆ‘å€‘è¨­ç½®çš„æœ€å¤§é•·åº¦, å› ç‚ºå¤§å¤šæ•¸ä¸Šä¸‹æ–‡æœƒå¾ˆé•· (ä¸¦ä¸”ç›¸æ‡‰çš„æ¨£æœ¬å°‡è¢«åˆ†æˆå¹¾å€‹ç‰¹å¾µ), æ‰€ä»¥åœ¨é€™è£¡æ‡‰ç”¨å‹•æ…‹å¡«å……æ²’æœ‰çœŸæ­£çš„å¥½è™•:

```py
max_length = 384
stride = 128


def preprocess_training_examples(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=max_length,
        truncation="only_second",
        stride=stride,
        return_overflowing_tokens=True,
        return_offsets_mapping=True,
        padding="max_length",
    )

    offset_mapping = inputs.pop("offset_mapping")
    sample_map = inputs.pop("overflow_to_sample_mapping")
    answers = examples["answers"]
    start_positions = []
    end_positions = []

    for i, offset in enumerate(offset_mapping):
        sample_idx = sample_map[i]
        answer = answers[sample_idx]
        start_char = answer["answer_start"][0]
        end_char = answer["answer_start"][0] + len(answer["text"][0])
        sequence_ids = inputs.sequence_ids(i)

        # Find the start and end of the context
        idx = 0
        while sequence_ids[idx] != 1:
            idx += 1
        context_start = idx
        while sequence_ids[idx] == 1:
            idx += 1
        context_end = idx - 1

        # If the answer is not fully inside the context, label is (0, 0)
        if offset[context_start][0] > start_char or offset[context_end][1] < end_char:
            start_positions.append(0)
            end_positions.append(0)
        else:
            # Otherwise it's the start and end token positions
            idx = context_start
            while idx <= context_end and offset[idx][0] <= start_char:
                idx += 1
            start_positions.append(idx - 1)

            idx = context_end
            while idx >= context_start and offset[idx][1] >= end_char:
                idx -= 1
            end_positions.append(idx + 1)

    inputs["start_positions"] = start_positions
    inputs["end_positions"] = end_positions
    return inputs
```

è«‹æ³¨æ„, æˆ‘å€‘å®šç¾©äº†å…©å€‹å¸¸æ•¸ä¾†ç¢ºå®šä½¿ç”¨çš„æœ€å¤§é•·åº¦ä»¥åŠæ»‘å‹•çª—å£çš„é•·åº¦, ä¸¦ä¸”æˆ‘å€‘åœ¨æ¨™è¨˜åŒ–ä¹‹å‰æ·»åŠ äº†ä¸€é»æ¸…ç†: SQuAD æ•¸æ“šé›†ä¸­çš„ä¸€äº›å•é¡Œåœ¨é–‹é ­æœ‰é¡å¤–çš„ç©ºæ ¼, ä¸¦ä¸”ä¸æ·»åŠ ä»»ä½•å…§å®¹çš„çµå°¾ (å¦‚æœä½ ä½¿ç”¨åƒ RoBERTa é€™æ¨£çš„æ¨¡å‹, å‰‡åœ¨æ¨™è¨˜åŒ–æ™‚æœƒä½”ç”¨ç©ºé–“), å› æ­¤æˆ‘å€‘åˆªé™¤äº†é‚£äº›é¡å¤–çš„ç©ºæ ¼ã€‚

ç‚ºäº†å°‡æ­¤å‡½æ•¸æ‡‰ç”¨æ–¼æ•´å€‹è¨“ç·´é›†, æˆ‘å€‘ä½¿ç”¨ `Dataset.map()` æ–¹æ³•èˆ‡ `batched=True` æ¨™èªŒã€‚é€™æ˜¯å¿…è¦çš„, å› ç‚ºæˆ‘å€‘æ­£åœ¨æ›´æ”¹æ•¸æ“šé›†çš„é•·åº¦(å› ç‚ºä¸€å€‹ç¤ºä¾‹å¯ä»¥æä¾›å¤šå€‹è¨“ç·´ç‰¹å¾µ):

```py
train_dataset = raw_datasets["train"].map(
    preprocess_training_examples,
    batched=True,
    remove_columns=raw_datasets["train"].column_names,
)
len(raw_datasets["train"]), len(train_dataset)
```

```python out
(87599, 88729)
```

æ­£å¦‚æˆ‘å€‘æ‰€è¦‹, é è™•ç†å¢åŠ äº†å¤§ç´„ 1,000 å€‹ç‰¹å¾µã€‚æˆ‘å€‘çš„è¨“ç·´é›†ç¾åœ¨å¯ä»¥ä½¿ç”¨äº†-- è®“æˆ‘å€‘æ·±å…¥ç ”ç©¶é©—è­‰é›†çš„é è™•ç†!

### è™•ç†é©—è­‰æ•¸æ“š

é è™•ç†é©—è­‰æ•¸æ“šæœƒç¨å¾®å®¹æ˜“ä¸€äº›, å› ç‚ºæˆ‘å€‘ä¸éœ€è¦ç”Ÿæˆæ¨™ç±¤(é™¤éæˆ‘å€‘æƒ³è¨ˆç®—é©—è­‰æå¤±, ä½†é€™å€‹æ•¸å­—ä¸¦ä¸èƒ½çœŸæ­£å¹«åŠ©æˆ‘å€‘ç†è§£æ¨¡å‹æœ‰å¤šå¥½)ã€‚çœŸæ­£çš„æ¨‚è¶£æ˜¯å°‡æ¨¡å‹çš„é æ¸¬è§£é‡‹ç‚ºåŸå§‹ä¸Šä¸‹æ–‡çš„è·¨åº¦ã€‚ç‚ºæ­¤, æˆ‘å€‘åªéœ€è¦å­˜å„²åç§»æ˜ å°„å’ŒæŸç¨®æ–¹å¼ä¾†å°‡æ¯å€‹å‰µå»ºçš„ç‰¹å¾µèˆ‡å®ƒä¾†è‡ªçš„åŸå§‹ç¤ºä¾‹ç›¸åŒ¹é…ã€‚ç”±æ–¼åŸå§‹æ•¸æ“šé›†ä¸­æœ‰ä¸€å€‹ ID åˆ—, æˆ‘å€‘å°‡ä½¿ç”¨è©² IDã€‚

æˆ‘å€‘å°‡åœ¨é€™è£¡æ·»åŠ çš„å”¯ä¸€å…§å®¹æ˜¯å°åç§»æ˜ å°„çš„ä¸€é»é»æ¸…ç†ã€‚å®ƒå€‘å°‡åŒ…å«å•é¡Œå’Œä¸Šä¸‹æ–‡çš„åç§»é‡, ä½†æ˜¯ä¸€æ—¦æˆ‘å€‘é€²å…¥å¾Œè™•ç†éšæ®µ, æˆ‘å€‘å°‡ç„¡æ³•çŸ¥é“è¼¸å…¥ ID çš„å“ªä¸€éƒ¨åˆ†å°æ‡‰æ–¼ä¸Šä¸‹æ–‡ä»¥åŠå“ªä¸€éƒ¨åˆ†æ˜¯å•é¡Œ(æˆ‘å€‘ä½¿ç”¨çš„ `sequence_ids()` æ–¹æ³•åƒ…å¯ç”¨æ–¼æ¨™è¨˜å™¨çš„è¼¸å‡º)ã€‚å› æ­¤, æˆ‘å€‘å°‡èˆ‡å•é¡Œå°æ‡‰çš„åç§»é‡è¨­ç½®ç‚º `None`:

```py
def preprocess_validation_examples(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=max_length,
        truncation="only_second",
        stride=stride,
        return_overflowing_tokens=True,
        return_offsets_mapping=True,
        padding="max_length",
    )

    sample_map = inputs.pop("overflow_to_sample_mapping")
    example_ids = []

    for i in range(len(inputs["input_ids"])):
        sample_idx = sample_map[i]
        example_ids.append(examples["id"][sample_idx])

        sequence_ids = inputs.sequence_ids(i)
        offset = inputs["offset_mapping"][i]
        inputs["offset_mapping"][i] = [
            o if sequence_ids[k] == 1 else None for k, o in enumerate(offset)
        ]

    inputs["example_id"] = example_ids
    return inputs
```

æˆ‘å€‘å¯ä»¥åƒä»¥å‰ä¸€æ¨£å°‡æ­¤å‡½æ•¸æ‡‰ç”¨æ–¼æ•´å€‹é©—è­‰æ•¸æ“šé›†:

```py
validation_dataset = raw_datasets["validation"].map(
    preprocess_validation_examples,
    batched=True,
    remove_columns=raw_datasets["validation"].column_names,
)
len(raw_datasets["validation"]), len(validation_dataset)
```

```python out
(10570, 10822)
```

Iåœ¨é€™ç¨®æƒ…æ³ä¸‹, æˆ‘å€‘åªæ·»åŠ äº†å¹¾ç™¾å€‹æ¨£æœ¬, å› æ­¤é©—è­‰æ•¸æ“šé›†ä¸­çš„ä¸Šä¸‹æ–‡ä¼¼ä¹æœ‰é»çŸ­ã€‚

ç¾åœ¨æˆ‘å€‘å·²ç¶“å°æ‰€æœ‰æ•¸æ“šé€²è¡Œäº†é è™•ç†, æˆ‘å€‘å¯ä»¥é–‹å§‹è¨“ç·´äº†ã€‚

{#if fw === 'pt'}

## ä½¿ç”¨ `Trainer` API å¾®èª¿æ¨¡å‹

é€™å€‹ä¾‹å­çš„è¨“ç·´ä»£ç¢¼çœ‹èµ·ä¾†å¾ˆåƒå‰é¢å¹¾ç¯€ä¸­çš„ä»£ç¢¼ -- æœ€é›£çš„æ˜¯ç·¨å¯« `compute_metrics()` å‡½æ•¸ã€‚ç”±æ–¼æˆ‘å€‘å°‡æ‰€æœ‰æ¨£æœ¬å¡«å……åˆ°æˆ‘å€‘è¨­ç½®çš„æœ€å¤§é•·åº¦, å› æ­¤æ²’æœ‰æ•¸æ“šæ•´ç†å™¨è¦å®šç¾©, æ‰€ä»¥é€™å€‹åº¦é‡è¨ˆç®—çœŸçš„æ˜¯æˆ‘å€‘å”¯ä¸€éœ€è¦æ“”å¿ƒçš„äº‹æƒ…ã€‚å›°é›£çš„éƒ¨åˆ†æ˜¯å°‡æ¨¡å‹é æ¸¬å¾Œè™•ç†ç‚ºåŸå§‹ç¤ºä¾‹ä¸­çš„æ–‡æœ¬ç¯„åœ; ä¸€æ—¦æˆ‘å€‘é€™æ¨£åšäº†, ğŸ¤— Datasets åº«ä¸­çš„æŒ‡æ¨™å°‡ç‚ºæˆ‘å€‘å®Œæˆå¤§éƒ¨åˆ†å·¥ä½œã€‚

{:else}

## ä½¿ç”¨ Keras å¾®èª¿æ¨¡å‹

é€™å€‹ç¤ºä¾‹çš„è¨“ç·´ä»£ç¢¼çœ‹èµ·ä¾†å¾ˆåƒå‰å¹¾ç¯€ä¸­çš„ä»£ç¢¼, ä½†æ˜¯è¨ˆç®—æŒ‡æ¨™å°‡æ˜¯å”¯ä¸€çš„æŒ‘æˆ°ã€‚å› ç‚ºæˆ‘å€‘å°‡æ‰€æœ‰çš„æ¨£æœ¬å¡«å……åˆ°æˆ‘å€‘è¨­ç½®çš„æœ€å¤§é•·åº¦, æ‰€ä»¥ä¸éœ€è¦å®šç¾©æ•¸æ“šæ•´ç†å™¨, æ‰€ä»¥é€™å€‹åº¦é‡è¨ˆç®—å¯¦éš›ä¸Šæ˜¯æˆ‘å€‘å”¯ä¸€éœ€è¦æ“”å¿ƒçš„äº‹æƒ…ã€‚å›°é›£çš„éƒ¨åˆ†æ˜¯å°‡æ¨¡å‹é æ¸¬å¾Œè™•ç†æˆåŸå§‹ä¾‹å­ä¸­çš„æ–‡æœ¬ç¯„åœ; ä¸€æ—¦æˆ‘å€‘å®Œæˆäº†é€™äº›, ğŸ¤— Datasets åº«ä¸­çš„æŒ‡æ¨™å°‡ç‚ºæˆ‘å€‘å®Œæˆå¤§éƒ¨åˆ†å·¥ä½œã€‚

{/if}

### å¾Œè™•ç†

{#if fw === 'pt'}

<Youtube id="BNy08iIWVJM"/>

{:else}

<Youtube id="VN67ZpN33Ss"/>

{/if}

è©²æ¨¡å‹å°‡åœ¨è¼¸å…¥IDä¸­ç‚ºç­”æ¡ˆçš„é–‹å§‹å’ŒçµæŸä½ç½®è¼¸å‡ºLogit, æ­£å¦‚æˆ‘å€‘åœ¨æ¢ç´¢ [`question-answering` pipeline](/course/chapter6/4) æ™‚çœ‹åˆ°çš„é‚£æ¨£ã€‚å¾Œè™•ç†æ­¥é©Ÿå°‡é¡ä¼¼æ–¼æˆ‘å€‘åœ¨é‚£è£¡æ‰€åšçš„, æ‰€ä»¥é€™è£¡æ˜¯æˆ‘å€‘æ¡å–çš„è¡Œå‹•çš„å¿«é€Ÿæé†’:

- æˆ‘å€‘å±è”½äº†èˆ‡ä¸Šä¸‹æ–‡ä¹‹å¤–çš„æ¨™è¨˜ç›¸å°æ‡‰çš„é–‹å§‹å’ŒçµæŸ logitsã€‚
- ç„¶å¾Œ, æˆ‘å€‘ä½¿ç”¨ softmax å°‡é–‹å§‹å’ŒçµæŸ logits è½‰æ›ç‚ºæ¦‚ç‡ã€‚
- æˆ‘å€‘é€šéå–å°æ‡‰çš„å…©å€‹æ¦‚ç‡çš„ä¹˜ç©ä¾†çµ¦æ¯å€‹ `(start_token, end_token)` çµ„åˆè³¦å€¼ã€‚
- æˆ‘å€‘å°‹æ‰¾ç”¢ç”Ÿæœ‰æ•ˆç­”æ¡ˆçš„æœ€é«˜åˆ†æ•¸çš„é…å° (ä¾‹å¦‚, `start_token` ä½æ–¼ `end_token`)ã€‚

åœ¨é€™è£¡, æˆ‘å€‘å°‡ç¨å¾®æ”¹è®Šé€™å€‹éç¨‹, å› ç‚ºæˆ‘å€‘ä¸éœ€è¦è¨ˆç®—å¯¦éš›åˆ†æ•¸ (åªæ˜¯é æ¸¬çš„ç­”æ¡ˆ)ã€‚é€™æ„å‘³è‘—æˆ‘å€‘å¯ä»¥è·³é softmax æ­¥é©Ÿã€‚ç‚ºäº†æ›´å¿«, æˆ‘å€‘ä¹Ÿä¸æœƒå°æ‰€æœ‰å¯èƒ½çš„ `(start_token, end_token)` å°é€²è¡Œè©•åˆ†, è€Œåªæœƒå°å°æ‡‰æ–¼æœ€é«˜ `n_best` çš„é‚£äº›å°é€²è¡Œè©•åˆ† (ä½¿ç”¨ `n_best=20`)ã€‚ç”±æ–¼æˆ‘å€‘å°‡è·³é softmax, å› æ­¤é€™äº›åˆ†æ•¸å°‡æ˜¯ logit åˆ†æ•¸, ä¸¦ä¸”å°‡é€šéå– start å’Œ end logits çš„ç¸½å’Œä¾†ç²å¾— (è€Œä¸æ˜¯ä¹˜ç©, å› ç‚ºè¦å‰‡ \\(\log(ab) = \log(a) + \log(b)\\))ã€‚

ç‚ºäº†è­‰æ˜é€™ä¸€åˆ‡, æˆ‘å€‘éœ€è¦ä¸€äº›é æ¸¬ã€‚ç”±æ–¼æˆ‘å€‘é‚„æ²’æœ‰è¨“ç·´æˆ‘å€‘çš„æ¨¡å‹, æˆ‘å€‘å°‡ä½¿ç”¨ QA ç®¡é“çš„é»˜èªæ¨¡å‹å°ä¸€å°éƒ¨åˆ†é©—è­‰é›†ç”Ÿæˆä¸€äº›é æ¸¬ã€‚æˆ‘å€‘å¯ä»¥ä½¿ç”¨å’Œä¹‹å‰ä¸€æ¨£çš„è™•ç†å‡½æ•¸; å› ç‚ºå®ƒä¾è³´æ–¼å…¨å±€å¸¸é‡ `tokenizer`, æˆ‘å€‘åªéœ€å°‡è©²å°è±¡æ›´æ”¹ç‚ºæˆ‘å€‘è¦è‡¨æ™‚ä½¿ç”¨çš„æ¨¡å‹çš„æ¨™è¨˜å™¨:

```python
small_eval_set = raw_datasets["validation"].select(range(100))
trained_checkpoint = "distilbert-base-cased-distilled-squad"

tokenizer = AutoTokenizer.from_pretrained(trained_checkpoint)
eval_set = small_eval_set.map(
    preprocess_validation_examples,
    batched=True,
    remove_columns=raw_datasets["validation"].column_names,
)
```

ç¾åœ¨é è™•ç†å·²ç¶“å®Œæˆ, æˆ‘å€‘å°‡åˆ†è©å™¨æ”¹å›æˆ‘å€‘æœ€åˆé¸æ“‡çš„é‚£å€‹:

```python
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)
```

ç„¶å¾Œ, æˆ‘å€‘åˆªé™¤ `eval_set` ä¸­æ¨¡å‹ä¸æœŸå¾…çš„åˆ—, ç”¨æ‰€æœ‰çš„å°é©—è­‰é›†æ§‹å»ºä¸€å€‹æ‰¹æ¬¡, ç„¶å¾Œé€šéæ¨¡å‹ã€‚å¦‚æœ GPU å¯ç”¨, æˆ‘å€‘æœƒä½¿ç”¨å®ƒä¾†åŠ å¿«é€Ÿåº¦:

{#if fw === 'pt'}

```python
import torch
from transformers import AutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns(["example_id", "offset_mapping"])
eval_set_for_model.set_format("torch")

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
batch = {k: eval_set_for_model[k].to(device) for k in eval_set_for_model.column_names}
trained_model = AutoModelForQuestionAnswering.from_pretrained(trained_checkpoint).to(
    device
)

with torch.no_grad():
    outputs = trained_model(**batch)
```

ç”±æ–¼ `Trainer` å°‡ç‚ºæˆ‘å€‘æä¾› NumPy æ•¸çµ„çš„é æ¸¬, æˆ‘å€‘ç²å–é–‹å§‹å’ŒçµæŸ logits ä¸¦å°‡å®ƒå€‘è½‰æ›ç‚ºè©²æ ¼å¼

```python
start_logits = outputs.start_logits.cpu().numpy()
end_logits = outputs.end_logits.cpu().numpy()
```

{:else}

```python
import tensorflow as tf
from transformers import TFAutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns(["example_id", "offset_mapping"])
eval_set_for_model.set_format("numpy")

batch = {k: eval_set_for_model[k] for k in eval_set_for_model.column_names}
trained_model = TFAutoModelForQuestionAnswering.from_pretrained(trained_checkpoint)

outputs = trained_model(**batch)
```

ç‚ºäº†ä¾¿æ–¼å¯¦é©—, è®“æˆ‘å€‘å°‡é€™äº›è¼¸å‡ºè½‰æ›ç‚º NumPy æ•¸çµ„:

```python
start_logits = outputs.start_logits.numpy()
end_logits = outputs.end_logits.numpy()
```

{/if}

ç¾åœ¨, æˆ‘å€‘éœ€è¦åœ¨ `small_eval_set` ä¸­æ‰¾åˆ°æ¯å€‹ç¤ºä¾‹çš„é æ¸¬ç­”æ¡ˆã€‚ä¸€å€‹ç¤ºä¾‹å¯èƒ½å·²ç¶“åœ¨  `eval_set` ä¸­æ‹†åˆ†ç‚ºå¤šå€‹ç‰¹å¾µ, å› æ­¤ç¬¬ä¸€æ­¥æ˜¯å°‡ `small_eval_set` ä¸­çš„æ¯å€‹ç¤ºä¾‹æ˜ å°„åˆ° `eval_set` ä¸­ç›¸æ‡‰çš„ç‰¹å¾µ:

```python
import collections

example_to_features = collections.defaultdict(list)
for idx, feature in enumerate(eval_set):
    example_to_features[feature["example_id"]].append(idx)
```

æœ‰äº†é€™å€‹, æˆ‘å€‘å°±å¯ä»¥çœŸæ­£é–‹å§‹å·¥ä½œ, å¾ªç’°éæ­·æ‰€æœ‰ç¤ºä¾‹, ä½µç‚ºæ¯å€‹ç¤ºä¾‹éæ­·æ‰€æœ‰ç›¸é—œåŠŸèƒ½ã€‚æ­£å¦‚æˆ‘å€‘ä¹‹å‰æ‰€èªª, æˆ‘å€‘å°‡æŸ¥çœ‹ `n_best` é–‹å§‹ logits å’ŒçµæŸ logits çš„ logit åˆ†æ•¸, ä¸åŒ…æ‹¬ä»¥ä¸‹çš„ä½ç½®:

- ä¸€å€‹ä¸åœ¨ä¸Šä¸‹æ–‡ä¸­çš„ç­”æ¡ˆ
- é•·åº¦ç‚ºè² çš„ç­”æ¡ˆ
- ç­”æ¡ˆå¤ªé•· (æˆ‘å€‘å°‡å¯èƒ½æ€§é™åˆ¶åœ¨ `max_answer_length=30`)

ä¸€æ—¦æˆ‘å€‘ç‚ºä¸€å€‹ç¤ºä¾‹ç²å¾—äº†æ‰€æœ‰å¯èƒ½çš„ç­”æ¡ˆ, æˆ‘å€‘åªéœ€é¸æ“‡ä¸€å€‹å…·æœ‰æœ€ä½³ logit åˆ†æ•¸çš„ç­”æ¡ˆ:

```python
import numpy as np

n_best = 20
max_answer_length = 30
predicted_answers = []

for example in small_eval_set:
    example_id = example["id"]
    context = example["context"]
    answers = []

    for feature_index in example_to_features[example_id]:
        start_logit = start_logits[feature_index]
        end_logit = end_logits[feature_index]
        offsets = eval_set["offset_mapping"][feature_index]

        start_indexes = np.argsort(start_logit)[-1 : -n_best - 1 : -1].tolist()
        end_indexes = np.argsort(end_logit)[-1 : -n_best - 1 : -1].tolist()
        for start_index in start_indexes:
            for end_index in end_indexes:
                # Skip answers that are not fully in the context
                if offsets[start_index] is None or offsets[end_index] is None:
                    continue
                # Skip answers with a length that is either < 0 or > max_answer_length.
                if (
                    end_index < start_index
                    or end_index - start_index + 1 > max_answer_length
                ):
                    continue

                answers.append(
                    {
                        "text": context[offsets[start_index][0] : offsets[end_index][1]],
                        "logit_score": start_logit[start_index] + end_logit[end_index],
                    }
                )

    best_answer = max(answers, key=lambda x: x["logit_score"])
    predicted_answers.append({"id": example_id, "prediction_text": best_answer["text"]})
```

é æ¸¬ç­”æ¡ˆçš„æœ€çµ‚æ ¼å¼æ˜¯æˆ‘å€‘å°‡ä½¿ç”¨çš„åº¦é‡æ¨™æº–æ‰€æœŸæœ›çš„æ ¼å¼ã€‚åƒå¾€å¸¸ä¸€æ¨£, æˆ‘å€‘å¯ä»¥åœ¨ ğŸ¤— Datasets åº«çš„å¹«åŠ©ä¸‹åŠ è¼‰å®ƒ:

```python
from datasets import load_metric

metric = load_metric("squad")
```

è©²æŒ‡æ¨™æœŸæœ›æˆ‘å€‘ä¸Šé¢çœ‹åˆ°çš„æ ¼å¼çš„é æ¸¬ç­”æ¡ˆ (ä¸€å€‹å­—å…¸åˆ—è¡¨, å…¶ä¸­ä¸€å€‹éµç”¨æ–¼ç¤ºä¾‹ ID, ä¸€å€‹éµç”¨æ–¼é æ¸¬æ–‡æœ¬) å’Œä»¥ä¸‹æ ¼å¼çš„ç†è«–ç­”æ¡ˆ (ä¸€å€‹å­—å…¸åˆ—è¡¨, ä¸€å€‹éµç¤ºä¾‹çš„ ID å’Œå¯èƒ½ç­”æ¡ˆçš„ä¸€éµ):

```python
theoretical_answers = [
    {"id": ex["id"], "answers": ex["answers"]} for ex in small_eval_set
]
```

æˆ‘å€‘ç¾åœ¨å¯ä»¥é€šéæŸ¥çœ‹å…©å€‹åˆ—è¡¨çš„ç¬¬ä¸€å€‹å…ƒç´ ä¾†æª¢æŸ¥æˆ‘å€‘æ˜¯å¦å¾—åˆ°äº†åˆç†çš„çµæœ:

```python
print(predicted_answers[0])
print(theoretical_answers[0])
```

```python out
{'id': '56be4db0acb8001400a502ec', 'prediction_text': 'Denver Broncos'}
{'id': '56be4db0acb8001400a502ec', 'answers': {'text': ['Denver Broncos', 'Denver Broncos', 'Denver Broncos'], 'answer_start': [177, 177, 177]}}
```

é‚„ä¸éŒ¯! ç¾åœ¨è®“æˆ‘å€‘çœ‹çœ‹é€™å€‹æŒ‡æ¨™çµ¦æˆ‘å€‘çš„åˆ†æ•¸:

```python
metric.compute(predictions=predicted_answers, references=theoretical_answers)
```

```python out
{'exact_match': 83.0, 'f1': 88.25}
```

åŒæ¨£, è€ƒæ…®åˆ°æ ¹æ“š [its paper](https://arxiv.org/abs/1910.01108v2), åœ¨ SQuAD ä¸Šå¾®èª¿çš„ DistilBERT åœ¨æ•´å€‹æ•¸æ“šé›†ä¸Šçš„å¾—åˆ†åˆ†åˆ¥ç‚º 79.1 å’Œ 86.9, é€™æ˜¯ç›¸ç•¶ä¸éŒ¯çš„ã€‚

{#if fw === 'pt'}

ç¾åœ¨, è®“æˆ‘å€‘æŠŠå‰›æ‰æ‰€åšçš„ä¸€åˆ‡æ”¾åœ¨ `compute_metrics()` å‡½æ•¸ä¸­, æˆ‘å€‘å°‡åœ¨ `Trainer` ä¸­ä½¿ç”¨å®ƒã€‚é€šå¸¸, `compute_metrics()` å‡½æ•¸åªæ¥æ”¶ä¸€å€‹åŒ…å« logits å’Œ labels çš„å…ƒçµ„ `eval_preds`ã€‚é€™è£¡æˆ‘å€‘éœ€è¦æ›´å¤š, å› ç‚ºæˆ‘å€‘å¿…é ˆåœ¨ç‰¹å¾µæ•¸æ“šé›†ä¸­æŸ¥æ‰¾åç§»é‡, åœ¨åŸå§‹ä¸Šä¸‹æ–‡çš„ç¤ºä¾‹æ•¸æ“šé›†ä¸­æŸ¥æ‰¾, å› æ­¤æˆ‘å€‘å°‡ç„¡æ³•åœ¨è¨“ç·´æœŸé–“ä½¿ç”¨æ­¤å‡½æ•¸ç²å¾—å¸¸è¦è©•ä¼°çµæœã€‚æˆ‘å€‘åªæœƒåœ¨è¨“ç·´çµæŸæ™‚ä½¿ç”¨å®ƒä¾†æª¢æŸ¥çµæœã€‚

`compute_metrics()` å‡½æ•¸å°‡èˆ‡å‰é¢ç›¸åŒçš„æ­¥é©Ÿåˆ†çµ„; æˆ‘å€‘åªæ˜¯æ·»åŠ ä¸€å€‹å°æª¢æŸ¥, ä»¥é˜²æˆ‘å€‘æ²’æœ‰æå‡ºä»»ä½•æœ‰æ•ˆçš„ç­”æ¡ˆ (åœ¨é€™ç¨®æƒ…æ³ä¸‹, æˆ‘å€‘é æ¸¬ä¸€å€‹ç©ºå­—ç¬¦ä¸²)ã€‚

{:else}

ç¾åœ¨, è®“æˆ‘å€‘å°‡å‰›æ‰æ‰€åšçš„ä¸€åˆ‡æ”¾å…¥ `compute_metrics()` å‡½æ•¸ä¸­, æˆ‘å€‘å°‡åœ¨è¨“ç·´æ¨¡å‹å¾Œä½¿ç”¨è©²å‡½æ•¸ã€‚æˆ‘å€‘éœ€è¦å‚³éçš„ä¸åƒ…åƒ…æ˜¯è¼¸å‡ºæ—¥èªŒ, å› ç‚ºæˆ‘å€‘å¿…é ˆåœ¨ç‰¹å¾µæ•¸æ“šé›†ä¸­å°‹æ‰¾åç§»é‡, åœ¨åŸå§‹ä¸Šä¸‹æ–‡çš„ç¤ºä¾‹æ•¸æ“šé›†ä¸­å°‹æ‰¾:

{/if}

```python
from tqdm.auto import tqdm


def compute_metrics(start_logits, end_logits, features, examples):
    example_to_features = collections.defaultdict(list)
    for idx, feature in enumerate(features):
        example_to_features[feature["example_id"]].append(idx)

    predicted_answers = []
    for example in tqdm(examples):
        example_id = example["id"]
        context = example["context"]
        answers = []

        # Loop through all features associated with that example
        for feature_index in example_to_features[example_id]:
            start_logit = start_logits[feature_index]
            end_logit = end_logits[feature_index]
            offsets = features[feature_index]["offset_mapping"]

            start_indexes = np.argsort(start_logit)[-1 : -n_best - 1 : -1].tolist()
            end_indexes = np.argsort(end_logit)[-1 : -n_best - 1 : -1].tolist()
            for start_index in start_indexes:
                for end_index in end_indexes:
                    # Skip answers that are not fully in the context
                    if offsets[start_index] is None or offsets[end_index] is None:
                        continue
                    # Skip answers with a length that is either < 0 or > max_answer_length
                    if (
                        end_index < start_index
                        or end_index - start_index + 1 > max_answer_length
                    ):
                        continue

                    answer = {
                        "text": context[offsets[start_index][0] : offsets[end_index][1]],
                        "logit_score": start_logit[start_index] + end_logit[end_index],
                    }
                    answers.append(answer)

        # Select the answer with the best score
        if len(answers) > 0:
            best_answer = max(answers, key=lambda x: x["logit_score"])
            predicted_answers.append(
                {"id": example_id, "prediction_text": best_answer["text"]}
            )
        else:
            predicted_answers.append({"id": example_id, "prediction_text": ""})

    theoretical_answers = [{"id": ex["id"], "answers": ex["answers"]} for ex in examples]
    return metric.compute(predictions=predicted_answers, references=theoretical_answers)
```

æˆ‘å€‘å¯ä»¥æª¢æŸ¥å®ƒæ˜¯å¦é©ç”¨æ–¼æˆ‘å€‘çš„é æ¸¬:

```python
compute_metrics(start_logits, end_logits, eval_set, small_eval_set)
```

```python out
{'exact_match': 83.0, 'f1': 88.25}
```

çœ‹èµ·ä¾†ä¸éŒ¯! ç¾åœ¨è®“æˆ‘å€‘ç”¨å®ƒä¾†å¾®èª¿æˆ‘å€‘çš„æ¨¡å‹ã€‚

### å¾®èª¿æ¨¡å‹

{#if fw === 'pt'}

æˆ‘å€‘ç¾åœ¨æº–å‚™å¥½è¨“ç·´æˆ‘å€‘çš„æ¨¡å‹äº†ã€‚è®“æˆ‘å€‘é¦–å…ˆå‰µå»ºå®ƒ, åƒä»¥å‰ä¸€æ¨£ä½¿ç”¨ `AutoModelForQuestionAnswering` é¡:

```python
model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)
```

{:else}

æˆ‘å€‘ç¾åœ¨æº–å‚™å¥½è¨“ç·´æˆ‘å€‘çš„æ¨¡å‹äº†ã€‚è®“æˆ‘å€‘é¦–å…ˆå‰µå»ºå®ƒ, åƒä»¥å‰ä¸€æ¨£ä½¿ç”¨ `TFAutoModelForQuestionAnswering` é¡:

```python
model = TFAutoModelForQuestionAnswering.from_pretrained(model_checkpoint)
```

{/if}

åƒå¾€å¸¸ä¸€æ¨£, æˆ‘å€‘æ”¶åˆ°ä¸€å€‹è­¦å‘Š, æœ‰äº›æ¬Šé‡æ²’æœ‰ä½¿ç”¨(ä¾†è‡ªé è¨“ç·´é ­çš„), è€Œå¦ä¸€äº›æ˜¯éš¨æ©Ÿåˆå§‹åŒ–çš„ (ç”¨æ–¼å•ç­”é ­çš„)ã€‚ä½ ç¾åœ¨æ‡‰è©²å·²ç¶“ç¿’æ…£äº†, ä½†é€™æ„å‘³è‘—é€™å€‹æ¨¡å‹é‚„æ²’æœ‰æº–å‚™å¥½ä½¿ç”¨, éœ€è¦å¾®èª¿ -- æˆ‘å€‘å³å°‡é€™æ¨£åš!

ç‚ºäº†èƒ½å¤ å°‡æˆ‘å€‘çš„æ¨¡å‹æ¨é€åˆ° Hub, æˆ‘å€‘éœ€è¦ç™»éŒ„ Hugging Faceã€‚ å¦‚æœä½ åœ¨ç­†è¨˜æœ¬ä¸­é‹è¡Œæ­¤ä»£ç¢¼, å‰‡å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å¯¦ç”¨ç¨‹åºå‡½æ•¸åŸ·è¡Œæ­¤æ“ä½œ, è©²å‡½æ•¸æœƒé¡¯ç¤ºä¸€å€‹å°éƒ¨ä»¶, ä½ å¯ä»¥åœ¨å…¶ä¸­è¼¸å…¥ç™»éŒ„æ†‘æ“š:

```python
from huggingface_hub import notebook_login

notebook_login()
```

å¦‚æœä½ ä¸åœ¨ç­†è¨˜æœ¬ä¸­å·¥ä½œ, åªéœ€åœ¨çµ‚ç«¯ä¸­éµå…¥ä»¥ä¸‹è¡Œ:

```bash
huggingface-cli login
```

{#if fw === 'pt'}

å®Œæˆå¾Œ, æˆ‘å€‘å°±å¯ä»¥å®šç¾©æˆ‘å€‘çš„ `TrainingArguments`ã€‚æ­£å¦‚æˆ‘å€‘åœ¨å®šç¾©å‡½æ•¸ä¾†è¨ˆç®—åº¦é‡æ™‚æ‰€èªªçš„é‚£æ¨£, ç”±æ–¼ `compute_metrics()` å‡½æ•¸çš„ç°½å, æˆ‘å€‘å°‡ä¸èƒ½æœ‰å¸¸è¦çš„æ±‚å€¼å¾ªç’°ã€‚æˆ‘å€‘å¯ä»¥ç·¨å¯« `Trainer` çš„å­é¡ä¾†å®Œæˆé€™ä¸€ä»»å‹™(ä½ å¯ä»¥åœ¨ [question answering example script](https://github.com/huggingface/transformers/blob/master/examples/pytorch/question-answering/trainer_qa.py)ä¸­æ‰¾åˆ°ä¸€ç¨®æ–¹æ³•), ä½†é€™å°æ–¼æœ¬ç¯€ä¾†èªªæœ‰é»å¤ªé•·äº†ã€‚ç›¸å, æˆ‘å€‘åªæœƒåœ¨è¨“ç·´çµæŸæ™‚è©•ä¼°æ¨¡å‹, ä¸¦åœ¨ä¸‹é¢çš„"è‡ªå®šç¾©è¨“ç·´å¾ªç’°"å‘ä½ å±•ç¤ºå¦‚ä½•é€²è¡Œå¸¸è¦è©•ä¼°ã€‚

Té€™ç¢ºå¯¦æ™‚ `Trainer` API é¡¯ç¤ºå…¶ä¾·é™æ€§å’Œ ğŸ¤— Accelerate åº«çš„äº®é»æ‰€åœ¨: æ ¹æ“šç‰¹å®šç”¨ä¾‹è‡ªå®šç¾©é¡å¯èƒ½å¾ˆç—›è‹¦, ä½†èª¿æ•´å®Œå…¨å…¬é–‹çš„è¨“ç·´å¾ªç’°å¾ˆå®¹æ˜“ã€‚

ä¾†çœ‹çœ‹æˆ‘å€‘çš„ `TrainingArguments`:

```python
from transformers import TrainingArguments

args = TrainingArguments(
    "bert-finetuned-squad",
    evaluation_strategy="no",
    save_strategy="epoch",
    learning_rate=2e-5,
    num_train_epochs=3,
    weight_decay=0.01,
    fp16=True,
    push_to_hub=True,
)
```

æˆ‘å€‘ä¹‹å‰å·²ç¶“çœ‹åˆ°äº†å…¶ä¸­çš„å¤§éƒ¨åˆ†: æˆ‘å€‘è¨­ç½®äº†ä¸€äº›è¶…åƒæ•¸ (æ¯”å¦‚å­¸ç¿’ç‡ã€è¨“ç·´çš„ epoch æ•¸å’Œä¸€äº›æ¬Šé‡è¡°æ¸›), ä¸¦è¡¨æ˜æˆ‘å€‘å¸Œæœ›åœ¨æ¯å€‹ epoch çµæŸæ™‚ä¿å­˜æ¨¡å‹, è·³éè©•ä¼°, ä¸¦å°‡æˆ‘å€‘çš„çµæœä¸Šå‚³åˆ°æ¨¡å‹ä¸­å¿ƒã€‚æˆ‘å€‘é‚„ä½¿ç”¨ `fp16=True` å•Ÿç”¨æ··åˆç²¾åº¦è¨“ç·´, å› ç‚ºå®ƒå¯ä»¥åœ¨æœ€è¿‘çš„ GPU ä¸Šå¾ˆå¥½åœ°åŠ å¿«è¨“ç·´é€Ÿåº¦ã€‚

{:else}

ç¾åœ¨, æˆ‘å€‘å¯ä»¥å‰µå»ºæˆ‘å€‘çš„ TF æ•¸æ“šé›†ã€‚é€™æ¬¡æˆ‘å€‘å¯ä»¥ä½¿ç”¨ç°¡å–®çš„é»˜èªæ•¸æ“šæ•´ç†å™¨:

```python
from transformers import DefaultDataCollator

data_collator = DefaultDataCollator(return_tensors="tf")
```

ç¾åœ¨æˆ‘å€‘åƒå¾€å¸¸ä¸€æ¨£å‰µå»ºæ•¸æ“šé›†ã€‚

```python
tf_train_dataset = train_dataset.to_tf_dataset(
    columns=[
        "input_ids",
        "start_positions",
        "end_positions",
        "attention_mask",
        "token_type_ids",
    ],
    collate_fn=data_collator,
    shuffle=True,
    batch_size=16,
)
tf_eval_dataset = validation_dataset.to_tf_dataset(
    columns=["input_ids", "attention_mask", "token_type_ids"],
    collate_fn=data_collator,
    shuffle=False,
    batch_size=16,
)
```

æ¥ä¸‹ä¾†, æˆ‘å€‘è¨­ç½®äº†æˆ‘å€‘çš„è¨“ç·´è¶…åƒæ•¸ä¸¦ç·¨è­¯äº†æˆ‘å€‘çš„æ¨¡å‹:

```python
from transformers import create_optimizer
from transformers.keras_callbacks import PushToHubCallback
import tensorflow as tf

# The number of training steps is the number of samples in the dataset, divided by the batch size then multiplied
# by the total number of epochs. Note that the tf_train_dataset here is a batched tf.data.Dataset,
# not the original Hugging Face Dataset, so its len() is already num_samples // batch_size.
num_train_epochs = 3
num_train_steps = len(tf_train_dataset) * num_train_epochs
optimizer, schedule = create_optimizer(
    init_lr=2e-5,
    num_warmup_steps=0,
    num_train_steps=num_train_steps,
    weight_decay_rate=0.01,
)
model.compile(optimizer=optimizer)

# Train in mixed-precision float16
tf.keras.mixed_precision.set_global_policy("mixed_float16")
```

æœ€å¾Œ, æˆ‘å€‘æº–å‚™å¥½ä½¿ç”¨ `model.fit()` é€²è¡Œè¨“ç·´äº†ã€‚æˆ‘å€‘ä½¿ç”¨ `PushToHubCallback` åœ¨æ¯å€‹æ™‚æœŸä¹‹å¾Œå°‡æ¨¡å‹ä¸Šå‚³åˆ°Hubã€‚

{/if}

é»˜èªæƒ…æ³ä¸‹, ä½¿ç”¨çš„å­˜å„²åº«å°‡åœ¨æ‚¨çš„å‘½åç©ºé–“ä¸­, ä¸¦ä»¥æ‚¨è¨­ç½®çš„è¼¸å‡ºç›®éŒ„å‘½å, å› æ­¤åœ¨æˆ‘å€‘çš„ä¾‹å­ä¸­, å®ƒå°‡åœ¨ `"sgugger/bert-finetuned-squad"` ä¸­ã€‚æˆ‘å€‘å¯ä»¥é€šéå‚³é `hub_model_id` ä¾†è¦†è“‹å®ƒ; ä¾‹å¦‚, ç‚ºäº†å°‡æ¨¡å‹æ¨é€åˆ° `huggingface_course` çµ„ç¹”, æˆ‘å€‘ä½¿ç”¨äº† `hub_model_id="huggingface_course/bert-finetuned-squad"` (é€™æ˜¯æˆ‘å€‘åœ¨æœ¬ç¯€é–‹é ­éˆæ¥çš„æ¨¡å‹)ã€‚

{#if fw === 'pt'}

<Tip>

ğŸ’¡ å¦‚æœæ‚¨ä½¿ç”¨çš„è¼¸å‡ºç›®éŒ„å­˜åœ¨, å‰‡å®ƒéœ€è¦æ˜¯æ‚¨è¦æ¨é€åˆ°çš„å­˜å„²åº«çš„æœ¬åœ°å…‹éš† (å› æ­¤, å¦‚æœåœ¨å®šç¾© `Trainer` æ™‚å‡ºéŒ¯, è«‹è¨­ç½®æ–°åç¨±)ã€‚

</Tip>

æœ€å¾Œ, æˆ‘å€‘åªéœ€å°‡æ‰€æœ‰å…§å®¹å‚³éçµ¦ `Trainer` é¡ä¸¦å•Ÿå‹•è¨“ç·´:

```python
from transformers import Trainer

trainer = Trainer(
    model=model,
    args=args,
    train_dataset=train_dataset,
    eval_dataset=validation_dataset,
    tokenizer=tokenizer,
)
trainer.train()
```

{:else}

```python
from transformers.keras_callbacks import PushToHubCallback

callback = PushToHubCallback(output_dir="bert-finetuned-squad", tokenizer=tokenizer)

# We're going to do validation afterwards, so no validation mid-training
model.fit(tf_train_dataset, callbacks=[callback], epochs=num_train_epochs)
```

{/if}

è«‹æ³¨æ„, åœ¨é€²è¡Œè¨“ç·´æ™‚, æ¯æ¬¡ä¿å­˜æ¨¡å‹æ™‚ (é€™è£¡æ˜¯æ¯å€‹ epoch) å®ƒéƒ½æœƒåœ¨å¾Œè‡ºä¸Šå‚³åˆ° Hubã€‚é€™æ¨£, å¦‚æœ‰å¿…è¦, ä½ å°‡èƒ½å¤ åœ¨å¦ä¸€è‡ºæ©Ÿå™¨ä¸Šæ¢å¾©è¨“ç·´ã€‚æ•´å€‹åŸ¹è¨“éœ€è¦ä¸€æ®µæ™‚é–“ (åœ¨ Titan RTX ä¸Šéœ€è¦ä¸€å€‹å¤šå°æ™‚), å› æ­¤æ‚¨å¯ä»¥å–æ¯å’–å•¡æˆ–é‡è®€èª²ç¨‹ä¸­æ‚¨ç™¼ç¾åœ¨é€²è¡Œéç¨‹ä¸­æ›´å…·æŒ‘æˆ°æ€§çš„éƒ¨åˆ†å…§å®¹ã€‚å¦è«‹æ³¨æ„, ä¸€æ—¦ç¬¬ä¸€å€‹ epoch å®Œæˆ, ä½ å°‡çœ‹åˆ°ä¸€äº›æ¬Šé‡ä¸Šå‚³åˆ° Hub, ä½ å¯ä»¥é–‹å§‹åœ¨å…¶é é¢ä¸Šä½¿ç”¨ä½ çš„æ¨¡å‹ã€‚

{#if fw === 'pt'}

ä¸€æ—¦è¨“ç·´å®Œæˆ, æˆ‘å€‘çµ‚æ–¼å¯ä»¥è©•ä¼°æˆ‘å€‘çš„æ¨¡å‹(ä¸¦ç¥ˆç¦±æˆ‘å€‘æ²’æœ‰æŠŠæ‰€æœ‰çš„è¨ˆç®—æ™‚é–“éƒ½èŠ±åœ¨ä»»ä½•äº‹æƒ…ä¸Š)ã€‚`Trainer` çš„ `predict()` æ–¹æ³•å°‡è¿”å›ä¸€å€‹å…ƒçµ„, å…¶ä¸­ç¬¬ä¸€å€‹å…ƒç´ å°‡æ˜¯æ¨¡å‹çš„é æ¸¬ (é€™è£¡æ˜¯å¸¶æœ‰é–‹å§‹å’ŒçµæŸ logits çš„å°)ã€‚æˆ‘å€‘å°‡å…¶ç™¼é€çµ¦ `compute_metrics()` å‡½æ•¸:

```python
predictions, _ = trainer.predict(validation_dataset)
start_logits, end_logits = predictions
compute_metrics(start_logits, end_logits, validation_dataset, raw_datasets["validation"])
```

{:else}

ä¸€æ—¦è¨“ç·´å®Œæˆ, æˆ‘å€‘çµ‚æ–¼å¯ä»¥è©•ä¼°æˆ‘å€‘çš„æ¨¡å‹(ä¸¦ç¥ˆç¦±æˆ‘å€‘æ²’æœ‰æŠŠæ‰€æœ‰çš„è¨ˆç®—æ™‚é–“éƒ½èŠ±åœ¨ä»»ä½•äº‹æƒ…ä¸Š)ã€‚æˆ‘å€‘çš„ `model` çš„ `predict()` æ–¹æ³•å°‡è² è²¬ç²å–é æ¸¬, ä¸¦ä¸”ç”±æ–¼æˆ‘å€‘ä¹‹å‰å·²ç¶“å®Œæˆäº†å®šç¾© `compute_metrics()` å‡½æ•¸çš„æ‰€ä»¥è‰±è‹¦å·¥ä½œ, å› æ­¤æˆ‘å€‘å¯ä»¥åœ¨ä¸€è¡Œä¸­ç²å¾—çµæœ:

```python
predictions = model.predict(tf_eval_dataset)
compute_metrics(
    predictions["start_logits"],
    predictions["end_logits"],
    validation_dataset,
    raw_datasets["validation"],
)
```

{/if}

```python out
{'exact_match': 81.18259224219489, 'f1': 88.67381321905516}
```

å¾ˆå¥½! ä½œç‚ºæ¯”è¼ƒ, BERT æ–‡ç« ä¸­å ±å‘Šçš„è©²æ¨¡å‹çš„åŸºç·šåˆ†æ•¸æ˜¯ 80.8 å’Œ 88.5, æ‰€ä»¥æˆ‘å€‘æ‡‰è©²æ˜¯æ­£ç¢ºçš„ã€‚

{#if fw === 'pt'}

æœ€å¾Œ, æˆ‘å€‘ä½¿ç”¨ `push_to_hub()` æ–¹æ³•ç¢ºä¿æˆ‘å€‘ä¸Šå‚³æ¨¡å‹çš„æœ€æ–°ç‰ˆæœ¬:

```py
trainer.push_to_hub(commit_message="Training complete")
```

å¦‚æœä½ æƒ³æª¢æŸ¥å®ƒ, é€™å°‡è¿”å›å®ƒå‰›å‰›åŸ·è¡Œçš„æäº¤çš„ URL:

```python out
'https://huggingface.co/sgugger/bert-finetuned-squad/commit/9dcee1fbc25946a6ed4bb32efb1bd71d5fa90b68'
```

`Trainer` é‚„èµ·è‰äº†åŒ…å«æ‰€æœ‰è©•ä¼°çµæœçš„æ¨¡å‹å¡ä¸¦ä¸Šå‚³ã€‚

{/if}

åœ¨é€™å€‹éšæ®µ, ä½ å¯ä»¥ä½¿ç”¨æ¨¡å‹ä¸­å¿ƒä¸Šçš„æ¨ç†å°éƒ¨ä»¶ä¾†æ¸¬è©¦æ¨¡å‹ä¸¦èˆ‡æ‚¨çš„æœ‹å‹ã€å®¶äººå’Œæœ€å–œæ­¡çš„å¯µç‰©åˆ†äº«ã€‚ä½ å·²ç¶“æˆåŠŸåœ°å¾®èª¿äº†ä¸€å€‹å•ç­”ä»»å‹™çš„æ¨¡å‹ -- æ­å–œ!

<Tip>

âœï¸ **è¼ªåˆ°ä½ äº†!** å˜—è©¦å¦ä¸€ç¨®æ¨¡å‹æ¶æ§‹, çœ‹çœ‹å®ƒæ˜¯å¦åœ¨æ­¤ä»»å‹™ä¸Šè¡¨ç¾æ›´å¥½!

</Tip>

{#if fw === 'pt'}

å¦‚æœä½ æƒ³æ›´æ·±å…¥åœ°ç­è§£è¨“ç·´å¾ªç’°, æˆ‘å€‘ç¾åœ¨å°‡å‘ä½ å±•ç¤ºå¦‚ä½•ä½¿ç”¨ ğŸ¤— Accelerate ä¾†åšåŒæ¨£çš„äº‹æƒ…ã€‚

## è‡ªå®šç¾©è¨“ç·´å¾ªç’°

ç¾åœ¨è®“æˆ‘å€‘ä¾†çœ‹ä¸€ä¸‹å®Œæ•´çš„è¨“ç·´å¾ªç’°, é€™æ¨£æ‚¨å°±å¯ä»¥è¼•é¬†åœ°è‡ªå®šç¾©æ‰€éœ€çš„éƒ¨åˆ†ã€‚å®ƒçœ‹èµ·ä¾†å¾ˆåƒ [ç¬¬ä¸‰ç« ](/course/chapter3/4) ä¸­çš„è¨“ç·´å¾ªç’°, é™¤äº†è©•ä¼°å¾ªç’°ã€‚æˆ‘å€‘å°‡èƒ½å¤ å®šæœŸè©•ä¼°æ¨¡å‹, å› ç‚ºæˆ‘å€‘ä¸å†å— `Trainer` é¡çš„é™åˆ¶ã€‚

### ç‚ºè¨“ç·´åšæº–å‚™

é¦–å…ˆ, æˆ‘å€‘éœ€è¦å¾æˆ‘å€‘çš„æ•¸æ“šé›†ä¸­æ§‹å»º `DataLoader`ã€‚æˆ‘å€‘å°‡é€™äº›æ•¸æ“šé›†çš„æ ¼å¼è¨­ç½®ç‚º `"torch"`, ä¸¦åˆªé™¤æ¨¡å‹æœªä½¿ç”¨çš„é©—è­‰é›†ä¸­çš„åˆ—ã€‚ç„¶å¾Œ, æˆ‘å€‘å¯ä»¥ä½¿ç”¨ Transformers æä¾›çš„ `default_data_collator` ä½œç‚º `collate_fn`, ä¸¦æ‰“äº‚è¨“ç·´é›†, ä½†ä¸æ‰“äº‚é©—è­‰é›†58:

```py
from torch.utils.data import DataLoader
from transformers import default_data_collator

train_dataset.set_format("torch")
validation_set = validation_dataset.remove_columns(["example_id", "offset_mapping"])
validation_set.set_format("torch")

train_dataloader = DataLoader(
    train_dataset,
    shuffle=True,
    collate_fn=default_data_collator,
    batch_size=8,
)
eval_dataloader = DataLoader(
    validation_set, collate_fn=default_data_collator, batch_size=8
)
```

æ¥ä¸‹ä¾†æˆ‘å€‘é‡æ–°å¯¦ä¾‹åŒ–æˆ‘å€‘çš„æ¨¡å‹, ä»¥ç¢ºä¿æˆ‘å€‘ä¸æœƒç¹¼çºŒä¹‹å‰çš„å¾®èª¿, è€Œæ˜¯å†æ¬¡å¾ BERT é è¨“ç·´æ¨¡å‹é–‹å§‹:

```py
model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)
```

ç„¶å¾Œæˆ‘å€‘éœ€è¦ä¸€å€‹å„ªåŒ–å™¨ã€‚åƒå¾€å¸¸ä¸€æ¨£, æˆ‘å€‘ä½¿ç”¨ç¶“å…¸çš„ `AdamW`, å®ƒèˆ‡ Adam é¡ä¼¼, ä½†å°æ¬Šé‡è¡°æ¸›çš„æ‡‰ç”¨æ–¹å¼é€²è¡Œäº†ä¿®å¾©:

```py
from torch.optim import AdamW

optimizer = AdamW(model.parameters(), lr=2e-5)
```

ä¸€æ—¦æˆ‘å€‘æ“æœ‰æ‰€æœ‰é€™äº›å°è±¡, æˆ‘å€‘å¯ä»¥å°‡å®ƒå€‘ç™¼é€çµ¦ `accelerator.prepare()` æ–¹æ³•ã€‚è«‹è¨˜ä½, å¦‚æœæ‚¨æƒ³åœ¨ Colab ç­†è¨˜æœ¬ä¸­çš„ TPU ä¸Šé€²è¡Œè¨“ç·´, æ‚¨éœ€è¦å°‡æ‰€æœ‰é€™äº›ä»£ç¢¼ç§»å‹•åˆ°ä¸€å€‹è¨“ç·´å‡½æ•¸ä¸­, ä¸¦ä¸”ä¸æ‡‰è©²åŸ·è¡Œä»»ä½•å¯¦ä¾‹åŒ– `Accelerator` çš„å–®å…ƒã€‚æˆ‘å€‘å¯ä»¥é€šéå‚³é `fp16=True` çµ¦ `Accelerator` (æˆ–è€…, å¦‚æœä½ å°‡ä»£ç¢¼ä½œç‚ºè…³æœ¬åŸ·è¡Œ, åªéœ€ç¢ºä¿é©ç•¶åœ°å¡«å¯« ğŸ¤— Accelerate `config` )ã€‚

```py
from accelerate import Accelerator

accelerator = Accelerator(fp16=True)
model, optimizer, train_dataloader, eval_dataloader = accelerator.prepare(
    model, optimizer, train_dataloader, eval_dataloader
)
```

å¾å‰é¢å¹¾ç¯€ä¸­ä½ æ‡‰è©²çŸ¥é“, æˆ‘å€‘åªèƒ½ä½¿ç”¨ `train_dataloader` é•·åº¦ä¾†è¨ˆç®—ç¶“é `accelerator.prepare()` æ–¹æ³•å¾Œçš„è¨“ç·´æ­¥é©Ÿçš„æ•¸é‡ã€‚æˆ‘å€‘ä½¿ç”¨èˆ‡å‰å¹¾ç¯€ç›¸åŒçš„ç·šæ€§æ™‚é–“è¡¨:

```py
from transformers import get_scheduler

num_train_epochs = 3
num_update_steps_per_epoch = len(train_dataloader)
num_training_steps = num_train_epochs * num_update_steps_per_epoch

lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps,
)
```

è¦å°‡æˆ‘å€‘çš„æ¨¡å‹æ¨é€åˆ° Hub, æˆ‘å€‘éœ€è¦åœ¨å·¥ä½œæ–‡ä»¶å¤¾ä¸­å‰µå»ºä¸€å€‹ `Repository` å°è±¡ã€‚å¦‚æœä½ å°šæœªç™»éŒ„, è«‹å…ˆç™»éŒ„ Hugging Face Hubã€‚æˆ‘å€‘å°‡æ ¹æ“šæˆ‘å€‘æƒ³è¦ç‚ºæ¨¡å‹æä¾›çš„æ¨¡å‹ ID ç¢ºå®šå­˜å„²åº«åç¨± (éš¨æ„ç”¨ä½ è‡ªå·±çš„é¸æ“‡æ›¿æ› `repo_name`; å®ƒåªéœ€è¦åŒ…å«ä½ çš„ç”¨æˆ¶å, é€™å°±æ˜¯å‡½æ•¸ `get_full_repo_name()` æ‰€åšçš„):

```py
from huggingface_hub import Repository, get_full_repo_name

model_name = "bert-finetuned-squad-accelerate"
repo_name = get_full_repo_name(model_name)
repo_name
```

```python out
'sgugger/bert-finetuned-squad-accelerate'
```

ç„¶å¾Œæˆ‘å€‘å¯ä»¥å°‡è©²å­˜å„²åº«å…‹éš†åˆ°æœ¬åœ°æ–‡ä»¶å¤¾ä¸­ã€‚å¦‚æœå®ƒå·²ç¶“å­˜åœ¨, é€™å€‹æœ¬åœ°æ–‡ä»¶å¤¾æ‡‰è©²æ˜¯æˆ‘å€‘æ­£åœ¨ä½¿ç”¨çš„å­˜å„²åº«çš„å…‹éš†:

```py
output_dir = "bert-finetuned-squad-accelerate"
repo = Repository(output_dir, clone_from=repo_name)
```

æˆ‘å€‘ç¾åœ¨å¯ä»¥é€šéèª¿ç”¨ `repo.push_to_hub()` æ–¹æ³•ä¸Šå‚³æˆ‘å€‘ä¿å­˜åœ¨ `output_dir` ä¸­çš„ä»»ä½•å…§å®¹ã€‚é€™å°‡å¹«åŠ©æˆ‘å€‘åœ¨æ¯å€‹ epoch çµæŸæ™‚ä¸Šå‚³ä¸­é–“æ¨¡å‹ã€‚

## è¨“ç·´å¾ªç’°

æˆ‘å€‘ç¾åœ¨æº–å‚™ç·¨å¯«å®Œæ•´çš„è¨“ç·´å¾ªç’°ã€‚åœ¨å®šç¾©äº†ä¸€å€‹é€²åº¦æ¢ä¾†è·Ÿè¹¤è¨“ç·´é€²è¡Œå¾Œ, å¾ªç’°åˆ†ç‚ºä¸‰å€‹éƒ¨åˆ†:

- è¨“ç·´æœ¬èº«æ˜¯å° `train_dataloader` çš„ç¶“å…¸è¿­ä»£, å‰å‘å‚³éæ¨¡å‹, ç„¶å¾Œåå‘å‚³éå’Œå„ªåŒ–å™¨æ­¥é©Ÿã€‚
- åœ¨è¨ˆç®—ä¸­, æˆ‘å€‘åœ¨å°‡ `start_logits` å’Œ `end_logits` çš„æ‰€æœ‰å€¼è½‰æ›ç‚º NumPy æ•¸çµ„ä¹‹å‰, æ”¶é›†å®ƒå€‘çš„æ‰€æœ‰å€¼ã€‚è©•ä¼°å¾ªç’°å®Œæˆå¾Œ,æˆ‘å€‘å°‡é€£æ¥æ‰€æœ‰çµæœã€‚è«‹æ³¨æ„, æˆ‘å€‘éœ€è¦æˆªæ–·, å› ç‚º `Accelerator` å¯èƒ½åœ¨æœ€å¾Œæ·»åŠ äº†ä¸€äº›ç¤ºä¾‹, ä»¥ç¢ºä¿æˆ‘å€‘åœ¨æ¯å€‹éç¨‹ä¸­æ“æœ‰ç›¸åŒæ•¸é‡çš„ç¤ºä¾‹ã€‚
- ä¿å­˜å’Œä¸Šå‚³, é€™è£¡æˆ‘å€‘å…ˆä¿å­˜æ¨¡å‹å’Œåˆ†è©å™¨, ç„¶å¾Œèª¿ç”¨ `repo.push_to_hub()`ã€‚æ­£å¦‚æˆ‘å€‘ä¹‹å‰æ‰€åšçš„é‚£æ¨£, æˆ‘å€‘ä½¿ç”¨åƒæ•¸ `blocking=False` ä¾†å‘Šè¨´ ğŸ¤— Hub åº«æ¨å…¥ä¸€å€‹ç•°æ­¥é€²ç¨‹ã€‚é€™æ¨£, è¨“ç·´æ­£å¸¸ç¹¼çºŒ, ä¸¦ä¸”é€™å€‹ (é•·) æŒ‡ä»¤åœ¨å¾Œè‡ºåŸ·è¡Œã€‚

é€™æ˜¯è¨“ç·´å¾ªç’°çš„å®Œæ•´ä»£ç¢¼:

```py
from tqdm.auto import tqdm
import torch

progress_bar = tqdm(range(num_training_steps))

for epoch in range(num_train_epochs):
    # Training
    model.train()
    for step, batch in enumerate(train_dataloader):
        outputs = model(**batch)
        loss = outputs.loss
        accelerator.backward(loss)

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)

    # Evaluation
    model.eval()
    start_logits = []
    end_logits = []
    accelerator.print("Evaluation!")
    for batch in tqdm(eval_dataloader):
        with torch.no_grad():
            outputs = model(**batch)

        start_logits.append(accelerator.gather(outputs.start_logits).cpu().numpy())
        end_logits.append(accelerator.gather(outputs.end_logits).cpu().numpy())

    start_logits = np.concatenate(start_logits)
    end_logits = np.concatenate(end_logits)
    start_logits = start_logits[: len(validation_dataset)]
    end_logits = end_logits[: len(validation_dataset)]

    metrics = compute_metrics(
        start_logits, end_logits, validation_dataset, raw_datasets["validation"]
    )
    print(f"epoch {epoch}:", metrics)

    # Save and upload
    accelerator.wait_for_everyone()
    unwrapped_model = accelerator.unwrap_model(model)
    unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)
    if accelerator.is_main_process:
        tokenizer.save_pretrained(output_dir)
        repo.push_to_hub(
            commit_message=f"Training in progress epoch {epoch}", blocking=False
        )
```

å¦‚æœé€™æ˜¯æ‚¨ç¬¬ä¸€æ¬¡çœ‹åˆ°ä½¿ç”¨ ğŸ¤— Accelerate ä¿å­˜çš„æ¨¡å‹, è®“æˆ‘å€‘èŠ±é»æ™‚é–“æª¢æŸ¥ä¸€ä¸‹å®ƒé™„å¸¶çš„ä¸‰è¡Œä»£ç¢¼:

```py
accelerator.wait_for_everyone()
unwrapped_model = accelerator.unwrap_model(model)
unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)
```

ç¬¬ä¸€è¡Œæ˜¯ä¸è¨€è‡ªæ˜çš„: å®ƒå‘Šè¨´æ‰€æœ‰é€²ç¨‹è¦ç­‰åˆ°æ¯å€‹äººéƒ½è™•æ–¼é‚£å€‹éšæ®µæ‰èƒ½ç¹¼çºŒã€‚é€™æ˜¯ç‚ºäº†ç¢ºä¿æˆ‘å€‘åœ¨ä¿å­˜ä¹‹å‰åœ¨æ¯å€‹éç¨‹ä¸­éƒ½æœ‰ç›¸åŒçš„æ¨¡å‹ã€‚ç„¶å¾Œæˆ‘å€‘ç²å– `unwrapped_model`, é€™æ˜¯æˆ‘å€‘å®šç¾©çš„åŸºç¤æ¨¡å‹ã€‚ `accelerator.prepare()` æ–¹æ³•å°‡æ¨¡å‹æ›´æ”¹ç‚ºåœ¨åˆ†ä½ˆå¼è¨“ç·´ä¸­å·¥ä½œ, å› æ­¤å®ƒå°‡ä¸å†æœ‰ `save_pretrained()` æ–¹æ³•; `accelerator.unwrap_model()` æ–¹æ³•æœƒæ’¤éŠ·è©²æ­¥é©Ÿã€‚æœ€å¾Œ, æˆ‘å€‘èª¿ç”¨ `save_pretrained()`, ä½†å‘Šè¨´è©²æ–¹æ³•ä½¿ç”¨ `accelerator.save()` è€Œä¸æ˜¯ `torch.save()`ã€‚

å®Œæˆå¾Œ, ä½ æ‡‰è©²æ“æœ‰ä¸€å€‹æ¨¡å‹, è©²æ¨¡å‹ç”¢ç”Ÿçš„çµæœèˆ‡ä½¿ç”¨ `Trainer` è¨“ç·´çš„æ¨¡å‹éå¸¸ç›¸ä¼¼ã€‚ä½ å¯ä»¥åœ¨ [*huggingface-course/bert-finetuned-squad-accelerate*](https://huggingface.co/huggingface-course/bert-finetuned-squad-accelerate) ä¸ŠæŸ¥çœ‹æˆ‘å€‘ä½¿ç”¨æ­¤ä»£ç¢¼è¨“ç·´çš„æ¨¡å‹ã€‚å¦‚æœä½ æƒ³æ¸¬è©¦å°è¨“ç·´å¾ªç’°çš„ä»»ä½•èª¿æ•´, ä½ å¯ä»¥é€šéç·¨è¼¯ä¸Šé¢é¡¯ç¤ºçš„ä»£ç¢¼ç›´æ¥å¯¦ç¾å®ƒå€‘!

{/if}

## ä½¿ç”¨å¾®èª¿æ¨¡å‹

æˆ‘å€‘å·²ç¶“å‘æ‚¨å±•ç¤ºç­å¦‚ä½•å°‡æˆ‘å€‘åœ¨æ¨¡å‹ä¸­å¿ƒå¾®èª¿çš„æ¨¡å‹èˆ‡æ¨ç†å°éƒ¨ä»¶ä¸€èµ·ä½¿ç”¨ã€‚è¦åœ¨ `pipeline` ä¸­æœ¬åœ°ä½¿ç”¨å®ƒ, ä½ åªéœ€è¦æŒ‡å®šæ¨¡å‹æ¨™è­˜ç¬¦:

```py
from transformers import pipeline

# Replace this with your own checkpoint
model_checkpoint = "huggingface-course/bert-finetuned-squad"
question_answerer = pipeline("question-answering", model=model_checkpoint)

context = """
ğŸ¤— Transformers is backed by the three most popular deep learning libraries â€” Jax, PyTorch and TensorFlow â€” with a seamless integration
between them. It's straightforward to train your models with one before loading them for inference with the other.
"""
question = "Which deep learning libraries back ğŸ¤— Transformers?"
question_answerer(question=question, context=context)
```

```python out
{'score': 0.9979003071784973,
 'start': 78,
 'end': 105,
 'answer': 'Jax, PyTorch and TensorFlow'}
```

å¾ˆæ£’! æˆ‘å€‘çš„æ¨¡å‹èˆ‡è©²ç®¡é“çš„é»˜èªæ¨¡å‹ä¸€æ¨£æœ‰æ•ˆ!
