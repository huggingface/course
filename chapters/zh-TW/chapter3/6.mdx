<FrameworkSwitchCourse {fw} />

<!-- DISABLE-FRONTMATTER-SECTIONS -->

# End-of-chapter quiz

<CourseFloatingBanner
    chapter={3}
    classNames="absolute z-10 right-0 top-0"
/>

Test what you learned in this chapter!

### 1.「情緒」數據集包含標記有情緒的 Twitter 消息。在[ Hub ]( https://huggingface.co/datasets 集線器)中搜索它，然後讀取數據集卡。哪一個不是它的基本情感？
<Question
	choices={[
		{
			text: "歡樂",
			explain: "再試一次ーー這種情緒出現在那個數據集中！"
		},
		{
			text: "愛",
			explain: "再試一次ーー這種情緒出現在那個數據集中！"
		},
		{
			text: "困惑",
			explain: "正確! 困惑不是六種基本情緒之一。",
            correct: true
		},
        {
			text: "驚喜",
			explain: "驚喜! 但不對！"
		}
	]}
/>

### 2.在[ Hub ]( https://huggingface.co/datasets 集線器)中搜索‘ ar _ sarcasm’數據集，它支持哪個任務？
<Question
	choices={[
		{
			text: "情緒分類",
			explain: "沒錯! 你可以感謝這些標籤。",
            correct: true
		},
		{
			text: "機器翻譯",
			explain: "不是這樣的ーー再看看 < a href =’https://huggingface.co/datasets/ar _ sarcasm’> dataset card </a > ！"
		},
		{
			text: "命名實體識別",
			explain: "不是這樣的ーー再看看 < a href =’https://huggingface.co/datasets/ar _ sarcasm’> dataset card </a > ！"
		},
        {
			text: "回答問題",
			explain: "Alas, this question was not answered correctly. 再試一次！"
		}
	]}
/>

### 3.BERT 模型期望如何處理一對句子？
<Question
	choices={[
		{
			text: "表示句子的記號1[ SEP ]表示句子的記號2",
			explain: "在創建批處理時確實意味著填充，但不意味著填充到整個數據集中的最大長度。"
		},
		{
			text: "表示句子的記號表示句子的記號",
			explain: "一個 < code > [ CLS ] </code > 特殊令牌在開始時是必需的，但是這不是唯一的事情！"
		},
		{
			text: "表示句子1[ SEP ]的符號表示句子2[ SEP ]",
			explain: "沒錯！",
            correct: true
		},
        {
			text: "表示句子1[ SEP ]的符號表示句子2",
			explain: "開頭需要一個 < code > [ CLS ] </code > 特殊標記，還需要一個 < code > [ SEP ] </code > 特殊標記來分隔兩個句子，但這還不是全部！"
		}
	]}
/>

{#if fw === 'pt'}
### 4.‘ Dataset.map ()’方法的好處是什麼？
<Question
	choices={[
		{
			text: "函數的結果是緩存的，因此如果我們重新執行代碼，不會花費任何時間。",
			explain: "這確實是這種方法的優點之一! 儘管它不是唯一的一個..。",
            correct: true
		},
		{
			text: "它可以應用多重處理，比在數據集的每個元素上應用函數更快。",
			explain: "這是這個方法的一個優雅的特性，但它不是唯一的一個！",
            correct: true
		},
		{
			text: "它只包含用於訓練的超參數。",
			explain: "這是這種方法的一個優點，儘管還有其他的優點！",
            correct: true
		},
	]}
/>

### 5.什麼是動態填充？
<Question
	choices={[
		{
			text: "就是將每個批處理的輸入填充到整個數據集中的最大長度。",
			explain: "在示例中，我們指定了保存模型及其檢查點的位置。請再試一次！"
		},
		{
			text: "這是當你填補你的輸入時，批處理創建，到最大長度的句子裡面的批處理。",
			explain: "沒錯！“動態”部分來自這樣一個事實，即每個批的大小是在創建時確定的，因此所有批可能具有不同的形狀。",
            correct: true
		},
		{
			text: "就是當您填充輸入時，使每個句子具有與數據集中的前一個相同的標記數量。",
			explain: "這是不正確的，而且由於我們在訓練過程中對數據集進行了洗牌，因此查看數據集中的順序是沒有意義的。"
		},
	]}
/>

### 6.校對函數的用途是什麼？
<Question
	choices={[
		{
			text: "它確保數據集中的所有序列具有相同的長度。",
			explain: "校對函數用於處理單個批處理，而不是整個數據集。此外，我們討論的是通用的校對函數，而不是特定的 < code > > DataCollatorWithPadding </code > 。"
		},
		{
			text: "它把所有的樣品一批一批地放在一起。",
			explain: "正確！ You can pass the collate function as an argument of a <code>DataLoader</code>. We used the <code>DataCollatorWithPadding</code> function, which pads all items in a batch so they have the same length.",
            correct: true
		},
		{
			text: "它預處理整個數據集。",
			explain: "這將是一個預處理函數，而不是校對函數。"
		},
        {
			text: "它截斷數據集中的序列。",
			explain: "校對函數用於處理單個批處理，而不是整個數據集。如果您對截斷感興趣，可以使用 < code > tokenizer </code > 的 < truncate </code > 參數。"
		}
	]}
/>

### 7.當你用一個預先訓練過的語言模型(例如‘ bert-base-uncased’)實例化一個‘ AutoModelForXxx’類，這個類對應於一個不同於它所被訓練的任務時會發生什麼？
<Question
	choices={[
		{
			text: "什麼都沒有，但是你得到了一個警告。",
			explain: "你確實得到了警告，但這還不是全部！"
		},
		{
			text: "丟棄預訓練模型的頭部，並插入一個新的頭部適合的任務。",
			explain: "這就是我們對 < code > Trainer </code > 所做的，而不是 Accelerate 庫。再試一次！",
            correct: true
		},
		{
			text: "丟棄預先訓練好的模型頭部。",
			explain: "Something else needs to happen. 再試一次！"
		},
        {
			text: "沒有，因為模型仍然可以針對不同的任務進行微調。",
			explain: "這個經過訓練的模特的頭沒有經過訓練來解決這個問題，所以我們應該丟掉這個頭！"
		}
	]}
/>

### 8.訓練爭論的目的是什麼？
<Question
	choices={[
		{
			text: "它包含了所有用於訓練和評估的超參數。",
			explain: "正確！",
            correct: true
		},
		{
			text: "它指定模型的大小。",
			explain: "模型大小是由模型配置定義的，而不是類 < code > TrainingArguments </code > 。"
		},
		{
			text: "它只包含用於評估的超參數。",
			explain: "In the example, we specified where the model and its checkpoints will be saved. 再試一次！"
		},
        {
			text: "您可以輕鬆地計算與數據集相關的指標。",
			explain: "In the example, we used an <code>evaluation_strategy</code> as well, so this impacts evaluation. 再試一次！"
		}
	]}
/>

### 9.為什麼要使用 Accelerate 庫？
<Question
	choices={[
		{
			text: "它提供了對更快的模型的訪問。",
			explain: "不，Accelerate 庫不提供任何模型。"
		},
		{
			text: "它提供了一個高級 API，因此我不必實現自己的培訓循環。",
			explain: "This is what we did with <code>Trainer</code>, not the 🤗 Accelerate library. 再試一次！"
		},
		{
			text: "它使我們的訓練循環工作在分佈式策略上",
			explain: "正確! 隨著加速，你的訓練循環將為多個 gpu 和 TPUs 工作。",
            correct: true
		},
        {
			text: "它提供了更多的優化功能。",
			explain: "不，Accelerate 庫不提供任何優化功能。"
		}
	]}
/>

{:else}
### 4.當你用一個預先訓練過的語言模型(例如‘ bert-base-uncased’)實例化一個‘ tfautoodelforxxx’類時，會發生什麼？
<Question
	choices={[
		{
			text: "什麼都沒有，但是你得到了一個警告。",
			explain: "你確實得到了警告，但這還不是全部！"
		},
		{
			text: "丟棄預訓練模型的頭部，並插入一個新的頭部適合的任務。",
			explain: "需要一個特殊的標記來分隔這兩個句子，但這不是唯一的事情！",
            correct: true
		},
		{
			text: "丟棄預先訓練好的模型頭部。",
			explain: "Something else needs to happen. 再試一次！"
		},
        {
			text: "沒有，因為模型仍然可以針對不同的任務進行微調。",
			explain: "這個經過訓練的模特的頭沒有經過訓練來解決這個問題，所以我們應該丟掉這個頭！"
		}
	]}
/>

### 5.來自“變壓器”的 TensorFlow 模型已經是 Keras 模型，這有什麼好處？
<Question
	choices={[
		{
			text: "該模型的工作在一個 TPU 的盒子。",
			explain: "差不多！還需要進行一些小的額外修改。例如，您需要運行 < code > TPUStrategy </code > scope 中的所有內容，包括模型的初始化。"
		},
		{
			text: "您可以利用現有的方法，如 < code > compile () </code > 、 < code > fit () < c/ode > 和 < code > predict () </code > 。",
			explain: "正確! 一旦你有了這些數據，在這些數據上進行培訓只需要很少的工作。",
            correct: true
		},
		{
			text: "你可以學習 Keras 和變形金剛。",
			explain: "沒錯，但我們要找的是別的東西:)",
			correct: true
		},
        {
			text: "困惑",
			explain: "Keras 幫助我們訓練和評估模型，而不是計算與數據集相關的度量。"
		}
	]}
/>

### 6.如何定義自己的定製度量？
<Question
	choices={[
		{
			text: "通過子類化 < code > tfkeras.metrics. Metric </code > 。",
			explain: "太好了！",
			correct: true
		},
		{
			text: "使用 Keras 函數 API。",
			explain: "再試一次！"
		},
		{
			text: "通過使用帶簽名的可調用 < code > metric _ fn (y _ true，y _ pred) </code > 。",
			explain: "正確！",
			correct: true
		},
        {
			text: "通過谷歌搜索。",
			explain: "這不是我們要找的答案，但它應該能幫助你找到答案。",
			correct: true
		}
	]}
/>

{/if}