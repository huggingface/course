<FrameworkSwitchCourse {fw} />

<!-- DISABLE-FRONTMATTER-SECTIONS -->

# 章末小测验 [[章末小测验]]

<CourseFloatingBanner
    chapter={3}
    classNames="absolute z-10 right-0 top-0"
/>

现在来测试一下本章所学内容吧！

### 1. “emotion”数据集包含带有情绪标记的 Twitter 消息。请在 [ Hub ]( https://huggingface.co/datasets) 中进行搜索并读取数据集的数据卡片。判断哪一个基本情感不在这个数据集中？
<Question
	choices={[
		{
			text: "Joy（欢乐）",
			explain: "再试一次ーー这种情绪在这个数据集中！"
		},
		{
			text: "Love（爱）",
			explain: "再试一次ーー这种情绪在这个数据集中！"
		},
		{
			text: "Confusion（困惑）",
			explain: "正确! Confusion 不是六种基本情绪之一。",
            correct: true
		},
        {
			text: "Surprise（惊喜）",
			explain: "Surprise! 再试一次！"
		}
	]}
/>

### 2. 在 [ Hub ]( https://huggingface.co/datasets) 中搜索`ar_sarcasm`数据集，该数据集支持哪个任务？
<Question
	choices={[
		{
			text: "情绪分类",
			explain: "没错! 多亏这些标签。",
            correct: true
		},
		{
			text: "机器翻译",
			explain: "不对，请再看看[数据卡片](https://huggingface.co/datasets/ar_sarcasm)！"
		},
		{
			text: "命名实体识别",
			explain: "不对，请再看看[数据卡片](https://huggingface.co/datasets/ar_sarcasm) ！"
		},
        {
			text: "回答问题",
			explain: "哎呀, 问题回答不正确. 再试一次！"
		}
	]}
/>

### 3. 当输入一对句子时 BERT 模型会需要进行怎么样的预处理？
<Question
	choices={[
		{
			text: "句子1的token序列 [ SEP ] 句子2的token序列",
			explain: "需要使用一个特殊的 `[SEP]` token 来分隔两个句子，但是只有这一个还不够。"
		},
		{
			text: "[CLS] 句子1的token序列 句子2的token序列",
			explain: "需要一个特殊的 `[CLS]` token 来指示句子的开头，但是只有这一个还不够。"
		},
		{
			text: "[CLS] 句子1的token序列 [SEP] 句子2的token序列 [SEP]",
			explain: "正确！",
            correct: true
		},
        {
			text: "[CLS] 句子1的token序列 [SEP] 句子2的token序列",
			explain: "需要一个特殊的 `[CLS]` token 来指示句子的开头，还需要一个特殊的 `[SEP]` token 来分隔两个句子，但这还不是需要全部的预处理。"
		}
	]}
/>

{#if fw === 'pt'}
### 4. `Dataset.map ()`方法的好处是什么？
<Question
	choices={[
		{
			text: "该函数执行后的结果被缓存，重新执行代码时不会花费多余时间。",
			explain: "这确实是这种方法的优点之一! 不过还有别的优点...",
            correct: true
		},
		{
			text: "它可以进行并行化处理，比在数据集的每个元素上依次使用函数进行处理更快。",
			explain: "这是该方法一个比较优雅的特点！ 不过还有别的优点...",
            correct: true
		},
		{
			text: "它不会将整个数据集加载到内存中，而是在处理一个元素后立即保存结果。",
			explain: "这是这种方法的一个优点！ 不过还有别的优点...",
            correct: true
		},
	]}
/>

### 5. 什么是动态填充？
<Question
	choices={[
		{
			text: "就是将每个批处理的输入填充到整个数据集中的最大长度。",
			explain: "它确实意味着创建 batch 时进行填充，但不是整个数据集中的最大长度。"
		},
		{
			text: "这是当你在创建 batch 时将输入填充到该 batch 内句子的最大长度。",
			explain: "没错！“动态”部分即每个 batch 的大小是在创建时确定的，因此不同的 batch 可能具有不同的形状。",
            correct: true
		},
		{
			text: "当你将每个句子填充到与数据集中的前一个句子相同数量的 token 时。",
			explain: "错误，而且由于我们在训练过程中对数据集进行了随机的打乱，因此数据集中的顺序是没有意义的。"
		},
	]}
/>

### 6. collate 函数的用途是什么？
<Question
	choices={[
		{
			text: "它确保数据集中的所有序列具有相同的长度。",
			explain: "collate 函数用于处理单个 batch 处理，而不是整个数据集。此外，我们讨论的是所有 collate 函数通常的用途，而不是特定的  <code>DataCollatorWithPadding</code> "
		},
		{
			text: "它把所有的样本地放在一个 batch 里。",
			explain: "正确！你可将 collate 函数作为 <code>DataLoader</code>函数的一个参数。 我们使用了 <code>DataCollatorWithPadding</code> 函数, 该函数对批次中的所有项目进行填充，使它们具有相同的长度。",
            correct: true
		},
		{
			text: "它预处理整个数据集。",
			explain: "预处理函数（preprocessing）用于预处理整个数据集，而不是 collate 函数。"
		},
        {
			text: "它截断数据集中的序列。",
			explain: "collate 函数用于处理单个 batch 的处理，而不是整个数据集。如果你对截断感兴趣，可以使用 <code> tokenizer </code> 的<code> truncate </code> 参数。"
		}
	]}
/>

### 7. 当你用一个预先训练过的语言模型（例如 `bert-base-uncased`）实例化一个`AutoModelForXxx`类，这个类与它所被训练的任务不匹配时会发生什么？
<Question
	choices={[
		{
			text: "什么都没有，但会出现一个警告。",
			explain: "确实出现警告，但这还不是全部！"
		},
		{
			text: "丢弃预训练模型的头部，取而代之的是一个适合该任务的新头部。",
			explain: "正确的。 例如，当我们将 AutoModelForSequenceClassification 与 bert-base-uncased 结合使用时，我们在实例化模型时将收到警告。 预训练的头不用于序列分类任务，因此它被丢弃，并使用随机初始化权重的用于序列分类任务的头。",
            correct: true
		},
		{
			text: "丢弃预先训练好的模型头部。",
			explain: "还需要做其他事情，再试一次！"
		},
        {
			text: "没有，因为模型仍然可以针对不同的任务进行微调。",
			explain: "这个经过训练的模特的头没有经过训练来解决这个问题，所以我们应该丢弃该头部！"
		}
	]}
/>

### 8．`TrainingArguments`的用途是什么？
<Question
	choices={[
		{
			text: "它包含了所有用于训练和评估的超参数。",
			explain: "正确！",
            correct: true
		},
		{
			text: "它指定模型的大小。",
			explain: "模型大小是由模型配置定义的，而不是由 `TrainingArguments` 类 。"
		},
		{
			text: "它只包含用于评估的超参数。",
			explain: "在示例中，我们还指定了模型的超参数及其检查点的保存位置。 再试一次！"
		}
	]}
/>

### 9．为什么要使用🤗 Accelerate 库？
<Question
	choices={[
		{
			text: "它可以对更快地访问的模型。",
			explain: "不，🤗 Accelerate 库不提供任何模型。"
		},
		{
			text: "它提供了一个高级 API，因此我不必实现自己的训练循环。",
			explain: "这是我们使用 <code>Trainer</code> 所做的事情，而不是 🤗 Accelerate 库。 再试一次"
		},
		{
			text: "它使我们的训练循环运行在分布式架构上",
			explain: "正确! 使用🤗 Accelerate 库，你的训练循环可以在多个 GPU 和 TPUs 上运行。",
            correct: true
		},
        {
			text: "它提供了更多的优化功能。",
			explain: "不，🤗 Accelerate 库不提供任何优化功能。"
		}
	]}
/>

{:else}
### 4．当模型与预训练的任务不匹配时，例如使用预训练的语言模型（例如“`bert-base-uncased`”）实例化“`TFAutoModelForXxx`”类时会发生什么？
<Question
	choices={[
		{
			text: "什么都不会发生，但是你会得到一个警告。",
			explain: "你确实得到了警告，但这还不是全部！"
		},
		{
			text: "丢弃预训练模型的头部，并插入一个新的头部以适应新的任务。",
			explain: "正确的。 例如，当我们将 `TFAutoModelForSequenceClassification `与 `bert-base-uncased` 结合使用时，我们在实例化模型时收到警告。 预训练的头不用于序列分类任务，因此它被丢弃，使用新的头并且随机初始化权重。",
            correct: true
		},
		{
			text: "丢弃预先训练好的模型头部。",
			explain: "除此之外还有一些事情会发生， 再试一次！"
		},
        {
			text: "没有，因为模型仍然可以针对不同的任务进行微调。",
			explain: "这个经过训练的模特的头没有经过训练来解决这个问题，所以我们应该丢掉这个头！"
		}
	]}
/>

### 5．来自 `transformers` 的 TensorFlow 模型已经是 Keras 模型，这有什么好处？
<Question
	choices={[
		{
			text: "这些模型可在开箱即用的 TPU 上运行。",
			explain: "差不多！但是还需要进行一些小的额外修改。例如，你需要在 <code>TPUStrategy</code> 范围内运行所有内容，包括模型的初始化。"
		},
		{
			text: "你可以利用现有方法，例如 <code>compile()</code>、<code>fit()</code> 和 <code>predict()</code>。",
			explain: "正确! 一旦你有了数据，只需要很少的工作就可以在这些数据上进行训练。",
            correct: true
		},
		{
			text: "你可以学习 Keras 以及 Transformer。",
			explain: "没错，但我们要找的是别的东西:)",
			correct: true
		},
        {
			text: "你可以轻松计算与数据集相关的指标。",
			explain: "Keras 帮助我们训练和评估模型，而不是计算与数据集相关的指标。"
		}
	]}
/>

### 6．如何定义自己的自定义指标？
<Question
	choices={[
		{
			text: "使用子类化 tf.keras.metrics.Metric。",
			explain: "太好了！",
			correct: true
		},
		{
			text: "使用 Keras 函数 API。",
			explain: "再试一次！"
		},
		{
			text: "使用使用带有签名的 <code>metric_fn(y_true, y_pred)</code> 函数。",
			explain: "正确！",
			correct: true
		},
        {
			text: "使用谷歌搜索。",
			explain: "这不是我们要找的答案，不过它应该能帮助你找到答案。",
			correct: true
		}
	]}
/>

{/if}