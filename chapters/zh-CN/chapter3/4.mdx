# ä¸€ä¸ªå®Œæ•´çš„è®­ç»ƒ [[ä¸€ä¸ªå®Œæ•´çš„è®­ç»ƒ]]

<CourseFloatingBanner chapter={3}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/zh-CN/chapter3/section4.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/zh-CN/chapter3/section4.ipynb"},
]} />

<Youtube id="Dh9CL8fyG80"/>

ç°åœ¨ï¼Œæˆ‘ä»¬å°†äº†è§£å¦‚ä½•åœ¨ä¸ä½¿ç”¨ `Trainer` ç±»çš„æƒ…å†µä¸‹å®ç°ä¸ä¸Šä¸€èŠ‚ç›¸åŒçš„ç»“æœã€‚åŒæ ·ï¼Œæˆ‘ä»¬å‡è®¾ä½ å·²ç»å®Œæˆäº†ç¬¬ 2 èŠ‚ä¸­çš„æ•°æ®å¤„ç†ã€‚ä¸‹é¢å¯¹ç¬¬ 2 èŠ‚å†…å®¹çš„ä¸€ä¸ªç®€çŸ­æ€»ç»“ï¼Œæ¶µç›–äº†ä½ éœ€è¦åœ¨æœ¬èŠ‚ä¹‹å‰è¿è¡Œçš„æ‰€æœ‰å†…å®¹ï¼š

```py
from datasets import load_dataset
from transformers import AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset("glue", "mrpc")
checkpoint = "bert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


def tokenize_function(example):
    return tokenizer(example["sentence1"], example["sentence2"], truncation=True)


tokenized_datasets = raw_datasets.map(tokenize_function, batched=True)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)
```

## è®­ç»ƒå‰çš„å‡†å¤‡ [[è®­ç»ƒå‰çš„å‡†å¤‡]]

åœ¨æ­£å¼å¼€å§‹ç¼–å†™æˆ‘ä»¬çš„è®­ç»ƒå¾ªç¯ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€äº›å¯¹è±¡ã€‚é¦–å…ˆæ˜¯æˆ‘ä»¬å°†ç”¨äºè¿­ä»£ batch çš„æ•°æ®åŠ è½½å™¨ã€‚ä½†åœ¨å®šä¹‰è¿™äº›æ•°æ®åŠ è½½å™¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æˆ‘ä»¬çš„ `tokenized_datasets` è¿›è¡Œä¸€äº›åå¤„ç†ï¼Œä»¥è‡ªå·±å®ç°ä¸€äº› Trainer è‡ªåŠ¨ä¸ºæˆ‘ä»¬å¤„ç†çš„å†…å®¹ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦ï¼š

- åˆ é™¤ä¸æ¨¡å‹ä¸éœ€è¦çš„åˆ—ï¼ˆå¦‚ `sentence1` å’Œ `sentence2` åˆ—ï¼‰ã€‚
- å°†åˆ—å `label` é‡å‘½åä¸º `labels` ï¼ˆå› ä¸ºæ¨¡å‹é»˜è®¤çš„è¾“å…¥æ˜¯ `labels` ï¼‰ã€‚
- è®¾ç½®æ•°æ®é›†çš„æ ¼å¼ï¼Œä½¿å…¶è¿”å› PyTorch å¼ é‡è€Œä¸æ˜¯åˆ—è¡¨ã€‚

é’ˆå¯¹ä¸Šé¢çš„æ¯ä¸ªæ­¥éª¤ï¼Œæˆ‘ä»¬çš„ `tokenized_datasets` éƒ½æœ‰ä¸€ä¸ªæ–¹æ³•ï¼š

```py
tokenized_datasets = tokenized_datasets.remove_columns(["sentence1", "sentence2", "idx"])
tokenized_datasets = tokenized_datasets.rename_column("label", "labels")
tokenized_datasets.set_format("torch")
tokenized_datasets["train"].column_names
```

ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥æ£€æŸ¥ç»“æœä¸­æ˜¯å¦åªæœ‰æ¨¡å‹èƒ½å¤Ÿæ¥å—çš„åˆ—ï¼š

```python
["attention_mask", "input_ids", "labels", "token_type_ids"]
```

è‡³æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾å®šä¹‰æ•°æ®åŠ è½½å™¨ï¼š

```py
from torch.utils.data import DataLoader

train_dataloader = DataLoader(
    tokenized_datasets["train"], shuffle=True, batch_size=8, collate_fn=data_collator
)
eval_dataloader = DataLoader(
    tokenized_datasets["validation"], batch_size=8, collate_fn=data_collator
)
```

ä¸ºäº†å¿«é€Ÿæ£€éªŒæ•°æ®å¤„ç†ä¸­æ²¡æœ‰é”™è¯¯ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·æ£€éªŒå…¶ä¸­çš„ä¸€ä¸ª batchï¼š

```py
for batch in train_dataloader:
    break
{k: v.shape for k, v in batch.items()}
```

```python out
{'attention_mask': torch.Size([8, 65]),
 'input_ids': torch.Size([8, 65]),
 'labels': torch.Size([8]),
 'token_type_ids': torch.Size([8, 65])}
```

è¯·æ³¨æ„ï¼Œè¿™é‡Œçš„å½¢çŠ¶å¯èƒ½ä¸ä½ ç•¥æœ‰ä¸åŒï¼Œå› ä¸ºæˆ‘ä»¬ä¸ºè®­ç»ƒæ•°æ®åŠ è½½å™¨è®¾ç½®äº† `shuffle=True` ï¼Œå¹¶ä¸”æ¨¡å‹ä¼šå°†å¥å­å¡«å……åˆ° `batch` ä¸­çš„æœ€å¤§é•¿åº¦ã€‚

ç°åœ¨æˆ‘ä»¬å·²ç»å®Œå…¨å®Œæˆäº†æ•°æ®é¢„å¤„ç†ï¼ˆå¯¹äºä»»ä½• ML ä»ä¸šè€…æ¥è¯´éƒ½æ˜¯ä¸€ä¸ªä»¤äººæ»¡æ„ä½†éš¾ä»¥å®ç°çš„ç›®æ ‡ï¼‰ï¼Œè®©æˆ‘ä»¬å°†æ³¨æ„åŠ›è½¬å‘æ¨¡å‹ã€‚æˆ‘ä»¬ä¼šåƒåœ¨ä¸Šä¸€èŠ‚ä¸­æ‰€åšçš„é‚£æ ·å®ä¾‹åŒ–å®ƒï¼š

```py
from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)
```

ä¸ºäº†ç¡®ä¿è®­ç»ƒè¿‡ç¨‹ä¸­ä¸€åˆ‡é¡ºåˆ©ï¼Œæˆ‘ä»¬å°† `batch` ä¼ é€’ç»™è¿™ä¸ªæ¨¡å‹ï¼š

```py
outputs = model(**batch)
print(outputs.loss, outputs.logits.shape)
```

```python out
tensor(0.5441, grad_fn=<NllLossBackward>) torch.Size([8, 2])
```

å½“æˆ‘ä»¬è¾“å…¥ `labels` æ—¶ï¼ŒğŸ¤— Transformers æ¨¡å‹éƒ½å°†è¿”å›è¿™ä¸ª `batch` çš„ `loss` ï¼Œæˆ‘ä»¬è¿˜å¾—åˆ°äº† `logits` ï¼ˆ `batch` ä¸­çš„æ¯ä¸ªè¾“å…¥æœ‰ä¸¤ä¸ªè¾“å‡ºï¼Œæ‰€ä»¥å¼ é‡å¤§å°ä¸º 8 x 2ï¼‰ã€‚

æˆ‘ä»¬å‡ ä¹å‡†å¤‡å¥½ç¼–å†™æˆ‘ä»¬çš„è®­ç»ƒå¾ªç¯äº†ï¼æˆ‘ä»¬åªæ˜¯ç¼ºå°‘ä¸¤ä»¶äº‹ï¼šä¼˜åŒ–å™¨å’Œå­¦ä¹ ç‡è°ƒåº¦å™¨ã€‚ç”±äºæˆ‘ä»¬è¯•å›¾æ‰‹åŠ¨å®ç° `Trainer` çš„åŠŸèƒ½ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç›¸åŒçš„ä¼˜åŒ–å™¨å’Œå­¦ä¹ ç‡è°ƒåº¦å™¨ã€‚ `Trainer` ä½¿ç”¨çš„ä¼˜åŒ–å™¨æ˜¯ `AdamW` ï¼Œå®ƒä¸ `Adam` ç›¸åŒï¼Œä½†åŠ å…¥äº†æƒé‡è¡°å‡æ­£åˆ™åŒ–çš„ä¸€ç‚¹å˜åŒ–ï¼ˆå‚è§ Ilya Loshchilov å’Œ Frank Hutter çš„ [â€œDecoupled Weight Decay Regularizationâ€](https://arxiv.org/abs/1711.05101) ï¼‰ï¼š

```py
from torch.optim import AdamW

optimizer = AdamW(model.parameters(), lr=5e-5)
```

æœ€åï¼Œé»˜è®¤ä½¿ç”¨çš„å­¦ä¹ ç‡è°ƒåº¦å™¨åªæ˜¯ä»æœ€å¤§å€¼ ï¼ˆ5e-5ï¼‰ åˆ° 0 çš„çº¿æ€§è¡°å‡ã€‚ä¸ºäº†å®šä¹‰å®ƒï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“æˆ‘ä»¬è®­ç»ƒçš„æ¬¡æ•°ï¼Œå³æ‰€æœ‰æ•°æ®è®­ç»ƒçš„æ¬¡æ•°ï¼ˆepochsï¼‰ä¹˜ä»¥çš„ batch çš„æ•°é‡ï¼ˆå³æˆ‘ä»¬è®­ç»ƒæ•°æ®åŠ è½½å™¨çš„é•¿åº¦ï¼‰ã€‚ `Trainer` é»˜è®¤æƒ…å†µä¸‹ä½¿ç”¨ä¸‰ä¸ª `epochs` ï¼Œå› æ­¤æˆ‘ä»¬å®šä¹‰è®­ç»ƒè¿‡ç¨‹å¦‚ä¸‹ï¼š

```py
from transformers import get_scheduler

num_epochs = 3
num_training_steps = num_epochs * len(train_dataloader)
lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps,
)
print(num_training_steps)
```

```python out
1377
```

## è®­ç»ƒå¾ªç¯ [[è®­ç»ƒå¾ªç¯]]

æœ€åä¸€ä»¶äº‹ï¼šå¦‚æœæˆ‘ä»¬å¯ä»¥è®¿é—® GPUï¼Œæˆ‘ä»¬å°†å¸Œæœ›ä½¿ç”¨ GPUï¼ˆåœ¨ CPU ä¸Šï¼Œè®­ç»ƒå¯èƒ½éœ€è¦å‡ ä¸ªå°æ—¶è€Œä¸æ˜¯å‡ åˆ†é’Ÿï¼‰ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ª `device` ï¼Œå®ƒåœ¨ GPU å¯ç”¨çš„æƒ…å†µä¸‹æŒ‡å‘ GPUï¼Œæœ€åæˆ‘ä»¬å°†æŠŠæˆ‘ä»¬çš„æ¨¡å‹å’Œ `batch` æ”¾åœ¨ `device` ä¸Šï¼š

```py
import torch

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
model.to(device)
device
```

```python out
device(type='cuda')
```

æˆ‘ä»¬ç°åœ¨å‡†å¤‡å¥½è®­ç»ƒäº†ï¼ä¸ºäº†çŸ¥é“è®­ç»ƒä½•æ—¶ç»“æŸï¼Œæˆ‘ä»¬ä½¿ç”¨ `tqdm` åº“ï¼Œåœ¨è®­ç»ƒæ­¥éª¤æ•°ä¸Šæ·»åŠ äº†ä¸€ä¸ªè¿›åº¦æ¡ï¼š

```py
from tqdm.auto import tqdm

progress_bar = tqdm(range(num_training_steps))

model.train()
for epoch in range(num_epochs):
    for batch in train_dataloader:
        batch = {k: v.to(device) for k, v in batch.items()}
        outputs = model(**batch)
        loss = outputs.loss
        loss.backward()

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)
```

ä½ å¯ä»¥çœ‹åˆ°è®­ç»ƒå¾ªç¯çš„æ ¸å¿ƒä¸ä»‹ç»ä¸­çš„éå¸¸ç›¸ä¼¼ã€‚æˆ‘ä»¬æ²¡æœ‰è¦æ±‚åœ¨è®­ç»ƒçš„è¿‡ç¨‹ä¸­è¿›è¡Œæ£€éªŒï¼Œæ‰€ä»¥è¿™ä¸ªè®­ç»ƒå¾ªç¯ä¸ä¼šå‘Šè¯‰æˆ‘ä»¬ä»»ä½•å…³äºæ¨¡å‹ç›®å‰çš„çŠ¶æ€ã€‚æˆ‘ä»¬éœ€è¦ä¸ºæ­¤æ·»åŠ ä¸€ä¸ªè¯„ä¼°å¾ªç¯ã€‚


## è¯„ä¼°å¾ªç¯ [[è¯„ä¼°å¾ªç¯]]

æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æ‰€åšçš„é‚£æ ·ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ ğŸ¤— Evaluate åº“æä¾›çš„æŒ‡æ ‡ã€‚æˆ‘ä»¬å·²ç»äº†è§£äº† `metric.compute()` æ–¹æ³•ï¼Œå½“æˆ‘ä»¬ä½¿ç”¨ `add_batch()` æ–¹æ³•è¿›è¡Œé¢„æµ‹å¾ªç¯æ—¶ï¼Œå®é™…ä¸Šè¯¥æŒ‡æ ‡å¯ä»¥ä¸ºæˆ‘ä»¬ç´¯ç§¯æ‰€æœ‰ `batch` çš„ç»“æœã€‚ä¸€æ—¦æˆ‘ä»¬ç´¯ç§¯äº†æ‰€æœ‰ `batch` ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ `metric.compute()` è¯„ä¼°å¾—åˆ°çš„ç»“æœã€‚ä»¥ä¸‹æ˜¯å¦‚ä½•åœ¨è¯„ä¼°å¾ªç¯ä¸­å®ç°æ‰€æœ‰è¿™äº›çš„æ–¹æ³•ï¼š

```py
import evaluate

metric = evaluate.load("glue", "mrpc")
model.eval()
for batch in eval_dataloader:
    batch = {k: v.to(device) for k, v in batch.items()}
    with torch.no_grad():
        outputs = model(**batch)

    logits = outputs.logits
    predictions = torch.argmax(logits, dim=-1)
    metric.add_batch(predictions=predictions, references=batch["labels"])

metric.compute()
```

```python out
{'accuracy': 0.8431372549019608, 'f1': 0.8907849829351535}
```

åŒæ ·ï¼Œç”±äºæ¨¡å‹å¤´éƒ¨åˆå§‹åŒ–å’Œæ•°æ®æ‰“ä¹±çš„éšæœºæ€§ï¼Œä½ çš„ç»“æœä¼šç•¥æœ‰ä¸åŒï¼Œä½†åº”è¯¥ç›¸å·®ä¸å¤šã€‚

<Tip>

âœï¸ **è¯•è¯•çœ‹ï¼** ä¿®æ”¹ä¹‹å‰çš„è®­ç»ƒå¾ªç¯ä»¥åœ¨ SST-2 æ•°æ®é›†ä¸Šå¾®è°ƒä½ çš„æ¨¡å‹ã€‚

</Tip>

## ä½¿ç”¨ğŸ¤— Accelerate åŠ é€Ÿä½ çš„è®­ç»ƒå¾ªç¯ [[ä½¿ç”¨ğŸ¤— AccelerateåŠ é€Ÿä½ çš„è®­ç»ƒå¾ªç¯]]

<Youtube id="s7dy8QRgjJ0" />

æˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„è®­ç»ƒå¾ªç¯åœ¨å•ä¸ª CPU æˆ– GPU ä¸Šè¿è¡Œè‰¯å¥½ã€‚é€šè¿‡ä½¿ç”¨ [ğŸ¤— Accelerate](https://github.com/huggingface/accelerate) åº“ï¼Œåªéœ€è¿›è¡Œä¸€äº›è°ƒæ•´ï¼Œæˆ‘ä»¬å°±å¯ä»¥åœ¨å¤šä¸ª GPU æˆ– TPU ä¸Šå¯ç”¨åˆ†å¸ƒå¼è®­ç»ƒã€‚ä»åˆ›å»ºè®­ç»ƒå’ŒéªŒè¯æ•°æ®åŠ è½½å™¨å¼€å§‹ï¼Œæˆ‘ä»¬çš„æ‰‹åŠ¨è®­ç»ƒå¾ªç¯å¦‚ä¸‹æ‰€ç¤ºï¼š

```py
from torch.optim import AdamW
from transformers import AutoModelForSequenceClassification, get_scheduler

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)
optimizer = AdamW(model.parameters(), lr=3e-5)

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
model.to(device)

num_epochs = 3
num_training_steps = num_epochs * len(train_dataloader)
lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps,
)

progress_bar = tqdm(range(num_training_steps))

model.train()
for epoch in range(num_epochs):
    for batch in train_dataloader:
        batch = {k: v.to(device) for k, v in batch.items()}
        outputs = model(**batch)
        loss = outputs.loss
        loss.backward()

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)
```

ä»¥ä¸‹æ˜¯æ›´æ”¹çš„éƒ¨åˆ†ï¼š

```diff
+ from accelerate import Accelerator
  from transformers import AutoModelForSequenceClassification, get_scheduler

+ accelerator = Accelerator()

  model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)
  optimizer = AdamW(model.parameters(), lr=3e-5)

- device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
- model.to(device)

+ train_dataloader, eval_dataloader, model, optimizer = accelerator.prepare(
+     train_dataloader, eval_dataloader, model, optimizer
+ )

  num_epochs = 3
  num_training_steps = num_epochs * len(train_dataloader)
  lr_scheduler = get_scheduler(
      "linear",
      optimizer=optimizer,
      num_warmup_steps=0,
      num_training_steps=num_training_steps
  )

  progress_bar = tqdm(range(num_training_steps))

  model.train()
  for epoch in range(num_epochs):
      for batch in train_dataloader:
-         batch = {k: v.to(device) for k, v in batch.items()}
          outputs = model(**batch)
          loss = outputs.loss
-         loss.backward()
+         accelerator.backward(loss)

          optimizer.step()
          lr_scheduler.step()
          optimizer.zero_grad()
          progress_bar.update(1)
```

è¦æ·»åŠ çš„ç¬¬ä¸€è¡Œæ˜¯å¯¼å…¥ `Accelerator` ã€‚ç¬¬äºŒè¡Œå®ä¾‹åŒ–ä¸€ä¸ª `Accelerator` å¯¹è±¡ å®ƒå°†æŸ¥çœ‹ç¯å¢ƒå¹¶åˆå§‹åŒ–é€‚å½“çš„åˆ†å¸ƒå¼è®¾ç½®ã€‚ğŸ¤— Accelerate ä¸ºä½ å¤„ç†æ•°æ®åœ¨è®¾å¤‡é—´çš„æ•°æ®ä¼ é€’ï¼Œå› æ­¤ä½ å¯ä»¥åˆ é™¤å°†æ¨¡å‹æ”¾åœ¨è®¾å¤‡ä¸Šçš„é‚£è¡Œä»£ç ï¼ˆæˆ–è€…ï¼Œå¦‚æœä½ æ„¿æ„ï¼Œå¯ä½¿ç”¨ `accelerator.device` ä»£æ›¿ `device` ï¼‰ã€‚

ç„¶åå¤§éƒ¨åˆ†å·¥ä½œä¼šåœ¨å°†æ•°æ®åŠ è½½å™¨ã€æ¨¡å‹å’Œä¼˜åŒ–å™¨å‘é€åˆ°çš„ `accelerator.prepare()` ä¸­å®Œæˆã€‚è¿™å°†ä¼šæŠŠè¿™äº›å¯¹è±¡åŒ…è£…åœ¨é€‚å½“çš„å®¹å™¨ä¸­ï¼Œä»¥ç¡®ä¿ä½ çš„åˆ†å¸ƒå¼è®­ç»ƒæŒ‰é¢„æœŸå·¥ä½œã€‚è¦è¿›è¡Œçš„å…¶ä½™æ›´æ”¹æ˜¯åˆ é™¤å°† `batch` æ”¾åœ¨ `device` çš„é‚£è¡Œä»£ç ï¼ˆåŒæ ·ï¼Œå¦‚æœä½ æƒ³ä¿ç•™å®ƒï¼Œä½ å¯ä»¥å°†å…¶æ›´æ”¹ä¸ºä½¿ç”¨ `accelerator.device` ï¼‰ å¹¶å°† `loss.backward()` æ›¿æ¢ä¸º `accelerator.backward(loss)` ã€‚

<Tip>

âš ï¸ ä¸ºäº†ä½¿äº‘ç«¯ TPU æä¾›çš„åŠ é€Ÿä¸­å‘æŒ¥æœ€å¤§çš„æ•ˆç›Šï¼Œæˆ‘ä»¬å»ºè®®ä½¿ç”¨ tokenizer çš„ `padding=max_length` å’Œ `max_length` å‚æ•°å°†ä½ çš„æ ·æœ¬å¡«å……åˆ°å›ºå®šé•¿åº¦ã€‚

</Tip>

å¦‚æœä½ æƒ³å¤åˆ¶å¹¶ç²˜è´´æ¥ç›´æ¥è¿è¡Œï¼Œä»¥ä¸‹æ˜¯ ğŸ¤— Accelerate çš„å®Œæ•´è®­ç»ƒå¾ªç¯ï¼š

```py
from accelerate import Accelerator
from torch.optim import AdamW
from transformers import AutoModelForSequenceClassification, get_scheduler

accelerator = Accelerator()

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)
optimizer = AdamW(model.parameters(), lr=3e-5)

train_dl, eval_dl, model, optimizer = accelerator.prepare(
    train_dataloader, eval_dataloader, model, optimizer
)

num_epochs = 3
num_training_steps = num_epochs * len(train_dl)
lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps,
)

progress_bar = tqdm(range(num_training_steps))

model.train()
for epoch in range(num_epochs):
    for batch in train_dl:
        outputs = model(**batch)
        loss = outputs.loss
        accelerator.backward(loss)

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)
```

æŠŠè¿™ä¸ªæ”¾åœ¨ `train.py` æ–‡ä»¶ä¸­ï¼Œå¯ä»¥è®©å®ƒåœ¨ä»»ä½•ç±»å‹çš„åˆ†å¸ƒå¼è®¾ç½®ä¸Šè¿è¡Œã€‚è¦åœ¨åˆ†å¸ƒå¼è®¾ç½®ä¸­è¯•ç”¨å®ƒï¼Œè¯·è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š

```bash
accelerate config
```

è¿™å°†è¯¢é—®ä½ å‡ ä¸ªé…ç½®çš„é—®é¢˜å¹¶å°†ä½ çš„å›ç­”ä¿å­˜åˆ°æ­¤å‘½ä»¤ä½¿ç”¨çš„é…ç½®æ–‡ä»¶ä¸­ï¼š

```
accelerate launch train.py
```

è¿™å°†å¯åŠ¨åˆ†å¸ƒå¼è®­ç»ƒ

è¿™å°†å¯åŠ¨åˆ†å¸ƒå¼è®­ç»ƒã€‚å¦‚æœä½ æƒ³åœ¨ Notebook ä¸­å°è¯•æ­¤æ“ä½œï¼ˆä¾‹å¦‚ï¼Œåœ¨ Colab ä¸Šä½¿ç”¨ TPU è¿›è¡Œæµ‹è¯•ï¼‰ï¼Œåªéœ€å°†ä»£ç ç²˜è´´åˆ°ä¸€ä¸ª `training_function()` å‡½æ•°ä¸­ï¼Œå¹¶åœ¨æœ€åä¸€ä¸ªå•å…ƒæ ¼ä¸­è¿è¡Œï¼š

```python
from accelerate import notebook_launcher

notebook_launcher(training_function)
```

ä½ å¯ä»¥åœ¨ [ğŸ¤— Accelerate repo](https://github.com/huggingface/accelerate/tree/main/examples) æ‰¾åˆ°æ›´å¤šçš„ç¤ºä¾‹ã€‚
