<FrameworkSwitchCourse {fw} />

# æŠ½å–å¼é—®ç­”é—®ç­” [[æŠ½å–å¼é—®ç­”]]

{#if fw === 'pt'}

<DocNotebookDropdown
  classNames="absolute z-10 right-0 top-0"
  options={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter7/section7_pt.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter7/section7_pt.ipynb"},
]} />

{:else}

<DocNotebookDropdown
  classNames="absolute z-10 right-0 top-0"
  options={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter7/section7_tf.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter7/section7_tf.ipynb"},
]} />

{/if}

ç°åœ¨æˆ‘ä»¬æ¥çœ‹çœ‹é—®ç­”è¿™ä¸ªä»»åŠ¡ï¼è¿™ä¸ªä»»åŠ¡æœ‰å¾ˆå¤šç§ç±»å‹ï¼Œä½†æˆ‘ä»¬åœ¨æœ¬èŠ‚å°†è¦å…³æ³¨çš„æ˜¯ç§°ä¸º `æŠ½å–å¼ï¼ˆextractiveï¼‰` é—®é¢˜å›ç­”çš„å½¢å¼ã€‚ä¼šæœ‰ä¸€äº›é—®é¢˜å’Œæ–‡æ¡£ï¼Œå…¶ä¸­ç­”æ¡ˆå°±åœ¨æ–‡æ¡£æ®µè½ä¹‹å†…ã€‚

<Youtube id="ajPx5LwJD-I"/>

æˆ‘ä»¬å°†ä½¿ç”¨ [SQuAD æ•°æ®é›†](https://rajpurkar.github.io/SQuAD-explorer/) å¾®è°ƒä¸€ä¸ª BERT æ¨¡å‹ï¼Œå…¶ä¸­åŒ…æ‹¬ç¾¤ä¼—å·¥ä½œè€…å¯¹ä¸€ç»„ç»´åŸºç™¾ç§‘æ–‡ç« æå‡ºçš„é—®é¢˜ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªå°çš„æµ‹è¯•æ ·ä¾‹ï¼š

<iframe src="https://course-demos-bert-finetuned-squad.hf.space" frameBorder="0" height="450" title="Gradio app" class="block dark:hidden container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

æœ¬èŠ‚ä½¿ç”¨çš„ä»£ç å·²ç»ä¸Šä¼ åˆ°äº† Hubã€‚ä½ å¯ä»¥åœ¨ [è¿™é‡Œ](https://huggingface.co/huggingface-course/bert-finetuned-squad?context=%F0%9F%A4%97+Transformers+is+backed+by+the+three+most+popular+deep+learning+libraries+%E2%80%94+Jax%2C+PyTorch+and+TensorFlow+%E2%80%94+with+a+seamless+integration+between+them.+It%27s+straightforward+to+train+your+models+with+one+before+loading+them+for+inference+with+the+other.&question=Which+deep+learning+libraries+back+%F0%9F%A4%97+Transformers%3F) æ‰¾åˆ°å®ƒå¹¶å°è¯•ç”¨å®ƒè¿›è¡Œé¢„æµ‹ã€‚

<Tip>

ğŸ’¡ åƒ BERT è¿™æ ·çš„çº¯ç¼–ç å™¨æ¨¡å‹å¾€å¾€å¾ˆæ“…é•¿æå–è¯¸å¦‚ â€œè°å‘æ˜äº† Transformer æ¶æ„ï¼Ÿâ€ä¹‹ç±»çš„äº‹å®æ€§é—®é¢˜çš„ç­”æ¡ˆã€‚ä½†åœ¨ç»™å‡ºè¯¸å¦‚ â€œä¸ºä»€ä¹ˆå¤©ç©ºæ˜¯è“è‰²çš„ï¼Ÿâ€ ä¹‹ç±»çš„å¼€æ”¾å¼é—®é¢˜æ—¶è¡¨ç°ä¸ä½³ã€‚åœ¨è¿™äº›æ›´å…·æŒ‘æˆ˜æ€§çš„æƒ…å†µä¸‹ï¼Œé€šå¸¸ä½¿ç”¨ç¼–ç å™¨-è§£ç å™¨æ¨¡å‹å¦‚ T5 å’Œ BART æ¥ä»¥ç±»ä¼¼äº [æ–‡æœ¬æ‘˜è¦](https://chat.openai.com/course/chapter7/5) çš„æ–¹å¼æ•´åˆä¿¡æ¯ã€‚å¦‚æœä½ å¯¹è¿™ç§ `ç”Ÿæˆå¼ï¼ˆgenerativeï¼‰` é—®ç­”æ„Ÿå…´è¶£ï¼Œæˆ‘ä»¬æ¨èä½ æŸ¥çœ‹æˆ‘ä»¬åšçš„åŸºäº [ELI5 æ•°æ®é›†](https://huggingface.co/datasets/eli5) çš„ [æ¼”ç¤ºdemo](https://yjernite.github.io/lfqa.html) ã€‚

</Tip>

## å‡†å¤‡æ•°æ® [[å‡†å¤‡æ•°æ®]]

ä½œä¸ºæŠ½å–å¼é—®é¢˜å›ç­”çš„å­¦æœ¯åŸºå‡†æœ€å¸¸ç”¨çš„æ•°æ®é›†æ˜¯ [SQuAD](https://rajpurkar.github.io/SQuAD-explorer/) ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨è¿™é‡Œå°†ä½¿ç”¨å®ƒã€‚è¿˜æœ‰ä¸€ä¸ªæ›´éš¾çš„ [SQuAD v2](https://huggingface.co/datasets/squad_v2) åŸºå‡†ï¼Œå…¶ä¸­åŒ…å«ä¸€äº›æ²¡æœ‰ç­”æ¡ˆçš„é—®é¢˜ã€‚ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨è‡ªå·±çš„æ•°æ®é›†ï¼Œåªè¦ä½ è‡ªå·±çš„æ•°æ®é›†åŒ…å«äº† Context åˆ—ã€é—®é¢˜åˆ—å’Œç­”æ¡ˆåˆ—ï¼Œåº”è¯¥ä¹Ÿèƒ½å¤Ÿé€‚ç”¨ä¸‹é¢çš„æ­¥éª¤ã€‚

### SQuAD æ•°æ®é›† [[SQuAD æ•°æ®é›†]]

åƒå¾€å¸¸ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `load_dataset()` åœ¨ä¸€è¡Œä¸­ä¸‹è½½å’Œç¼“å­˜æ•°æ®é›†ï¼š

```py
from datasets import load_dataset

raw_datasets = load_dataset("squad")
```

æˆ‘ä»¬å¯ä»¥æŸ¥çœ‹è¿™ä¸ª `raw_datasets` å¯¹è±¡æ¥äº†è§£å…³äº SQuAD æ•°æ®é›†çš„æ›´å¤šä¿¡æ¯ï¼š

```py
raw_datasets
```

```python out
DatasetDict({
    train: Dataset({
        features: ['id', 'title', 'context', 'question', 'answers'],
        num_rows: 87599
    })
    validation: Dataset({
        features: ['id', 'title', 'context', 'question', 'answers'],
        num_rows: 10570
    })
})
```

çœ‹èµ·æ¥æˆ‘ä»¬çš„æ•°æ®é›†æ‹¥æœ‰æ‰€éœ€çš„ `context` ã€ `question` å’Œ `answers` å­—æ®µï¼Œæ‰€ä»¥è®©æˆ‘ä»¬æ‰“å°è®­ç»ƒé›†çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼š

```py
print("Context: ", raw_datasets["train"][0]["context"])
print("Question: ", raw_datasets["train"][0]["question"])
print("Answer: ", raw_datasets["train"][0]["answers"])
```

```python out
Context: 'Architecturally, the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend "Venite Ad Me Omnes". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive (and in a direct line that connects through 3 statues and the Gold Dome), is a simple, modern stone statue of Mary.'
Question: 'To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France?'
Answer: {'text': ['Saint Bernadette Soubirous'], 'answer_start': [515]}
```
`context` å’Œ `question` å­—æ®µçš„ä½¿ç”¨éå¸¸ç›´è§‚ã€‚ `answers` å­—æ®µç›¸å¯¹å¤æ‚ä¸€äº›ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ªå­—å…¸ï¼ŒåŒ…å«ä¸¤ä¸ªåˆ—è¡¨çš„å­—æ®µã€‚è¿™æ˜¯åœ¨è¯„ä¼°æ—¶ `squad` æŒ‡æ ‡éœ€è¦çš„æ ¼å¼ï¼›å¦‚æœä½ ä½¿ç”¨çš„æ˜¯ä½ è‡ªå·±çš„æ•°æ®ï¼Œä¸éœ€è¦å°†ç­”æ¡ˆå¤„ç†æˆå®Œå…¨ç›¸åŒçš„æ ¼å¼ã€‚ `text` å­—æ®µæ˜¯éå¸¸æ˜æ˜¾çš„ç­”æ¡ˆæ–‡æœ¬ï¼Œè€Œ `answer_start` å­—æ®µåŒ…å«äº† Context ä¸­æ¯ä¸ªç­”æ¡ˆå¼€å§‹çš„ç´¢å¼•ã€‚

åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œåªæœ‰ä¸€ä¸ªå¯èƒ½çš„ç­”æ¡ˆã€‚æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ `Dataset.filter()` æ–¹æ³•æ¥è¿›è¡Œæ£€æŸ¥ï¼š

```py
raw_datasets["train"].filter(lambda x: len(x["answers"]["text"]) != 1)
```

```python out
Dataset({
    features: ['id', 'title', 'context', 'question', 'answers'],
    num_rows: 0
})
```

ç„¶è€Œï¼Œåœ¨è¯„ä¼°è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸ªæ ·æœ¬å¯èƒ½æœ‰å¤šä¸ªç­”æ¡ˆï¼Œè¿™äº›ç­”æ¡ˆå¯èƒ½ç›¸åŒæˆ–ä¸åŒï¼š

```py
print(raw_datasets["validation"][0]["answers"])
print(raw_datasets["validation"][2]["answers"])
```

```python out
{'text': ['Denver Broncos', 'Denver Broncos', 'Denver Broncos'], 'answer_start': [177, 177, 177]}
{'text': ['Santa Clara, California', "Levi's Stadium", "Levi's Stadium in the San Francisco Bay Area at Santa Clara, California."], 'answer_start': [403, 355, 355]}
```

æˆ‘ä»¬ä¸ä¼šæ·±å…¥æ¢ç©¶è¯„ä¼°çš„ä»£ç ï¼Œå› ä¸ºæ‰€æœ‰çš„ä¸œè¥¿éƒ½å°†ç”±ğŸ¤— Datasets metric å¸®æˆ‘ä»¬å®Œæˆï¼Œä½†ç®€å•æ¥è¯´ï¼Œä¸€äº›é—®é¢˜å¯èƒ½æœ‰å¤šä¸ªå¯èƒ½çš„ç­”æ¡ˆï¼Œè€Œè¯¥è¯„ä¼°ä»£ç å°†æŠŠé¢„æµ‹çš„ç­”æ¡ˆä¸æ‰€æœ‰å¯æ¥å—çš„ç­”æ¡ˆè¿›è¡Œæ¯”è¾ƒï¼Œå¹¶é€‰æ‹©æœ€ä½³åˆ†æ•°ã€‚ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬çœ‹ä¸€ä¸‹ç´¢å¼•ä¸º 2 çš„æ ·æœ¬ï¼š

```py
print(raw_datasets["validation"][2]["context"])
print(raw_datasets["validation"][2]["question"])
```

```python out
'Super Bowl 50 was an American football game to determine the champion of the National Football League (NFL) for the 2015 season. The American Football Conference (AFC) champion Denver Broncos defeated the National Football Conference (NFC) champion Carolina Panthers 24â€“10 to earn their third Super Bowl title. The game was played on February 7, 2016, at Levi\'s Stadium in the San Francisco Bay Area at Santa Clara, California. As this was the 50th Super Bowl, the league emphasized the "golden anniversary" with various gold-themed initiatives, as well as temporarily suspending the tradition of naming each Super Bowl game with Roman numerals (under which the game would have been known as "Super Bowl L"), so that the logo could prominently feature the Arabic numerals 50.'
'Where did Super Bowl 50 take place?'
```

æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œç­”æ¡ˆçš„ç¡®å¯èƒ½æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„ä¸‰ä¸ªå¯èƒ½é€‰æ‹© `['Denver Broncos', 'Denver Broncos', 'Denver Broncos']` çš„ä¹‹ä¸€ã€‚

### å¤„ç†è®­ç»ƒæ•°æ® [[å¤„ç†è®­ç»ƒæ•°æ®]]

<Youtube id="qgaM0weJHpA"/>

æˆ‘ä»¬ä»é¢„å¤„ç†è®­ç»ƒæ•°æ®å¼€å§‹ã€‚æœ€å›°éš¾çš„éƒ¨åˆ†å°†æ˜¯ç”Ÿæˆé—®é¢˜ç­”æ¡ˆçš„ä½ç½®ï¼Œå³æ‰¾åˆ° Context ä¸­å¯¹åº”ç­”æ¡ˆ token çš„èµ·å§‹å’Œç»“æŸä½ç½®ã€‚

ä½†æˆ‘ä»¬ä¸è¦æ€¥äºæ±‚æˆã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ tokenizer å°†è¾“å…¥ä¸­çš„æ–‡æœ¬è½¬æ¢ä¸ºæ¨¡å‹å¯ä»¥ç†è§£çš„ IDï¼š

```py
from transformers import AutoTokenizer

model_checkpoint = "bert-base-cased"
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)
```

å¦‚å‰æ‰€è¿°ï¼Œæˆ‘ä»¬å°†å¯¹ BERT æ¨¡å‹è¿›è¡Œå¾®è°ƒï¼Œä½†ä½ å¯ä»¥ä½¿ç”¨ä»»ä½•å…¶ä»–æ¨¡å‹ç±»å‹ï¼Œåªè¦å®ƒå®ç°äº†å¿«é€Ÿ tokenizer å³å¯ã€‚ä½ å¯ä»¥åœ¨ [æ”¯æŒå¿«é€Ÿ tokenizer çš„æ¡†æ¶](https://huggingface.co/transformers/#supported-frameworks) è¡¨ä¸­çœ‹åˆ°æ‰€æœ‰å¸¦æœ‰å¿«é€Ÿç‰ˆæœ¬çš„æ¶æ„ï¼Œè¦æ£€æŸ¥ä½ æ­£åœ¨ä½¿ç”¨çš„ `tokenizer` å¯¹è±¡æ˜¯å¦çœŸçš„æ˜¯ç”±ğŸ¤— Tokenizers æ”¯æŒçš„ï¼Œä½ å¯ä»¥æŸ¥çœ‹å®ƒçš„ `is_fast` å±æ€§ï¼š

```py
tokenizer.is_fast
```

```python out
True
```

æˆ‘ä»¬å¯ä»¥å°† question å’Œ context ä¸€èµ·ä¼ é€’ç»™æˆ‘ä»¬çš„ tokenizer å®ƒä¼šæ­£ç¡®æ’å…¥ç‰¹æ®Š tokens å½¢æˆå¦‚ä¸‹å¥å­ï¼š

```
[CLS] question [SEP] context [SEP]
```

è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹å¤„ç†åçš„æ ·æœ¬ï¼š

```py
context = raw_datasets["train"][0]["context"]
question = raw_datasets["train"][0]["question"]

inputs = tokenizer(question, context)
tokenizer.decode(inputs["input_ids"])
```

```python out
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Architecturally, '
'the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin '
'Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms '
'upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred '
'Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a '
'replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette '
'Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 statues '
'and the Gold Dome ), is a simple, modern stone statue of Mary. [SEP]'
```

éœ€è¦é¢„æµ‹çš„æ˜¯ç­”æ¡ˆèµ·å§‹å’Œç»“æŸ token çš„ç´¢å¼•ï¼Œæ¨¡å‹çš„ä»»åŠ¡æ˜¯ä¸ºè¾“å…¥ä¸­çš„æ¯ä¸ªæ ‡è®°é¢„æµ‹ä¸€ä¸ªèµ·å§‹å’Œç»“æŸçš„ logit å€¼ï¼Œç†è®ºä¸Šçš„é¢„æµ‹çš„ç»“æœå¦‚ä¸‹æ‰€ç¤ºï¼š

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/qa_labels.svg" alt="One-hot encoded labels for question answering."/>
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/qa_labels-dark.svg" alt="One-hot encoded labels for question answering."/>
</div>

åœ¨åšä¸ªä¾‹å­ä¸­ï¼ŒContext æ²¡æœ‰å¾ˆé•¿ï¼Œä½†æ˜¯æ•°æ®é›†ä¸­çš„ä¸€äº›ç¤ºä¾‹çš„ Context ä¼šå¾ˆé•¿ï¼Œä¼šè¶…è¿‡æˆ‘ä»¬è®¾ç½®çš„æœ€å¤§é•¿åº¦ï¼ˆæœ¬ä¾‹ä¸­ä¸º 384ï¼‰ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨ [ç¬¬å…­ç« ](/course/chapter6/4) ä¸­æ‰€çœ‹åˆ°çš„ï¼Œå½“æˆ‘ä»¬æ¢ç´¢ `question-answering` ç®¡é“çš„å†…éƒ¨ç»“æ„æ—¶ï¼Œæˆ‘ä»¬ä¼šé€šè¿‡å°†ä¸€ä¸ªæ ·æœ¬çš„è¾ƒé•¿çš„ Context åˆ’åˆ†æˆå¤šä¸ªç‰‡æ®µï¼Œå¹¶åœ¨è¿™äº›ç‰‡æ®µä¹‹é—´ä½¿ç”¨æ»‘åŠ¨çª—å£ï¼Œæ¥å¤„ç†è¾ƒé•¿çš„ Contextã€‚

è¦äº†è§£åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­å¯¹å½“å‰çš„è®­ç»ƒæ ·æœ¬è¿›è¡Œäº†å“ªäº›å¤„ç†ï¼Œæˆ‘ä»¬å¯ä»¥å°†é•¿åº¦é™åˆ¶ä¸º 100ï¼Œå¹¶ä½¿ç”¨é•¿åº¦ä¸º 50 çš„ token çª—å£ã€‚æˆ‘ä»¬å°†è®¾ç½®ä»¥ä¸‹çš„å‚æ•°ï¼š

- `max_length` æ¥è®¾ç½®æœ€å¤§é•¿åº¦ ï¼ˆè¿™é‡Œä¸º 100ï¼‰
- `truncation="only_second"` åœ¨é—®é¢˜å’Œ Context è¿‡é•¿æ—¶æˆªæ–­ Contextï¼ˆContext ä½äºç¬¬äºŒä¸ªä½ç½®ï¼Œç¬¬ä¸€ä¸ªæ˜¯ Questionï¼‰
- `stride` è®¾ç½®ä¸¤ä¸ªè¿ç»­å—ä¹‹é—´çš„é‡å  tokens æ•° ï¼ˆè¿™é‡Œä¸º 50ï¼‰
- `return_overflowing_tokens=True` å‘Šè¯‰ tokenizer æˆ‘ä»¬æƒ³è¦ä¿ç•™è¶…è¿‡é•¿åº¦çš„ tokens 

```py
inputs = tokenizer(
    question,
    context,
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
)

for ids in inputs["input_ids"]:
    print(tokenizer.decode(ids))
```

```python out
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Architecturally, the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basi [SEP]'
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin [SEP]'
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 [SEP]'
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP]. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 statues and the Gold Dome ), is a simple, modern stone statue of Mary. [SEP]'
```

å¦‚æˆ‘ä»¬æ‰€è§ï¼Œç¤ºä¾‹æ–‡æœ¬è¢«æ‹†åˆ†æˆå››ä¸ªè¾“å…¥ï¼Œæ¯ä¸ªè¾“å…¥éƒ½åŒ…å«é—®é¢˜å’Œ Context çš„ä¸€éƒ¨åˆ†ã€‚è¯·æ³¨æ„ï¼Œé—®é¢˜çš„ç­”æ¡ˆ ï¼ˆâ€œBernadette Soubirousâ€ï¼‰ ä»…å‡ºç°åœ¨ç¬¬ä¸‰ä¸ªå’Œæœ€åä¸€ä¸ªç‰‡æ®µä¸­ï¼Œå› æ­¤é€šè¿‡ä»¥è¿™ç§æ–¹å¼å¤„ç†è¾ƒé•¿çš„ Context æ—¶ï¼Œæˆ‘ä»¬å¯èƒ½åˆ›å»ºä¸€äº› Context ä¸­ä¸åŒ…å«ç­”æ¡ˆçš„è®­ç»ƒæ ·æœ¬ã€‚æˆ‘ä»¬æŠŠè¿™äº›æ ·æœ¬çš„æ ‡ç­¾è®¾ç½®ä¸º `start_position = end_position = 0` ï¼ˆè¿™æ ·çš„è¯ï¼Œå®é™…ä¸Šæˆ‘ä»¬çš„ç­”æ¡ˆæŒ‡å‘äº† `[CLS]` tokensï¼‰ã€‚å¦‚æœç­”æ¡ˆè¢«æˆªæ–­ï¼Œé‚£ä¹ˆåªåœ¨è¿™ä¸€éƒ¨åˆ†é¢„æµ‹ç­”æ¡ˆçš„èµ·å§‹ï¼ˆæˆ–ç»“æŸï¼‰çš„token çš„ç´¢å¼•ã€‚å¯¹äºç­”æ¡ˆå®Œå…¨åœ¨ Context ä¸­çš„ç¤ºä¾‹ï¼Œæ ‡ç­¾å°†æ˜¯ç­”æ¡ˆèµ·å§‹çš„ token çš„ç´¢å¼•å’Œç­”æ¡ˆç»“æŸçš„ token çš„ç´¢å¼•ã€‚

æ•°æ®é›†ä¸ºæˆ‘ä»¬æä¾›äº† Context ä¸­ç­”æ¡ˆçš„èµ·å§‹çš„ä½ç½®ç´¢å¼•ï¼ŒåŠ ä¸Šç­”æ¡ˆçš„é•¿åº¦ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ° Context ä¸­çš„ç»“æŸç´¢å¼•ã€‚è¦å°†å®ƒä»¬æ˜ å°„åˆ° tokens ç´¢å¼•ï¼Œæˆ‘ä»¬å°†éœ€è¦ä½¿ç”¨æˆ‘ä»¬åœ¨ [ç¬¬å…­ç« ](/course/chapter6/4) ä¸­å­¦åˆ°çš„åç§»æ˜ å°„ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨ `return_offsets_mapping=True`ï¼Œè®©æˆ‘ä»¬çš„ tokenizer è¿”å›åç§»åçš„æ˜ å°„ï¼š

```py
inputs = tokenizer(
    question,
    context,
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)
inputs.keys()
```

```python out
dict_keys(['input_ids', 'token_type_ids', 'attention_mask', 'offset_mapping', 'overflow_to_sample_mapping'])
```

å¦‚æˆ‘ä»¬æ‰€è§ï¼Œæˆ‘ä»¬å¾—åˆ°äº† inputs IDã€tokens ç±»å‹ ID å’Œæ³¨æ„åŠ›æ©ç ï¼Œä»¥åŠæˆ‘ä»¬æ‰€éœ€çš„åç§»æ˜ å°„å’Œä¸€ä¸ªé¢å¤–çš„ `overflow_to_sample_mapping` ã€‚å½“æˆ‘ä»¬åŒæ—¶å¯¹å¤šä¸ªæ–‡æœ¬å¹¶è¡Œ tokenize æ—¶ï¼Œä¸ºäº†ä»æ”¯æŒ Rust ä¸­å—ç›Šï¼Œè¿™ä¸ªé”®çš„å€¼å¯¹æˆ‘ä»¬å¾ˆæœ‰ç”¨ã€‚ç”±äºä¸€ä¸ªé•¿çš„æ ·æœ¬å¯ä»¥åˆ‡åˆ†ä¸ºå¤šä¸ªçŸ­çš„æ ·æœ¬ï¼Œå®ƒä¿å­˜äº†è¿™äº›çŸ­çš„æ ·æœ¬æ˜¯æ¥è‡ªäºå“ªä¸ªé•¿çš„æ ·æœ¬ã€‚å› ä¸ºè¿™é‡Œæˆ‘ä»¬åªå¯¹ä¸€ä¸ªæ ·æœ¬è¿›è¡Œäº† tokenizeï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªç”± `0` ç»„æˆçš„åˆ—è¡¨ï¼š

```py
inputs["overflow_to_sample_mapping"]
```

```python out
[0, 0, 0, 0]
```

ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å¯¹æ›´å¤šçš„ç¤ºä¾‹è¿›è¡Œ tokenize ï¼Œå®ƒä¼šå˜å¾—æ›´åŠ æœ‰ç”¨ï¼š

```py
inputs = tokenizer(
    raw_datasets["train"][2:6]["question"],
    raw_datasets["train"][2:6]["context"],
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)

print(f"The 4 examples gave {len(inputs['input_ids'])} features.")
print(f"Here is where each comes from: {inputs['overflow_to_sample_mapping']}.")
```

```python out
'The 4 examples gave 19 features.'
'Here is where each comes from: [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3].'
```

åœ¨æˆ‘ä»¬çš„è¿™ä¸ªä¾‹å­ä¸­ï¼Œå‰ä¸‰æ¡æ•°æ® ï¼ˆåœ¨è®­ç»ƒé›†ä¸­çš„ç´¢å¼• 2ã€3 å’Œ 4 å¤„ï¼‰ æ¯æ¡æ•°æ®è¢«æ‹†åˆ†ä¸º4ä¸ªæ ·æœ¬ï¼Œæœ€åä¸€æ¡æ•°æ®ï¼ˆåœ¨è®­ç»ƒé›†ä¸­çš„ç´¢å¼• 5 å¤„ï¼‰ æ‹†åˆ†ä¸ºäº†5ä¸ªæ ·æœ¬ã€‚

è¿™äº›ä¿¡æ¯å°†æœ‰åŠ©äºå°†æˆ‘ä»¬æ‹†åˆ†åçš„æ–‡æœ¬å—æ˜ å°„åˆ°å…¶ç›¸åº”çš„æ ‡ç­¾ã€‚å¦‚å‰æ‰€è¿°ï¼Œè¿™äº›æ ‡ç­¾çš„è§„åˆ™æ˜¯ï¼š

- å¦‚æœç­”æ¡ˆä¸åœ¨ç›¸åº”ä¸Šä¸‹æ–‡çš„èŒƒå›´å†…ï¼Œåˆ™ä¸º `(0, 0)` 
- å¦‚æœç­”æ¡ˆåœ¨ç›¸åº”ä¸Šä¸‹æ–‡çš„èŒƒå›´å†…ï¼Œåˆ™ä¸º `(start_position, end_position)` ï¼Œå…¶ä¸­ `start_position` æ˜¯ç­”æ¡ˆèµ·å§‹å¤„çš„ token ç´¢å¼•ï¼ˆåœ¨ inputs ID ä¸­ï¼‰ï¼Œ `end_position` æ˜¯ç­”æ¡ˆç»“æŸå¤„çš„ token ç´¢å¼•ï¼ˆåœ¨ inputs ID ä¸­ï¼‰

ä¸ºäº†ç¡®å®šè¿™ä¸¤ç§æƒ…å†µä¸­çš„å“ªä¸€ç§ï¼Œå¹¶ä¸”å¦‚æœæ˜¯ç¬¬äºŒç§ï¼Œåˆ™éœ€è¦ç¡®å®š token çš„ä½ç½®ï¼Œæˆ‘ä»¬é¦–å…ˆæ‰¾åˆ°åœ¨è¾“å…¥ ID ä¸­èµ·å§‹å’Œç»“æŸä¸Šä¸‹æ–‡çš„ç´¢å¼•ã€‚æˆ‘ä»¬é¦–å…ˆæ‰¾åˆ°æ‹†åˆ†åçš„æ¯ä¸€ä¸ªéƒ¨åˆ†åœ¨ `Context` èµ·å§‹å’Œç»“æŸçš„ç´¢å¼•ï¼Œå¯ä»¥ä½¿ç”¨ token ç±»å‹ ID æ¥å®Œæˆæ­¤æ“ä½œï¼Œä½†ç”±äºå¹¶éæ‰€æœ‰æ¨¡å‹éƒ½æ”¯æŒè¿™æ ·çš„æ“ä½œï¼ˆå¦‚DistilBERTï¼‰ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ `tokenizer` çš„ `sequence_ids()` å‡½æ•°è¿”å›çš„ BatchEncoding å¯¹è±¡ã€‚

æœ‰äº†è¿™äº› tokens çš„ç´¢å¼•ä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥è®¡ç®—ç›¸åº”çš„åç§»é‡äº†ï¼Œå®ƒä»¬æ˜¯ä¸¤ä¸ªæ•´æ•°çš„å…ƒç»„ï¼Œè¡¨ç¤ºåŸå§‹ Context ä¸­çš„å­—ç¬¦èŒƒå›´ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æµ‹æ¯ä¸ªåˆ†å—ä¸­çš„ Context å—æ˜¯åœ¨ç­”æ¡ˆä¹‹åèµ·å§‹è¿˜æ˜¯åœ¨ç­”æ¡ˆèµ·å§‹ä¹‹å‰ç»“æŸï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ ‡ç­¾æ˜¯ `(0, 0)` ï¼‰ã€‚å¦‚æœç­”æ¡ˆå°±åœ¨ Context é‡Œï¼Œæˆ‘ä»¬å°±å¾ªç¯æŸ¥æ‰¾ç­”æ¡ˆçš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ª tokenï¼š

```py
answers = raw_datasets["train"][2:6]["answers"]
start_positions = []
end_positions = []

for i, offset in enumerate(inputs["offset_mapping"]):
    sample_idx = inputs["overflow_to_sample_mapping"][i]
    answer = answers[sample_idx]
    start_char = answer["answer_start"][0]
    end_char = answer["answer_start"][0] + len(answer["text"][0])
    sequence_ids = inputs.sequence_ids(i)

    # æ‰¾åˆ°ä¸Šä¸‹æ–‡çš„èµ·å§‹å’Œç»“æŸ
    idx = 0
    while sequence_ids[idx] != 1:
        idx += 1
    context_start = idx
    while sequence_ids[idx] == 1:
        idx += 1
    context_end = idx - 1

    # å¦‚æœç­”æ¡ˆä¸å®Œå…¨åœ¨ä¸Šä¸‹æ–‡å†…,æ ‡ç­¾ä¸º(0, 0)
    if offset[context_start][0] > start_char or offset[context_end][1] < end_char:
        start_positions.append(0)
        end_positions.append(0)
    else:
        # å¦åˆ™,å®ƒå°±æ˜¯èµ·å§‹å’Œç»“æŸ token çš„ä½ç½®
        idx = context_start
        while idx <= context_end and offset[idx][0] <= start_char:
            idx += 1
        start_positions.append(idx - 1)

        idx = context_end
        while idx >= context_start and offset[idx][1] >= end_char:
            idx -= 1
        end_positions.append(idx + 1)

start_positions, end_positions
```

```python out
([83, 51, 19, 0, 0, 64, 27, 0, 34, 0, 0, 0, 67, 34, 0, 0, 0, 0, 0],
 [85, 53, 21, 0, 0, 70, 33, 0, 40, 0, 0, 0, 68, 35, 0, 0, 0, 0, 0])
```

è®©æˆ‘ä»¬æŸ¥çœ‹ä¸€äº›ç»“æœæ¥éªŒè¯ä¸€ä¸‹æˆ‘ä»¬çš„æ–¹æ³•æ˜¯å¦æ­£ç¡®ã€‚åœ¨æ‹†åˆ†åçš„ç¬¬ä¸€ä¸ªéƒ¨åˆ†çš„æ–‡æœ¬ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº† `(83, 85)` æ˜¯å¾…é¢„æµ‹çš„æ ‡ç­¾å€¼ï¼Œå› æ­¤è®©æˆ‘ä»¬å°†ç†è®ºç­”æ¡ˆä¸ä» 83 åˆ° 85ï¼ˆåŒ…æ‹¬ 85ï¼‰çš„ tokens è§£ç çš„ç»“æœè¿›è¡Œæ¯”è¾ƒï¼š

```py
idx = 0
sample_idx = inputs["overflow_to_sample_mapping"][idx]
answer = answers[sample_idx]["text"][0]

start = start_positions[idx]
end = end_positions[idx]
labeled_answer = tokenizer.decode(inputs["input_ids"][idx][start : end + 1])

print(f"Theoretical answer: {answer}, labels give: {labeled_answer}")
```

```python out
'Theoretical answer: the Main Building, labels give: the Main Building'
```

å¾ˆå¥½ï¼å¯»æ‰¾çš„ç­”æ¡ˆæ˜¯æ­£ç¡®çš„ï¼ç°åœ¨è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æ‹†åˆ†åçš„ç¬¬4ä¸ªæ–‡æœ¬å—ï¼Œæˆ‘ä»¬æˆ‘ä»¬å¾—åˆ°çš„æ ‡ç­¾æ˜¯ `(0, 0)` ï¼Œè¿™æ„å‘³ç€ç­”æ¡ˆä¸åœ¨è¿™ä¸ªæ–‡æœ¬å—ä¸­ï¼š

```py
idx = 4
sample_idx = inputs["overflow_to_sample_mapping"][idx]
answer = answers[sample_idx]["text"][0]

decoded_example = tokenizer.decode(inputs["input_ids"][idx])
print(f"Theoretical answer: {answer}, decoded example: {decoded_example}")
```

```python out
'Theoretical answer: a Marian place of prayer and reflection, decoded example: [CLS] What is the Grotto at Notre Dame? [SEP] Architecturally, the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grot [SEP]'
```

ç¡®å®ï¼Œæˆ‘ä»¬åœ¨ Context ä¸­æ²¡æœ‰çœ‹åˆ°ç­”æ¡ˆã€‚

<Tip>

âœï¸ **è½®ä½ æ¥äº†ï¼** åœ¨ä½¿ç”¨ XLNet æ¶æ„æ—¶ï¼Œå¦‚æœæˆªå–åçš„æ–‡æœ¬é•¿åº¦æ²¡æœ‰è¾¾åˆ°è®¾å®šçš„æœ€å¤§é•¿åº¦ï¼Œéœ€è¦åœ¨å·¦ä¾§è¿›è¡Œå¡«å……ï¼Œå¹¶ä¸”éœ€è¦äº¤äº’é—®é¢˜å’Œ Context çš„é¡ºåºã€‚å°è¯•å°†æˆ‘ä»¬åˆšåˆšçœ‹åˆ°çš„æ‰€æœ‰ä»£ç è°ƒæ•´ä¸º XLNet æ¶æ„ï¼ˆå¹¶æ·»åŠ  `padding=True` ï¼‰ã€‚è¯·æ³¨æ„ï¼Œå› ä¸ºæ˜¯åœ¨å·¦ä¾§å¡«å……çš„ï¼Œæ‰€ä»¥å¡«å……åçš„ `[CLS]` tokens å¯èƒ½ä¸åœ¨ç´¢å¼•ä¸º 0 çš„ä½ç½®ã€‚

</Tip>

ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»é€æ­¥äº†è§£äº†å¦‚ä½•é¢„å¤„ç†æˆ‘ä»¬çš„è®­ç»ƒæ•°æ®ï¼Œæ¥ä¸‹æ¥å¯ä»¥å°†å…¶ç»„åˆåˆ°ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œå¹¶ä½¿ç”¨è¯¥å‡½æ•°å¤„ç†æ•´ä¸ªè®­ç»ƒæ•°æ®é›†ã€‚æˆ‘ä»¬å°†æ¯ä¸ªæ‹†åˆ†åçš„æ ·æœ¬éƒ½å¡«å……åˆ°æˆ‘ä»¬è®¾ç½®çš„æœ€å¤§é•¿åº¦ï¼Œå› ä¸ºå¤§å¤šæ•°ä¸Šä¸‹æ–‡éƒ½å¾ˆé•¿ï¼ˆç›¸åº”çš„æ ·æœ¬ä¼šè¢«åˆ†å‰²æˆå‡ å°å—ï¼‰ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œè¿›è¡ŒåŠ¨æ€å¡«å……çš„æ‰€å¸¦æ¥çš„å¢ç›Šä¸æ˜¯å¾ˆå¤§ã€‚

```py
max_length = 384
stride = 128


def preprocess_training_examples(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=max_length,
        truncation="only_second",
        stride=stride,
        return_overflowing_tokens=True,
        return_offsets_mapping=True,
        padding="max_length",
    )

    offset_mapping = inputs.pop("offset_mapping")
    sample_map = inputs.pop("overflow_to_sample_mapping")
    answers = examples["answers"]
    start_positions = []
    end_positions = []

    for i, offset in enumerate(offset_mapping):
        sample_idx = sample_map[i]
        answer = answers[sample_idx]
        start_char = answer["answer_start"][0]
        end_char = answer["answer_start"][0] + len(answer["text"][0])
        sequence_ids = inputs.sequence_ids(i)

        # æ‰¾åˆ°ä¸Šä¸‹æ–‡çš„èµ·å§‹å’Œç»“æŸ
        idx = 0
        while sequence_ids[idx] != 1:
            idx += 1
        context_start = idx
        while sequence_ids[idx] == 1:
            idx += 1
        context_end = idx - 1

        # å¦‚æœç­”æ¡ˆä¸å®Œå…¨åœ¨ä¸Šä¸‹æ–‡å†…,æ ‡ç­¾ä¸º(0, 0)
        if offset[context_start][0] > start_char or offset[context_end][1] < end_char:
            start_positions.append(0)
            end_positions.append(0)
        else:
            # å¦åˆ™,å®ƒå°±æ˜¯èµ·å§‹å’Œç»“æŸ tokens çš„ä½ç½®
            idx = context_start
            while idx <= context_end and offset[idx][0] <= start_char:
                idx += 1
            start_positions.append(idx - 1)

            idx = context_end
            while idx >= context_start and offset[idx][1] >= end_char:
                idx -= 1
            end_positions.append(idx + 1)

    inputs["start_positions"] = start_positions
    inputs["end_positions"] = end_positions
    return inputs
```

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸¤ä¸ªå¸¸é‡æ¥ç¡®å®šæ‰€ä½¿ç”¨çš„æœ€å¤§é•¿åº¦ä»¥åŠæ»‘åŠ¨çª—å£çš„é•¿åº¦ï¼Œå¹¶ä¸”åœ¨ä¹‹å‰ tokenize ä¹‹å‰å¯¹æ•°æ®è¿›è¡Œäº†ä¸€äº›æ¸…æ´—ï¼šSQuAD æ•°æ®é›†ä¸­çš„ä¸€äº›é—®é¢˜åœ¨å¼€å¤´å’Œç»“å°¾æœ‰é¢å¤–çš„ç©ºæ ¼ï¼Œè¿™äº›ç©ºæ ¼æ²¡æœ‰ä»»ä½•æ„ä¹‰ï¼ˆå¦‚æœä½ ä½¿ç”¨åƒ RoBERTa è¿™æ ·çš„æ¨¡å‹ï¼Œå®ƒä»¬ä¼šå ç”¨ tokenize çš„é•¿åº¦ï¼‰ï¼Œå› æ­¤æˆ‘ä»¬å»æ‰äº†è¿™äº›é¢å¤–çš„ç©ºæ ¼ã€‚

è¦ä½¿ç”¨è¯¥å‡½æ•°å¤„ç†æ•´ä¸ªè®­ç»ƒé›†ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `Dataset.map()` æ–¹æ³•å¹¶è®¾ç½® `batched=True` å‚æ•°ã€‚è¿™æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºæˆ‘ä»¬æ­£åœ¨æ›´æ”¹æ•°æ®é›†çš„é•¿åº¦ï¼ˆå› ä¸ºä¸€ä¸ªæ ·æœ¬å¯èƒ½ä¼šäº§ç”Ÿå¤šä¸ªå­æ ·æœ¬ï¼‰ï¼š

```py
train_dataset = raw_datasets["train"].map(
    preprocess_training_examples,
    batched=True,
    remove_columns=raw_datasets["train"].column_names,
)
len(raw_datasets["train"]), len(train_dataset)
```

```python out
(87599, 88729)
```

å¦‚æˆ‘ä»¬æ‰€è§ï¼Œé¢„å¤„ç†å¢åŠ äº†å¤§çº¦ 1000 ä¸ªæ ·æœ¬ã€‚æˆ‘ä»¬çš„è®­ç»ƒé›†ç°åœ¨å·²ç»å‡†å¤‡å¥½ä½¿ç”¨äº†â€”â€”è®©æˆ‘ä»¬æ·±å…¥ç ”ç©¶ä¸€ä¸‹éªŒè¯é›†çš„é¢„å¤„ç†ï¼

### å¤„ç†éªŒè¯æ•°æ® [[å¤„ç†éªŒè¯æ•°æ®]]

éªŒè¯é›†çš„é¢„å¤„ç†ä¼šæ›´åŠ å®¹æ˜“ï¼Œå› ä¸ºæˆ‘ä»¬ä¸éœ€è¦ç”Ÿæˆæ ‡ç­¾ï¼ˆé™¤éæˆ‘ä»¬æƒ³è®¡ç®—éªŒè¯æŸå¤±ï¼Œä½†é‚£ä¸ªæ•°å­—å¹¶ä¸èƒ½çœŸæ­£å¸®åŠ©æˆ‘ä»¬äº†è§£æ¨¡å‹çš„å¥½åï¼Œå¦‚æœè¦è¯„ä¼°æ¨¡å‹æ›´å¥½çš„æ–¹å¼ä½¿ç”¨æˆ‘ä»¬ä¹‹å‰æåˆ°çš„`squad` æŒ‡æ ‡ï¼‰ã€‚çœŸæ­£çš„æŒ‘æˆ˜åœ¨äºå°†æ¨¡å‹çš„é¢„æµ‹è½¬åŒ–ä¸ºä¸ºåŸå§‹ Context çš„ç‰‡æ®µã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬åªéœ€è¦å­˜å‚¨åç§»æ˜ å°„å¹¶ä¸”æ‰¾åˆ°ä¸€ç§æ–¹æ³•æ¥å°†æ¯ä¸ªåˆ†å‰²åçš„æ ·æœ¬ä¸åˆ†å‰²å‰çš„åŸå§‹ç‰‡æ®µåŒ¹é…èµ·æ¥ã€‚ç”±äºåŸå§‹æ•°æ®é›†ä¸­æœ‰ä¸€ä¸ª ID åˆ—ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨IDæ¥ä»£è¡¨åŸå§‹çš„ç‰‡æ®µã€‚

æˆ‘ä»¬å”¯ä¸€éœ€è¦åšçš„æ˜¯å¯¹åç§»æ˜ å°„è¿›è¡Œä¸€äº›å¾®å°ä¿®æ”¹ã€‚åç§»æ˜ å°„åŒ…å«é—®é¢˜å’Œ Context  çš„åç§»é‡ï¼ˆé—®é¢˜çš„åç§»é‡æ˜¯0ï¼ŒContext æ˜¯1ï¼‰ï¼Œä½†å½“æˆ‘ä»¬è¿›å…¥åå¤„ç†é˜¶æ®µï¼Œæˆ‘ä»¬å°†æ— æ³•çŸ¥é“ inputs ID çš„å“ªä¸ªéƒ¨åˆ†å¯¹åº”äº Contextï¼Œå“ªä¸ªéƒ¨åˆ†æ˜¯é—®é¢˜ï¼ˆæˆ‘ä»¬ä½¿ç”¨çš„ `sequence_ids()` æ–¹æ³•ä»…å¯ç”¨äº tokenizer çš„è¾“å‡ºï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†å°†ä¸é—®é¢˜å¯¹åº”çš„åç§»è®¾ç½®ä¸º `None` Context å¯¹åº”çš„åç§»é‡ä¿æŒä¸å˜ï¼š

```py
def preprocess_validation_examples(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=max_length,
        truncation="only_second",
        stride=stride,
        return_overflowing_tokens=True,
        return_offsets_mapping=True,
        padding="max_length",
    )

    sample_map = inputs.pop("overflow_to_sample_mapping")
    example_ids = []

    for i in range(len(inputs["input_ids"])):
        sample_idx = sample_map[i]
        example_ids.append(examples["id"][sample_idx])

        sequence_ids = inputs.sequence_ids(i)
        offset = inputs["offset_mapping"][i]
        inputs["offset_mapping"][i] = [
            o if sequence_ids[k] == 1 else None for k, o in enumerate(offset)
        ]

    inputs["example_id"] = example_ids
    return inputs
```

æˆ‘ä»¬å¯ä»¥åƒå¤„ç†è®­ç»ƒé›†ä¸€æ ·ä½¿ç”¨æ­¤å‡½æ•°å¤„ç†æ•´ä¸ªéªŒè¯æ•°æ®é›†ï¼š

```py
validation_dataset = raw_datasets["validation"].map(
    preprocess_validation_examples,
    batched=True,
    remove_columns=raw_datasets["validation"].column_names,
)
len(raw_datasets["validation"]), len(validation_dataset)
```

```python out
(10570, 10822)
```

ä»æœ€ç»ˆçš„ç»“æœæ¥çœ‹ï¼Œæˆ‘ä»¬åªæ·»åŠ äº†å‡ ç™¾ä¸ªæ ·æœ¬ï¼Œå› æ­¤éªŒè¯æ•°æ®é›†ä¸­çš„ Context ä¼¼ä¹è¦çŸ­ä¸€äº›ã€‚

ç°åœ¨æˆ‘ä»¬å·²ç»å¯¹æ‰€æœ‰æ•°æ®è¿›è¡Œäº†é¢„å¤„ç†ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹è®­ç»ƒäº†ã€‚

{#if fw === 'pt'}

## ä½¿ç”¨ `Trainer` API å¾®è°ƒæ¨¡å‹ [[ä½¿ç”¨ `Trainer` API å¾®è°ƒæ¨¡å‹]]

è¿™ä¸ªä¾‹å­çš„è®­ç»ƒä»£ç ä¸å‰é¢çš„éƒ¨åˆ†éå¸¸ç›¸ä¼¼ï¼Œæœ€å›°éš¾çš„éƒ¨åˆ†æ˜¯ç¼–å†™ `compute_metrics()` è¯„ä¼°æŒ‡æ ‡å‡½æ•°ã€‚ç”±äºæˆ‘ä»¬å°†æ‰€æœ‰æ ·æœ¬å¡«å……åˆ°äº†æˆ‘ä»¬è®¾ç½®çš„æœ€å¤§é•¿åº¦ï¼Œæ‰€ä»¥æ²¡æœ‰éœ€è¦å®šä¹‰çš„æ•°æ®æ•´ç†å™¨ï¼Œå› æ­¤æˆ‘ä»¬å”¯ä¸€éœ€è¦æ‹…å¿ƒçš„äº‹æƒ…æ˜¯å¦‚ä½•è®¡ç®—è¯„ä¼°æŒ‡æ ‡ã€‚æ¯”è¾ƒå›°éš¾çš„éƒ¨åˆ†å°†æ˜¯å°†æ¨¡å‹é¢„æµ‹çš„ç»“æœè¿˜åŸåˆ°åŸå§‹ç¤ºä¾‹ä¸­çš„æ–‡æœ¬ç‰‡æ®µï¼›ä¸€æ—¦æˆ‘ä»¬å®Œæˆäº†è¿™ä¸€æ­¥éª¤ï¼ŒğŸ¤— Datasets åº“ä¸­çš„ metric å°±å¯ä»¥å¸®åŠ©æˆ‘ä»¬åšå¤§éƒ¨åˆ†å·¥ä½œã€‚

{:else}

## ä½¿ç”¨ Keras å¾®è°ƒæ¨¡å‹ [[ä½¿ç”¨ Keras å¾®è°ƒæ¨¡å‹]]

è¿™ä¸ªä¾‹å­çš„è®­ç»ƒä»£ç ä¸å‰é¢çš„éƒ¨åˆ†éå¸¸ç›¸ä¼¼ï¼Œæœ€å›°éš¾çš„éƒ¨åˆ†æ˜¯è®¡ç®—è¯„ä¼°æŒ‡æ ‡ã€‚ç”±äºæˆ‘ä»¬å°†æ‰€æœ‰æ ·æœ¬å¡«å……åˆ°äº†æˆ‘ä»¬è®¾ç½®çš„æœ€å¤§é•¿åº¦ï¼Œæ‰€ä»¥æ²¡æœ‰éœ€è¦å®šä¹‰çš„æ•°æ®æ•´ç†å™¨ï¼Œå› æ­¤æˆ‘ä»¬å”¯ä¸€éœ€è¦æ‹…å¿ƒçš„äº‹æƒ…æ˜¯è®¡ç®—è¯„ä¼°æŒ‡æ ‡ã€‚æ¯”è¾ƒå›°éš¾çš„éƒ¨åˆ†å°†æ˜¯å°†æ¨¡å‹é¢„æµ‹çš„ç»“æœè¿˜åŸåˆ°åŸå§‹ç¤ºä¾‹ä¸­çš„æ–‡æœ¬ç‰‡æ®µï¼›ä¸€æ—¦æˆ‘ä»¬å®Œæˆäº†è¿™ä¸€æ­¥éª¤ï¼ŒğŸ¤— Datasets åº“ä¸­çš„ metric å°±å¯ä»¥å¸®åŠ©æˆ‘ä»¬åšå¤§éƒ¨åˆ†å·¥ä½œã€‚

{/if}

### åå¤„ç† [[åå¤„ç†]]

{#if fw === 'pt'}

<Youtube id="BNy08iIWVJM"/>

{:else}

<Youtube id="VN67ZpN33Ss"/>

{/if}

æ¨¡å‹å°†è¾“å‡ºç­”æ¡ˆåœ¨ inputs ID ä¸­èµ·å§‹å’Œç»“æŸä½ç½®çš„ logitï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨æ¢ç´¢ [`question-answering` pipeline](/course/chapter6/3b) æ—¶çœ‹åˆ°çš„é‚£æ ·ã€‚åå¤„ç†æ­¥éª¤ä¸æˆ‘ä»¬åœ¨é‚£é‡Œæ‰€åšçš„å¾ˆç›¸ä¼¼ï¼Œæ‰€ä»¥è¿™é‡Œç®€å•å›é¡¾ä¸€ä¸‹æˆ‘ä»¬æ‰€é‡‡å–çš„æ“ä½œï¼š

- æˆ‘ä»¬å±è”½äº†é™¤äº† Context ä¹‹å¤–çš„ tokens å¯¹åº”çš„èµ·å§‹å’Œç»“æŸ logitã€‚
- ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨ softmax å°†èµ·å§‹å’Œç»“æŸ logits è½¬æ¢ä¸ºæ¦‚ç‡ã€‚
- æˆ‘ä»¬é€šè¿‡å°†ä¸¤ä¸ªæ¦‚ç‡å¯¹åº”çš„ä¹˜ç§¯æ¥ä¸ºæ¯ä¸ª `(start_token, end_token)` å¯¹è®¡ç®—ä¸€ä¸ªåˆ†æ•°ã€‚
- æˆ‘ä»¬å¯»æ‰¾å…·æœ‰æœ€å¤§åˆ†æ•°ä¸”äº§ç”Ÿæœ‰æ•ˆç­”æ¡ˆï¼ˆä¾‹å¦‚ï¼Œ `start_token` å°äº `end_token` ï¼‰çš„å¯¹ã€‚

è¿™æ¬¡æˆ‘ä»¬å°†ç¨å¾®æ”¹å˜è¿™ä¸ªæµç¨‹ï¼Œå› ä¸ºæˆ‘ä»¬ä¸éœ€è¦è®¡ç®—å®é™…åˆ†æ•°ï¼ˆåªéœ€è¦é¢„æµ‹çš„ç­”æ¡ˆçš„æ–‡æœ¬ï¼‰ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥è·³è¿‡ softmax æ­¥éª¤ï¼ˆå› ä¸º softmax å¹¶ä¸ä¼šæ”¹å˜åˆ†æ•°å¤§å°çš„æ’åºï¼‰ã€‚ä¸ºäº†åŠ å¿«è®¡ç®—é€Ÿåº¦ï¼Œæˆ‘ä»¬ä¹Ÿä¸ä¼šä¸ºæ‰€æœ‰å¯èƒ½çš„ `(start_token, end_token)` å¯¹è®¡ç®—åˆ†æ•°ï¼Œè€Œåªä¼šè®¡ç®—ä¸æœ€é«˜çš„ `n_best` å¯¹åº”çš„ logit åˆ†æ•°ï¼ˆå…¶ä¸­ `n_best=20` ï¼‰ã€‚ç”±äºæˆ‘ä»¬å°†è·³è¿‡ softmaxï¼Œè¿™äº›åˆ†æ•°å°†æ˜¯ logit åˆ†æ•°ï¼Œè€Œä¸”æ˜¯èµ·å§‹å’Œç»“æŸå¯¹æ•°æ¦‚ç‡çš„å’Œï¼ˆè€Œä¸æ˜¯ä¹˜ç§¯ï¼Œå› ä¸ºå¯¹æ•°è¿ç®—è§„åˆ™ï¼š \($\log(ab) = \log(a) + \log(b))$ã€‚

ä¸ºäº†éªŒè¯çŒœæƒ³ï¼Œæˆ‘ä»¬éœ€è¦ä¸€äº›é¢„æµ‹ã€‚ç”±äºæˆ‘ä»¬è¿˜æ²¡æœ‰è®­ç»ƒæˆ‘ä»¬çš„æ¨¡å‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ QA ç®¡é“çš„é»˜è®¤æ¨¡å‹å¯¹ä¸€å°éƒ¨åˆ†éªŒè¯é›†ç”Ÿæˆä¸€äº›é¢„æµ‹ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å’Œä¹‹å‰ä¸€æ ·çš„å¤„ç†å‡½æ•°ï¼›å› ä¸ºå®ƒä¾èµ–äºå…¨å±€å¸¸é‡ `tokenizer` ï¼Œæˆ‘ä»¬åªéœ€å°†è¯¥å¯¹è±¡æ›´æ”¹ä¸ºæˆ‘ä»¬è¦ä¸´æ—¶ä½¿ç”¨çš„æ¨¡å‹çš„ tokenizer 

ä¸ºäº†æµ‹è¯•è¿™äº›ä»£ç ï¼Œæˆ‘ä»¬éœ€è¦ä¸€äº›é¢„æµ‹ç»“æœã€‚ç”±äºæˆ‘ä»¬è¿˜æ²¡æœ‰è®­ç»ƒæ¨¡å‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ QA pipeline çš„é»˜è®¤æ¨¡å‹åœ¨éªŒè¯é›†çš„ä¸€å°éƒ¨åˆ†ä¸Šç”Ÿæˆä¸€äº›é¢„æµ‹ç»“æœã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸ä¹‹å‰ç›¸åŒçš„å¤„ç†å‡½æ•°ï¼›å› ä¸ºå®ƒä¾èµ–äºå…¨å±€å¸¸é‡ `tokenizer` ï¼Œæ‰€ä»¥åªéœ€å°†å…¶æ›´æ”¹ä¸ºè¿™æ¬¡ä¸´æ—¶ä½¿ç”¨çš„æ¨¡å‹å¯¹åº”çš„ `tokenizer` å³å¯ã€‚

```python
small_eval_set = raw_datasets["validation"].select(range(100))
trained_checkpoint = "distilbert-base-cased-distilled-squad"

tokenizer = AutoTokenizer.from_pretrained(trained_checkpoint)
eval_set = small_eval_set.map(
    preprocess_validation_examples,
    batched=True,
    remove_columns=raw_datasets["validation"].column_names,
)
```

ç°åœ¨é¢„å¤„ç†å·²ç»å®Œæˆï¼Œæˆ‘ä»¬å°† `tokenizer` æ”¹å›æˆ‘ä»¬æœ€åˆé€‰æ‹©çš„ `tokenizer` ï¼š

```python
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)
```

ç„¶åæˆ‘ä»¬ç§»é™¤ `eval_set` ä¸­æ¨¡å‹ä¸éœ€è¦çš„åˆ—ï¼Œæ„å»ºä¸€ä¸ªåŒ…å«æ‰€æœ‰å°å‹éªŒè¯é›†æ•°æ®çš„ batchï¼Œå¹¶å°†å…¶ä¼ é€’ç»™æ¨¡å‹ã€‚å¦‚æœæœ‰å¯ç”¨çš„ GPUï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ GPU ä»¥åŠ å¿«è®¡ç®—ï¼š

{#if fw === 'pt'}

```python
import torch
from transformers import AutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns(["example_id", "offset_mapping"])
eval_set_for_model.set_format("torch")

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
batch = {k: eval_set_for_model[k].to(device) for k in eval_set_for_model.column_names}
trained_model = AutoModelForQuestionAnswering.from_pretrained(trained_checkpoint).to(
    device
)

with torch.no_grad():
    outputs = trained_model(**batch)
```

ä¸ºäº†ä¾¿äºå®éªŒï¼Œè®©æˆ‘ä»¬å°†è¿™äº›è¾“å‡ºè½¬æ¢ä¸º NumPy æ•°ç»„ï¼š

```python
start_logits = outputs.start_logits.cpu().numpy()
end_logits = outputs.end_logits.cpu().numpy()
```

{:else}

```python
import tensorflow as tf
from transformers import TFAutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns(["example_id", "offset_mapping"])
eval_set_for_model.set_format("numpy")

batch = {k: eval_set_for_model[k] for k in eval_set_for_model.column_names}
trained_model = TFAutoModelForQuestionAnswering.from_pretrained(trained_checkpoint)

outputs = trained_model(**batch)
```

ä¸ºäº†ä¾¿äºå®éªŒï¼Œè®©æˆ‘ä»¬å°†è¿™äº›è¾“å‡ºè½¬æ¢ä¸º NumPy æ•°ç»„ï¼š

```python
start_logits = outputs.start_logits.numpy()
end_logits = outputs.end_logits.numpy()
```

{/if}

ç°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ° `small_eval_set` ä¸­æ¯ä¸ªæ ·æœ¬çš„é¢„æµ‹ç­”æ¡ˆã€‚ä¸€ä¸ªæ ·æœ¬å¯èƒ½ä¼šè¢«æ‹†åˆ†æˆ `eval_set` ä¸­çš„å¤šä¸ªå­æ ·æœ¬ï¼Œæ‰€ä»¥ç¬¬ä¸€æ­¥æ˜¯å°† `small_eval_set` ä¸­çš„æ¯ä¸ªæ ·æœ¬æ˜ å°„åˆ° `eval_set` ä¸­å¯¹åº”çš„å­æ ·æœ¬ï¼š

```python
import collections

example_to_features = collections.defaultdict(list)
for idx, feature in enumerate(eval_set):
    example_to_features[feature["example_id"]].append(idx)
```

æœ‰äº†è¿™ä¸ªæ˜ å°„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¾ªç¯éå†æ‰€æœ‰æ ·æœ¬ï¼Œå¹¶éå†æ¯ä¸ªæ ·æœ¬çš„æ‰€æœ‰å­æ ·æœ¬ã€‚æ­£å¦‚ä¹‹å‰æ‰€è¯´ï¼Œæˆ‘ä»¬å°†æŸ¥çœ‹ `n_best` ä¸ªèµ·å§‹ logit å’Œç»“æŸ logit çš„å¾—åˆ†ï¼Œæ’é™¤ä»¥ä¸‹æƒ…å†µï¼š

- ç­”æ¡ˆä¸åœ¨ä¸Šä¸‹æ–‡ä¸­
- ç­”æ¡ˆé•¿åº¦ä¸ºè´Ÿæ•°
- ç­”æ¡ˆè¿‡é•¿ï¼ˆæˆ‘ä»¬å°†é•¿åº¦é™åˆ¶ä¸º `max_answer_length=30` ï¼‰

å½“æˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªæ ·æœ¬çš„æ‰€æœ‰å¾—åˆ†å¯èƒ½ç­”æ¡ˆï¼Œæˆ‘ä»¬åªéœ€é€‰æ‹©å…·æœ‰æœ€ä½³ logit å¾—åˆ†çš„ç­”æ¡ˆï¼š

```python
import numpy as np

n_best = 20
max_answer_length = 30
predicted_answers = []

for example in small_eval_set:
    example_id = example["id"]
    context = example["context"]
    answers = []

    for feature_index in example_to_features[example_id]:
        start_logit = start_logits[feature_index]
        end_logit = end_logits[feature_index]
        offsets = eval_set["offset_mapping"][feature_index]

        start_indexes = np.argsort(start_logit)[-1 : -n_best - 1 : -1].tolist()
        end_indexes = np.argsort(end_logit)[-1 : -n_best - 1 : -1].tolist()
        for start_index in start_indexes:
            for end_index in end_indexes:
                # è·³è¿‡ä¸å®Œå…¨åœ¨ä¸Šä¸‹æ–‡ä¸­çš„ç­”æ¡ˆ
                if offsets[start_index] is None or offsets[end_index] is None:
                    continue
                # è·³è¿‡é•¿åº¦ä¸ºè´Ÿæ•°æˆ–å¤§äº max_answer_length çš„ç­”æ¡ˆã€‚
                if (
                    end_index < start_index
                    or end_index - start_index + 1 > max_answer_length
                ):
                    continue

                answers.append(
                    {
                        "text": context[offsets[start_index][0] : offsets[end_index][1]],
                        "logit_score": start_logit[start_index] + end_logit[end_index],
                    }
                )

    best_answer = max(answers, key=lambda x: x["logit_score"])
    predicted_answers.append({"id": example_id, "prediction_text": best_answer["text"]})
```

å®Œæˆä¸Šè¿°å¤„ç†åï¼Œé¢„æµ‹ç­”æ¡ˆå°±å˜æˆäº†æˆ‘ä»¬å°†ä½¿ç”¨çš„è¯„ä¼°æŒ‡æ ‡æ‰€è¦æ±‚çš„è¾“å…¥çš„æ ¼å¼ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹å¯ä»¥å€ŸåŠ©ğŸ¤— Evaluate åº“æ¥åŠ è½½å®ƒã€‚

```python
import evaluate

metric = evaluate.load("squad")
```

è¿™ä¸ªè¯„ä¼°æŒ‡æ ‡ä¸€ä¸ªå¦‚ä¸Šæ‰€ç¤ºæ ¼å¼ï¼ˆä¸€ä¸ªåŒ…å«ç¤ºä¾‹ ID å’Œé¢„æµ‹æ–‡æœ¬çš„å­—å…¸åˆ—è¡¨ï¼‰çš„é¢„æµ‹ç­”æ¡ˆï¼ŒåŒæ—¶ä¹Ÿéœ€è¦ä¸€ä¸ªå¦‚ä¸‹æ ¼å¼ï¼ˆä¸€ä¸ªåŒ…å«ç¤ºä¾‹ ID å’Œå¯èƒ½ç­”æ¡ˆçš„å­—å…¸åˆ—è¡¨ï¼‰çš„å‚è€ƒç­”æ¡ˆï¼š

è¯¥è¯„ä¼°æŒ‡æ ‡éœ€è¦ä¸€ä¸ªç”±æ ·æœ¬ ID å’Œé¢„æµ‹æ–‡æœ¬å­—å…¸çš„åˆ—è¡¨ç»„æˆé¢„æµ‹ç­”æ¡ˆï¼ŒåŒæ—¶ä¹Ÿéœ€è¦ä¸€ä¸ªç”±å‚è€ƒID å’Œå¯èƒ½ç­”æ¡ˆå­—å…¸çš„åˆ—è¡¨ç»„æˆå‚è€ƒç­”æ¡ˆã€‚

```python
theoretical_answers = [
    {"id": ex["id"], "answers": ex["answers"]} for ex in small_eval_set
]
```

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æŸ¥çœ‹ä¸¤ä¸ªåˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ¥æ£€æŸ¥æ˜¯å¦ç¬¦åˆè¯„ä¼°æŒ‡æ ‡çš„è¦æ±‚ï¼š

```python
print(predicted_answers[0])
print(theoretical_answers[0])
```

```python out
{'id': '56be4db0acb8001400a502ec', 'prediction_text': 'Denver Broncos'}
{'id': '56be4db0acb8001400a502ec', 'answers': {'text': ['Denver Broncos', 'Denver Broncos', 'Denver Broncos'], 'answer_start': [177, 177, 177]}}
```

è¿˜ä¸é”™ï¼ç°åœ¨è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹è¯„ä¼°æŒ‡æ ‡ç»™å‡ºçš„åˆ†æ•°ï¼š

```python
metric.compute(predictions=predicted_answers, references=theoretical_answers)
```

```python out
{'exact_match': 83.0, 'f1': 88.25}
```

æ ¹æ® [DistilBERT çš„è®ºæ–‡](https://arxiv.org/abs/1910.01108v2) æ‰€è¿°ï¼ŒDistilBERT åœ¨ SQuAD ä¸Šå¾®è°ƒåæ•´ä½“æ•°æ®é›†çš„å¾—åˆ†ä¸º 79.1 å’Œ 86.9ï¼Œç›¸æ¯”ä¹‹ä¸‹æˆ‘ä»¬å–å¾—çš„ç»“æœç›¸å½“ä¸é”™ã€‚

{#if fw === 'pt'}

ç°åœ¨ï¼Œè®©æˆ‘ä»¬å°†åˆšæ‰æ‰€åšçš„æ”¾å…¥ `compute_metrics()` å‡½æ•°ä¸­ï¼Œå°±å¯ä»¥åœ¨ `Trainer` ä¸­ä½¿ç”¨å®ƒäº†ã€‚é€šå¸¸ï¼Œ `compute_metrics()` å‡½æ•°åªæ¥æ”¶ä¸€ä¸ªåŒ…å« logits å’Œå¸¦é¢„æµ‹æ ‡ç­¾ç»„æˆçš„ `eval_preds` å…ƒç»„ã€‚ä½†æ˜¯åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬éœ€è¦æ›´å¤šçš„ä¿¡æ¯æ‰èƒ½è¯„ä¼°ç»“æœï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦åœ¨åˆ†å‰²åçš„æ•°æ®é›†ä¸­æŸ¥æ‰¾åç§»é‡ï¼Œå¹¶åœ¨åŸå§‹æ•°æ®é›†ä¸­æŸ¥æ‰¾åŸå§‹ Contextï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ä½¿ç”¨æ­¤å‡½æ•°æ¥è·å–å¸¸è§„çš„è¯„ä¼°ç»“æœã€‚æˆ‘ä»¬åªä¼šåœ¨è®­ç»ƒç»“æŸæ—¶ä½¿ç”¨å®ƒæ¥æ£€æŸ¥è®­ç»ƒçš„ç»“æœã€‚
`compute_metrics()` å‡½æ•°ä¸ä¹‹å‰çš„æ­¥éª¤ç›¸åŒï¼›æˆ‘ä»¬åªæ˜¯æ·»åŠ äº†ä¸€ä¸ªå°çš„æ£€æŸ¥ï¼Œä»¥é˜²æˆ‘ä»¬æ‰¾ä¸åˆ°ä»»ä½•æœ‰æ•ˆçš„ç­”æ¡ˆï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„é¢„æµ‹ä¼šè¾“å‡ºä¸€ä¸ªç©ºå­—ç¬¦ä¸²ï¼‰ã€‚

{:else}

ç°åœ¨ï¼Œè®©æˆ‘ä»¬å°†åˆšæ‰æ‰€åšçš„æ”¾å…¥ `compute_metrics()` å‡½æ•°ä¸­ï¼Œå°±å¯ä»¥åœ¨è®­ç»ƒæ¨¡å‹æ—¶ä½¿ç”¨è¯¥å‡½æ•°ã€‚æˆ‘ä»¬éœ€è¦ä¼ é€’çš„ä¸ä»…ä»…æ˜¯è¾“å‡ºçš„ logitsï¼Œå› ä¸ºæˆ‘ä»¬å¿…é¡»åœ¨åˆ†å‰²åçš„æ•°æ®é›†ä¸­æŸ¥æ‰¾åç§»é‡ï¼Œå¹¶åœ¨åŸå§‹æ•°æ®é›†ä¸­æŸ¥æ‰¾åŸå§‹çš„ Contextï¼š

{/if}

```python
from tqdm.auto import tqdm


def compute_metrics(start_logits, end_logits, features, examples):
    example_to_features = collections.defaultdict(list)
    for idx, feature in enumerate(features):
        example_to_features[feature["example_id"]].append(idx)

    predicted_answers = []
    for example in tqdm(examples):
        example_id = example["id"]
        context = example["context"]
        answers = []

        # å¾ªç¯éå†ä¸è¯¥ç¤ºä¾‹ç›¸å…³è”çš„æ‰€æœ‰ç‰¹å¾
        for feature_index in example_to_features[example_id]:
            start_logit = start_logits[feature_index]
            end_logit = end_logits[feature_index]
            offsets = features[feature_index]["offset_mapping"]

            start_indexes = np.argsort(start_logit)[-1 : -n_best - 1 : -1].tolist()
            end_indexes = np.argsort(end_logit)[-1 : -n_best - 1 : -1].tolist()
            for start_index in start_indexes:
                for end_index in end_indexes:
                    # è·³è¿‡ä¸å®Œå…¨ä½äºä¸Šä¸‹æ–‡ä¸­çš„ç­”æ¡ˆ
                    if offsets[start_index] is None or offsets[end_index] is None:
                        continue
                    # è·³è¿‡é•¿åº¦å°äº 0 æˆ–å¤§äº max_answer_length çš„ç­”æ¡ˆ
                    if (
                        end_index < start_index
                        or end_index - start_index + 1 > max_answer_length
                    ):
                        continue

                    answer = {
                        "text": context[offsets[start_index][0] : offsets[end_index][1]],
                        "logit_score": start_logit[start_index] + end_logit[end_index],
                    }
                    answers.append(answer)

        # é€‰æ‹©å¾—åˆ†æœ€é«˜çš„ç­”æ¡ˆ
        if len(answers) > 0:
            best_answer = max(answers, key=lambda x: x["logit_score"])
            predicted_answers.append(
                {"id": example_id, "prediction_text": best_answer["text"]}
            )
        else:
            predicted_answers.append({"id": example_id, "prediction_text": ""})

    theoretical_answers = [{"id": ex["id"], "answers": ex["answers"]} for ex in examples]
    return metric.compute(predictions=predicted_answers, references=theoretical_answers)
```

æˆ‘ä»¬å¯ä»¥è¯„ä¼°æˆ‘ä»¬æ¨¡å‹åœ¨è¯„ä¼°æ•°æ®é›†è¾“å‡ºçš„ç»“æœï¼š

```python
compute_metrics(start_logits, end_logits, eval_set, small_eval_set)
```

```python out
{'exact_match': 83.0, 'f1': 88.25}
```

çœ‹èµ·æ¥ä¸é”™ï¼ç°åœ¨è®©æˆ‘ä»¬ä½¿ç”¨å®ƒæ¥å¾®è°ƒæˆ‘ä»¬çš„æ¨¡å‹ã€‚

### å¾®è°ƒæ¨¡å‹ [[å¾®è°ƒæ¨¡å‹]]

{#if fw === 'pt'}

ç°åœ¨æˆ‘ä»¬å·²ç»å‡†å¤‡å¥½è®­ç»ƒæˆ‘ä»¬çš„æ¨¡å‹äº†ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬åƒä¹‹å‰ä¸€æ ·ä½¿ç”¨ `AutoModelForQuestionAnswering` ç±»åˆ›å»ºæ¨¡å‹ï¼š

```python
model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)
```

{:else}

ç°åœ¨æˆ‘ä»¬å·²ç»å‡†å¤‡å¥½è®­ç»ƒæˆ‘ä»¬çš„æ¨¡å‹äº†ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬åƒä¹‹å‰ä¸€æ ·ä½¿ç”¨ `TFAutoModelForQuestionAnswering` ç±»åˆ›å»ºæ¨¡å‹ï¼š

```python
model = TFAutoModelForQuestionAnswering.from_pretrained(model_checkpoint)
```

{/if}

å’Œä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬ä¼šæ”¶åˆ°ä¸€ä¸ªè­¦å‘Šï¼Œæç¤ºæœ‰äº›æƒé‡æ²¡æœ‰è¢«ä½¿ç”¨ï¼ˆæ¥è‡ªé¢„è®­ç»ƒå¤´éƒ¨çš„æƒé‡ï¼‰ï¼Œè€Œå…¶ä»–ä¸€äº›æƒé‡æ˜¯éšæœºåˆå§‹åŒ–çš„ï¼ˆç”¨äºé—®ç­”å¤´éƒ¨çš„æƒé‡ï¼‰ã€‚ä½ ç°åœ¨åº”è¯¥å·²ç»ä¹ æƒ¯äº†è¿™ç§æƒ…å†µï¼Œä½†è¿™æ„å‘³ç€è¿™ä¸ªæ¨¡å‹è¿˜æ²¡æœ‰å‡†å¤‡å¥½ä½¿ç”¨ï¼Œéœ€è¦è¿›è¡Œå¾®è°ƒâ€”â€”å¥½åœ¨è¿™æ­£æ˜¯æˆ‘ä»¬æ¥ä¸‹æ¥è¦åšçš„äº‹æƒ…ï¼

ä¸ºäº†èƒ½å¤Ÿå°†æˆ‘ä»¬çš„æ¨¡å‹æ¨é€åˆ° Hubï¼Œæˆ‘ä»¬éœ€è¦ç™»å½• Hugging Faceã€‚å¦‚æœä½ åœ¨ Notebook ä¸­è¿è¡Œæ­¤ä»£ç ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ä»¥ä¸‹çš„å‡½æ•°æ‰§è¡Œæ­¤æ“ä½œï¼Œè¯¥å‡½æ•°ä¼šæ˜¾ç¤ºä¸€ä¸ªå°éƒ¨ä»¶ï¼Œä½ å¯ä»¥åœ¨å…¶ä¸­è¾“å…¥ç™»å½•å‡­æ®è¿›è¡Œç™»é™†ï¼š

```python
from huggingface_hub import notebook_login

notebook_login()
```

å¦‚æœä½ ä¸åœ¨ Notebook ä¸­å·¥ä½œï¼Œåªéœ€åœ¨ç»ˆç«¯ä¸­è¾“å…¥ä»¥ä¸‹è¡Œï¼š

```bash
huggingface-cli login
```

{#if fw === 'pt'}

å®Œæˆåï¼Œæˆ‘ä»¬å°±å¯ä»¥å®šä¹‰æˆ‘ä»¬çš„ `TrainingArguments` ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨å®šä¹‰è®¡ç®—è¯„ä¼°å‡½æ•°æ—¶æ‰€è¯´çš„ï¼Œç”±äº `compute_metrics()` å‡½æ•°çš„è¾“å…¥å‚æ•°é™åˆ¶ï¼Œæˆ‘ä»¬æ— æ³•ä½¿ç”¨å¸¸è§„çš„æ–¹æ³•æ¥ç¼–å†™è¯„ä¼°å¾ªç¯ã€‚ä¸è¿‡ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™è‡ªå·±çš„ `Trainer` å­ç±»æ¥å®ç°è¿™ä¸€ç‚¹ï¼ˆä½ å¯ä»¥åœ¨ [é—®ç­”ç¤ºä¾‹ä»£ç ](https://github.com/huggingface/transformers/blob/master/examples/pytorch/question-answering/trainer_qa.py) ä¸­æ‰¾åˆ°è¯¥æ–¹æ³•ï¼‰ï¼Œä½†æ”¾åœ¨æœ¬èŠ‚ä¸­ä¼šæœ‰äº›å†—é•¿ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå°†ä»…åœ¨è®­ç»ƒç»“æŸæ—¶è¯„ä¼°æ¨¡å‹ï¼Œå¹¶åœ¨ä¸‹é¢çš„â€œè‡ªå®šä¹‰è®­ç»ƒå¾ªç¯â€ä¸­å‘ä½ å±•ç¤ºå¦‚ä½•ä½¿ç”¨å¸¸è§„çš„æ–¹æ³•è¿›è¡Œè¯„ä¼°ã€‚

è¿™ç¡®å®æ˜¯ `Trainer` API å±€é™æ€§çš„åœ°æ–¹ï¼Œè€ŒğŸ¤— Accelerate åº“åˆ™éå¸¸é€‚åˆå¤„ç†è¿™ç§æƒ…å†µï¼šå®šåˆ¶åŒ–ç‰¹å®šç”¨ä¾‹çš„ç±»å¯èƒ½ä¼šå¾ˆç¹çï¼Œä½†å®šåˆ¶åŒ–è°ƒæ•´è®­ç»ƒå¾ªç¯å´å¾ˆç®€å•ã€‚

è®©æˆ‘ä»¬æ¥çœ‹çœ‹æˆ‘ä»¬çš„ `TrainingArguments` ï¼š

```python
from transformers import TrainingArguments

args = TrainingArguments(
    "bert-finetuned-squad",
    evaluation_strategy="no",
    save_strategy="epoch",
    learning_rate=2e-5,
    num_train_epochs=3,
    weight_decay=0.01,
    fp16=True,
    push_to_hub=True,
)
```

æˆ‘ä»¬ä¹‹å‰å·²ç»è§è¿‡å…¶ä¸­å¤§éƒ¨åˆ†å†…å®¹ï¼šæˆ‘ä»¬è®¾ç½®äº†ä¸€äº›è¶…å‚æ•°ï¼ˆå¦‚å­¦ä¹ ç‡ã€è®­ç»ƒçš„å‘¨æœŸæ•°å’Œä¸€äº›æƒé‡è¡°å‡ï¼‰ï¼Œå¹¶è®¾å®šæˆ‘ä»¬æƒ³åœ¨æ¯ä¸ªå‘¨æœŸç»“æŸæ—¶ä¿å­˜æ¨¡å‹ã€è·³è¿‡è¯„ä¼°ï¼Œå¹¶å°†ç»“æœä¸Šä¼ åˆ°æ¨¡å‹ä¸­å¿ƒã€‚æˆ‘ä»¬è¿˜å¯ç”¨äº† `fp16=True` çš„æ··åˆç²¾åº¦è®­ç»ƒï¼Œå› ä¸ºå®ƒå¯ä»¥åœ¨æœ€æ–°çš„ GPU ä¸ŠåŠ å¿«è®­ç»ƒé€Ÿåº¦ã€‚

{:else}

ç°åœ¨å®Œæˆäº†è¿™ä¸€æ­¥éª¤ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºæˆ‘ä»¬çš„ TF æ•°æ®é›†ã€‚è¿™æ¬¡æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç®€å•çš„é»˜è®¤æ•°æ®æ•´ç†å™¨ï¼š

```python
from transformers import DefaultDataCollator

data_collator = DefaultDataCollator(return_tensors="tf")
```

ç„¶ååƒå¾€å¸¸ä¸€æ ·åˆ›å»ºæ•°æ®é›†ã€‚

```python
tf_train_dataset = model.prepare_tf_dataset(
    train_dataset,
    collate_fn=data_collator,
    shuffle=True,
    batch_size=16,
)
tf_eval_dataset = model.prepare_tf_dataset(
    validation_dataset,
    collate_fn=data_collator,
    shuffle=False,
    batch_size=16,
)
```

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è®¾ç½®è®­ç»ƒè¶…å‚æ•°å¹¶ç¼–è¯‘æˆ‘ä»¬çš„æ¨¡å‹

```python
from transformers import create_optimizer
from transformers.keras_callbacks import PushToHubCallback
import tensorflow as tf

# è®­ç»ƒæ­¥éª¤çš„æ•°é‡æ˜¯æ•°æ®é›†ä¸­çš„æ ·æœ¬æ•°é‡é™¤ä»¥ batch å¤§å°,ç„¶åä¹˜ä»¥æ€»çš„è®­ç»ƒå‘¨æœŸæ•°ã€‚
# æ³¨æ„,è¿™é‡Œçš„ tf_train_dataset æ˜¯ä¸€ä¸ªbatchçš„ tf.data.Dataset,
# è€Œä¸æ˜¯åŸå§‹çš„ Hugging Face æ•°æ®é›†,æ‰€ä»¥ä½¿ç”¨ len() è®¡ç®—å…¶é•¿åº¦å·²ç»æ˜¯ num_samples // batch_sizeã€‚
num_train_epochs = 3
num_train_steps = len(tf_train_dataset) * num_train_epochs
optimizer, schedule = create_optimizer(
    init_lr=2e-5,
    num_warmup_steps=0,
    num_train_steps=num_train_steps,
    weight_decay_rate=0.01,
)
model.compile(optimizer=optimizer)

# ä½¿ç”¨ float16 æ··åˆç²¾åº¦è¿›è¡Œè®­ç»ƒ
tf.keras.mixed_precision.set_global_policy("mixed_float16")
```

æœ€åï¼Œæˆ‘ä»¬å‡†å¤‡ä½¿ç”¨ `model.fit()` è¿›è¡Œè®­ç»ƒï¼Œä½¿ç”¨ `PushToHubCallback` åœ¨æ¯ä¸ªå‘¨æœŸç»“æŸåå°†æ¨¡å‹ä¸Šä¼ åˆ°æ¨¡å‹ä¸­å¿ƒã€‚

{/if}

é»˜è®¤æƒ…å†µä¸‹ï¼Œä½¿ç”¨çš„ä»“åº“å°†ä¿å­˜åœ¨ä½ çš„è´¦æˆ·ä¸­ï¼Œå¹¶ä»¥ä½ è®¾ç½®çš„è¾“å‡ºç›®å½•å‘½åï¼Œæ‰€ä»¥åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­å®ƒå°†ä½äº `"sgugger/bert-finetuned-squad"` ä¸­ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¼ é€’ä¸€ä¸ª `hub_model_id` å‚æ•°æ¥è¦†ç›–è¿™ä¸ªè®¾ç½®ï¼›ä¾‹å¦‚ï¼Œè¦å°†æ¨¡å‹æ¨é€åˆ°æˆ‘ä»¬ä½¿ç”¨çš„ `huggingface_course` ç»„ç»‡ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† `hub_model_id="huggingface_course/bert-finetuned-squad"` ï¼ˆè¿™æ˜¯æˆ‘ä»¬åœ¨æœ¬èŠ‚å¼€å§‹æ—¶æ¼”ç¤ºçš„æ¨¡å‹ï¼‰ã€‚

{#if fw === 'pt'}

<Tip>

ğŸ’¡ å¦‚æœä½ æ­£åœ¨ä½¿ç”¨çš„è¾“å‡ºç›®å½•å·²ç»å­˜åœ¨ä¸€ä¸ªåŒåçš„æ–‡ä»¶ï¼Œåˆ™å®ƒéœ€è¦æ˜¯ä½ è¦æ¨é€åˆ°çš„å­˜å‚¨åº“å…‹éš†åœ¨æœ¬åœ°çš„ç‰ˆæœ¬ï¼ˆå› æ­¤ï¼Œå¦‚æœåœ¨å®šä¹‰ä½ çš„ `Trainer` æ—¶å‡ºç°é”™è¯¯ï¼Œè¯·è®¾ç½®ä¸€ä¸ªæ–°çš„åç§°ï¼‰ã€‚

</Tip>

æœ€åï¼Œæˆ‘ä»¬åªéœ€å°†æ‰€æœ‰å†…å®¹ä¼ é€’ç»™ `Trainer` ç±»å¹¶å¯åŠ¨è®­ç»ƒï¼š

```python
from transformers import Trainer

trainer = Trainer(
    model=model,
    args=args,
    train_dataset=train_dataset,
    eval_dataset=validation_dataset,
    tokenizer=tokenizer,
)
trainer.train()
```

{:else}

```python
from transformers.keras_callbacks import PushToHubCallback

callback = PushToHubCallback(output_dir="bert-finetuned-squad", tokenizer=tokenizer)

# æˆ‘ä»¬å°†åœ¨ä¹‹åè¿›è¡ŒéªŒè¯,å› æ­¤è®­ç»ƒè¿‡ç¨‹ä¸­ä¸ä¼šè¿›è¡ŒéªŒè¯
model.fit(tf_train_dataset, callbacks=[callback], epochs=num_train_epochs)
```

{/if}

è¯·æ³¨æ„ï¼Œåœ¨è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œæ¯æ¬¡æ¨¡å‹ä¿å­˜ï¼ˆä¾‹å¦‚ï¼Œæ¯ä¸ª epoch ç»“æŸæ—¶ï¼‰ï¼Œæ¨¡å‹éƒ½ä¼šåœ¨åå°ä¸Šä¼ åˆ° Hubã€‚è¿™æ ·ï¼Œå¦‚æœéœ€è¦çš„è¯ï¼Œä½ å°±å¯ä»¥åœ¨å¦ä¸€å°æœºå™¨ä¸Šæ¢å¤è®­ç»ƒã€‚æ•´ä¸ªè®­ç»ƒè¿‡ç¨‹éœ€è¦ä¸€äº›æ—¶é—´ï¼ˆåœ¨ Titan RTX ä¸Šç•¥è¶…è¿‡ä¸€ä¸ªå°æ—¶ï¼‰ï¼Œæ‰€ä»¥ä½ å¯ä»¥å–æ¯å’–å•¡æˆ–è€…é‡æ–°é˜…è¯»ä¸€äº›ä½ è§‰å¾—æ›´å…·æŒ‘æˆ˜æ€§çš„è¯¾ç¨‹éƒ¨åˆ†æ¥æ¶ˆç£¨æ—¶é—´ã€‚è¿˜è¦æ³¨æ„ï¼Œåœ¨ç¬¬ä¸€ä¸ª epoch å®Œæˆåï¼Œä½ å¯ä»¥çœ‹åˆ°ä¸€äº›æƒé‡ä¸Šä¼ åˆ° Hubï¼Œå¹¶ä¸”ä½ å¯ä»¥åœ¨å…¶é¡µé¢ä¸Šå¼€å§‹ä½¿ç”¨ä½ çš„æ¨¡å‹è¿›è¡Œæµ‹è¯•ã€‚

{#if fw === 'pt'}

è®­ç»ƒå®Œæˆåï¼Œæˆ‘ä»¬å°±å¯ä»¥è¯„ä¼°æˆ‘ä»¬æœ€ç»ˆçš„æ¨¡å‹äº†ï¼ˆå¹¶ç¥ˆç¥·æˆ‘ä»¬å¯ä»¥ä¸€æ¬¡æˆåŠŸï¼‰ã€‚ `Trainer` çš„ `predict()` æ–¹æ³•å°†è¿”å›ä¸€ä¸ªå…ƒç»„ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ å°†æ˜¯æ¨¡å‹çš„é¢„æµ‹ç»“æœï¼ˆåœ¨è¿™é‡Œæ˜¯ä¸€ä¸ªåŒ…å«èµ·å§‹å’Œç»“æŸ logits çš„æ•°å€¼å¯¹ï¼‰ã€‚æˆ‘ä»¬å°†è¿™ä¸ªç»“æœä¼ é€’ç»™æˆ‘ä»¬çš„ `compute_metrics()` å‡½æ•°ï¼š

```python
predictions, _, _ = trainer.predict(validation_dataset)
start_logits, end_logits = predictions
compute_metrics(start_logits, end_logits, validation_dataset, raw_datasets["validation"])
```

{:else}

è®­ç»ƒå®Œæˆåï¼Œæˆ‘ä»¬å¯ä»¥æœ€ç»ˆè¯„ä¼°æˆ‘ä»¬çš„æ¨¡å‹ï¼ˆå¹¶ç¥ˆç¥·æˆ‘ä»¬å¯ä»¥ä¸€æ¬¡æˆåŠŸï¼‰ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `model` çš„ `predict()` æ–¹æ³•å°†è´Ÿè´£è·å–é¢„æµ‹ç»“æœï¼Œå¹¶ä¸”ç”±äºæˆ‘ä»¬ä¹‹å‰å·²ç»å®šä¹‰äº†ä¸€ä¸ª `compute_metrics()` å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨ä¸€è¡Œä»£ç å¾—åˆ°æˆ‘ä»¬çš„ç»“æœï¼š

```python
predictions = model.predict(tf_eval_dataset)
compute_metrics(
    predictions["start_logits"],
    predictions["end_logits"],
    validation_dataset,
    raw_datasets["validation"],
)
```

{/if}

```python out
{'exact_match': 81.18259224219489, 'f1': 88.67381321905516}
```

å¾ˆæ£’ï¼ä½œä¸ºå¯¹æ¯”ï¼ŒBERT æ–‡ç« ä¸­æŠ¥å‘Šçš„è¯¥æ¨¡å‹çš„åŸºå‡†åˆ†æ•°åˆ†åˆ«ä¸º 80.8 å’Œ 88.5ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„ç»“æœæ­£å¥½è¾¾åˆ°äº†é¢„æœŸåˆ†æ•°ã€‚

{#if fw === 'pt'}

æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨ `push_to_hub()` æ–¹æ³•ç¡®ä¿ä¸Šä¼ æ¨¡å‹çš„æœ€æ–°ç‰ˆæœ¬ï¼š

```py
trainer.push_to_hub(commit_message="Training complete")
```

å¦‚æœä½ æƒ³æ£€æŸ¥å®ƒï¼Œä¸Šé¢çš„ä»£ç è¿”å›å®ƒåˆšåˆšæ‰§è¡Œçš„æäº¤çš„ URLï¼š

```python out
'https://huggingface.co/sgugger/bert-finetuned-squad/commit/9dcee1fbc25946a6ed4bb32efb1bd71d5fa90b68'
```
`Trainer` è¿˜ä¼šåˆ›å»ºä¸€ä¸ªåŒ…å«æ‰€æœ‰è¯„ä¼°ç»“æœçš„æ¨¡å‹å¡ç‰‡ï¼Œå¹¶å°†å…¶ä¸Šä¼ ã€‚

{/if}

åœ¨è¿™ä¸ªé˜¶æ®µï¼Œä½ å¯ä»¥ä½¿ç”¨æ¨¡å‹åº“ä¸­çš„æ¨ç†å°éƒ¨ä»¶æ¥æµ‹è¯•æ¨¡å‹ï¼Œå¹¶ä¸ä½ çš„æœ‹å‹ã€å®¶äººå’ŒåŒä¼´åˆ†äº«ã€‚æ­å–œä½ æˆåŠŸåœ°åœ¨é—®ç­”ä»»åŠ¡ä¸Šå¯¹æ¨¡å‹è¿›è¡Œäº†å¾®è°ƒï¼

<Tip>

âœï¸ **è½®åˆ°ä½ äº†ï¼** å°è¯•ä½¿ç”¨å¦ä¸€ä¸ªæ¨¡å‹æ¶æ„ï¼Œçœ‹çœ‹å®ƒåœ¨è¿™ä¸ªä»»åŠ¡ä¸Šè¡¨ç°å¾—æ˜¯å¦æ›´å¥½ï¼

</Tip>

{#if fw === 'pt'}

å¦‚æœä½ æƒ³æ›´æ·±å…¥åœ°äº†è§£è®­ç»ƒå¾ªç¯ï¼Œæˆ‘ä»¬ç°åœ¨å°†å‘ä½ å±•ç¤ºå¦‚ä½•ä½¿ç”¨ ğŸ¤— Accelerate æ¥åšåŒæ ·çš„äº‹æƒ…ã€‚

## è‡ªå®šä¹‰è®­ç»ƒå¾ªç¯ [[è‡ªå®šä¹‰è®­ç»ƒå¾ªç¯]]

ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å®Œæ•´çš„è®­ç»ƒå¾ªç¯ï¼Œè¿™æ ·ä½ å°±å¯ä»¥è½»æ¾åœ°è‡ªå®šä¹‰æ‰€éœ€çš„éƒ¨åˆ†ã€‚å®ƒçœ‹èµ·æ¥å¾ˆåƒ [ç¬¬ä¸‰ç« ](https://www.hubchat.top/course/chapter3/4) ä¸­çš„è®­ç»ƒå¾ªç¯ï¼Œåªæ˜¯è¯„ä¼°çš„è¿‡ç¨‹æœ‰æ‰€ä¸åŒã€‚ç”±äºæˆ‘ä»¬ä¸å†å— `Trainer` ç±»çš„é™åˆ¶ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨æ¨¡å‹è®­ç»ƒçš„è¿‡ç¨‹ä¸­å®šæœŸè¯„ä¼°æ¨¡å‹ã€‚

### ä¸ºè®­ç»ƒåšå‡†å¤‡ [[ä¸ºè®­ç»ƒåšå‡†å¤‡]]

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨æ•°æ®é›†æ„å»º `DataLoader` ã€‚æˆ‘ä»¬å°†è¿™äº›æ•°æ®é›†çš„æ ¼å¼è®¾ç½®ä¸º `"torch"` ï¼Œå¹¶åˆ é™¤æ¨¡å‹ä¸ä½¿ç”¨çš„éªŒè¯é›†çš„åˆ—ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Transformers æä¾›çš„ `default_data_collator` ä½œä¸º `collate_fn` ï¼Œå¹¶æ‰“ä¹±è®­ç»ƒé›†ï¼Œä½†ä¸æ‰“ä¹±éªŒè¯é›†ï¼š

```py
from torch.utils.data import DataLoader
from transformers import default_data_collator

train_dataset.set_format("torch")
validation_set = validation_dataset.remove_columns(["example_id", "offset_mapping"])
validation_set.set_format("torch")

train_dataloader = DataLoader(
    train_dataset,
    shuffle=True,
    collate_fn=default_data_collator,
    batch_size=8,
)
eval_dataloader = DataLoader(
    validation_set, collate_fn=default_data_collator, batch_size=8
)
```

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬é‡æ–°å®ä¾‹åŒ–æˆ‘ä»¬çš„æ¨¡å‹ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬ä¸æ˜¯ä»ä¸Šé¢çš„å¾®è°ƒç»§ç»­è®­ç»ƒï¼Œè€Œæ˜¯ä»åŸå§‹çš„ BERT é¢„è®­ç»ƒæ¨¡å‹é‡æ–°å¼€å§‹è®­ç»ƒï¼š

```py
model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)
```

ç„¶åï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªä¼˜åŒ–å™¨ã€‚é€šå¸¸æˆ‘ä»¬ä½¿ç”¨ç»å…¸çš„ `AdamW` ä¼˜åŒ–å™¨ï¼Œå®ƒä¸ Adam ç±»ä¼¼ï¼Œä¸è¿‡åœ¨æƒé‡è¡°å‡çš„æ–¹å¼ä¸Šæœ‰äº›ä¸åŒï¼š

```py
from torch.optim import AdamW

optimizer = AdamW(model.parameters(), lr=2e-5)
```

å½“æˆ‘ä»¬æ‹¥æœ‰äº†æ‰€æœ‰è¿™äº›å¯¹è±¡ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒä»¬å‘é€åˆ° `accelerator.prepare()` æ–¹æ³•ã€‚è¯·è®°ä½ï¼Œå¦‚æœä½ æƒ³åœ¨ Colab Notebook ä¸Šä½¿ç”¨ TPU è¿›è¡Œè®­ç»ƒï¼Œä½ éœ€è¦å°†æ‰€æœ‰è¿™äº›ä»£ç ç§»åˆ°ä¸€ä¸ªè®­ç»ƒå‡½æ•°ä¸­ï¼Œä¸è¦åœ¨ Colab Notebook çš„å•å…ƒæ ¼ä¸­ç›´æ¥å®ä¾‹åŒ– `Accelerator` å¯¹è±¡ã€‚è¿™æ˜¯å› ä¸ºåœ¨ TPU ç¯å¢ƒä¸‹ï¼Œç›´æ¥åœ¨å•å…ƒæ ¼ä¸­å®ä¾‹åŒ–å¯èƒ½ä¼šå¯¼è‡´èµ„æºåˆ†é…å’Œåˆå§‹åŒ–çš„é—®é¢˜ã€‚æ­¤å¤–æˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡å‘ `Accelerator` ä¼ é€’ `fp16=True` æ¥å¼ºåˆ¶ä½¿ç”¨æ··åˆç²¾åº¦è®­ç»ƒï¼ˆæˆ–è€…ï¼Œå¦‚æœä½ æƒ³è¦å°†ä»£ç ä½œä¸ºè„šæœ¬æ‰§è¡Œï¼Œåªéœ€ç¡®ä¿å¡«å†™æ­£ç¡®çš„ğŸ¤— Accelerate `config` ï¼‰ã€‚

```py
from accelerate import Accelerator

accelerator = Accelerator(fp16=True)
model, optimizer, train_dataloader, eval_dataloader = accelerator.prepare(
    model, optimizer, train_dataloader, eval_dataloader
)
```

ä»å‰é¢å‡ èŠ‚ä¸­ä½ åº”è¯¥çŸ¥é“ï¼Œæˆ‘ä»¬åªæœ‰åœ¨ `train_dataloader` é€šè¿‡ `accelerator.prepare()` æ–¹æ³•åæ‰èƒ½ä½¿ç”¨å…¶é•¿åº¦æ¥è®¡ç®—è®­ç»ƒæ­¥éª¤çš„æ•°é‡ã€‚æˆ‘ä»¬ä½¿ç”¨ä¸ä¹‹å‰ç« èŠ‚ç›¸åŒçš„çº¿æ€§å­¦ä¹ ç‡è°ƒåº¦ï¼š

```py
from transformers import get_scheduler

num_train_epochs = 3
num_update_steps_per_epoch = len(train_dataloader)
num_training_steps = num_train_epochs * num_update_steps_per_epoch

lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps,
)
```

è¦å°†æ¨¡å‹æ¨é€åˆ° Hubï¼Œæˆ‘ä»¬éœ€è¦åœ¨å·¥ä½œæ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ª `Repository` å¯¹è±¡ã€‚å¦‚æœä½ å°šæœªç™»å½• Hugging Face Hubï¼Œè¯·å…ˆç™»å½•ã€‚æˆ‘ä»¬å°†æ ¹æ®æˆ‘ä»¬ç»™æ¨¡å‹æŒ‡å®šçš„æ¨¡å‹ ID ç¡®å®šä»“åº“åç§°ï¼ˆå¯ä»¥æ ¹æ®è‡ªå·±çš„é€‰æ‹©æ›¿æ¢ `repo_name` ï¼›åªéœ€è¦åŒ…å«ä½ çš„ç”¨æˆ·åå³å¯ï¼Œç”¨æˆ·åå¯ä»¥ä½¿ç”¨ `get_full_repo_name()` å‡½æ•°å¯ä»¥è·å–ï¼‰ï¼š

```py
from huggingface_hub import Repository, get_full_repo_name

model_name = "bert-finetuned-squad-accelerate"
repo_name = get_full_repo_name(model_name)
repo_name
```

```python out
'sgugger/bert-finetuned-squad-accelerate'
```

ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å°†è¯¥å­˜å‚¨åº“å…‹éš†åˆ°æœ¬åœ°æ–‡ä»¶å¤¹ä¸­ã€‚å¦‚æœåœ¨è®¾å®šçš„ç›®å½•ä¸­å·²ç»å­˜åœ¨ä¸€ä¸ªåŒåçš„æ–‡ä»¶å¤¹ï¼Œé‚£ä¹ˆè¿™ä¸ªæœ¬åœ°æ–‡ä»¶å¤¹åº”è¯¥æ˜¯æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„ä»“åº“å…‹éš†åœ¨æœ¬åœ°çš„ç‰ˆæœ¬ï¼Œå¦åˆ™å®ƒä¼šæŠ¥é”™ï¼š

```py
output_dir = "bert-finetuned-squad-accelerate"
repo = Repository(output_dir, clone_from=repo_name)
```

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨ `repo.push_to_hub()` æ–¹æ³•ä¸Šä¼ ä¿å­˜åœ¨ `output_dir` ä¸­çš„æ‰€æœ‰å†…å®¹ã€‚è¿™å°†å¸®åŠ©æˆ‘ä»¬åœ¨æ¯ä¸ªæ—¶æœŸç»“æŸæ—¶ä¸Šä¼ ä¸­é—´æ¨¡å‹ã€‚

## è®­ç»ƒå¾ªç¯ [[è®­ç»ƒå¾ªç¯]]

ç°åœ¨ï¼Œæˆ‘ä»¬å‡†å¤‡ç¼–å†™å®Œæ•´çš„è®­ç»ƒå¾ªç¯ã€‚åœ¨å®šä¹‰ä¸€ä¸ªè¿›åº¦æ¡ä»¥è·Ÿè¸ªè®­ç»ƒè¿›åº¦ä¹‹åï¼Œå¾ªç¯åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼š

- è®­ç»ƒæœ¬èº«ï¼Œå³å¯¹ `train_dataloader` è¿›è¡Œè¿­ä»£ï¼Œæ¨¡å‹å‰å‘ä¼ æ’­ã€åå‘ä¼ æ’­å’Œä¼˜åŒ–å™¨æ›´æ–°ã€‚
- è¯„ä¼°ï¼Œæˆ‘ä»¬å°†éå†æ•´ä¸ªè¯„ä¼°æ•°æ®é›†ï¼ŒåŒæ—¶æ”¶é›† `start_logits` å’Œ `end_logits` ä¸­çš„æ‰€æœ‰å€¼ã€‚å®Œæˆè¯„ä¼°å¾ªç¯åï¼Œæˆ‘ä»¬ä¼šå°†æ‰€æœ‰ç»“æœæ±‡æ€»åˆ°ä¸€èµ·ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äº `Accelerator` å¯èƒ½ä¼šåœ¨æœ€åæ·»åŠ ä¸€äº›é¢å¤–çš„æ ·æœ¬ï¼Œä»¥ç¡®ä¿æ¯ä¸ªè¿›ç¨‹ä¸­çš„æ ·æœ¬æ•°é‡ç›¸åŒï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å¯¹è¿™äº›æ•°æ®è¿›è¡Œæˆªæ–­ï¼Œä»¥é˜²æ­¢å¤šä½™æ ·æœ¬å½±å“æœ€ç»ˆç»“æœã€‚

- ä¿å­˜å’Œä¸Šä¼ ï¼Œé¦–å…ˆä¿å­˜æ¨¡å‹å’Œ Tokenizerï¼Œç„¶åè°ƒç”¨ `repo.push_to_hub()` ã€‚ä¸ä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬ä½¿ç”¨ `blocking=False` å‚æ•°å‘Šè¯‰ğŸ¤— Hub åº“åœ¨å¼‚æ­¥è¿›ç¨‹ä¸­æ¨é€ã€‚è¿™æ ·ï¼Œè®­ç»ƒå°†ç»§ç»­è¿›è¡Œï¼Œè€Œè¿™ä¸ªï¼ˆéœ€è¦å¾ˆé•¿æ—¶é—´çš„ï¼‰ä¸Šä¼ æŒ‡ä»¤å°†åœ¨åå°å¼‚æ­¥æ‰§è¡Œã€‚

ä»¥ä¸‹è®­ç»ƒå¾ªç¯çš„å®Œæ•´ä»£ç ï¼š

```py
from tqdm.auto import tqdm
import torch

progress_bar = tqdm(range(num_training_steps))

for epoch in range(num_train_epochs):
    # è®­ç»ƒ
    model.train()
    for step, batch in enumerate(train_dataloader):
        outputs = model(**batch)
        loss = outputs.loss
        accelerator.backward(loss)

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)

    # è¯„ä¼°
    model.eval()
    start_logits = []
    end_logits = []
    accelerator.print("Evaluation!")
    for batch in tqdm(eval_dataloader):
        with torch.no_grad():
            outputs = model(**batch)

        start_logits.append(accelerator.gather(outputs.start_logits).cpu().numpy())
        end_logits.append(accelerator.gather(outputs.end_logits).cpu().numpy())

    start_logits = np.concatenate(start_logits)
    end_logits = np.concatenate(end_logits)
    start_logits = start_logits[: len(validation_dataset)]
    end_logits = end_logits[: len(validation_dataset)]

    metrics = compute_metrics(
        start_logits, end_logits, validation_dataset, raw_datasets["validation"]
    )
    print(f"epoch {epoch}:", metrics)

    # ä¿å­˜å’Œä¸Šä¼ 
    accelerator.wait_for_everyone()
    unwrapped_model = accelerator.unwrap_model(model)
    unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)
    if accelerator.is_main_process:
        tokenizer.save_pretrained(output_dir)
        repo.push_to_hub(
            commit_message=f"Training in progress epoch {epoch}", blocking=False
        )
```

å¦‚æœè¿™æ˜¯ä½ ç¬¬ä¸€æ¬¡çœ‹åˆ°ä½¿ç”¨ğŸ¤— Accelerate ä¿å­˜çš„æ¨¡å‹ï¼Œè¯·èŠ±ç‚¹æ—¶é—´äº†è§£ä¸€ä¸‹ä¸ä¹‹ç›¸å…³çš„ä¸‰è¡Œä»£ç 

```py
accelerator.wait_for_everyone()
unwrapped_model = accelerator.unwrap_model(model)
unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)
```

ç¬¬ä¸€è¡Œå¾ˆå¥½ç†è§£ï¼šå®ƒå‘Šè¯‰æ‰€æœ‰è¿›ç¨‹åœ¨ç»§ç»­ä¹‹å‰ç­‰å¾…æ‰€æœ‰è¿›ç¨‹éƒ½åˆ°è¾¾è¯¥é˜¶æ®µã€‚è¿™æ˜¯ä¸ºäº†ç¡®ä¿æˆ‘ä»¬åœ¨ä¿å­˜ä¹‹å‰ï¼Œåœ¨æ¯ä¸ªè¿›ç¨‹ä¸­éƒ½æœ‰ç›¸åŒçš„æ¨¡å‹ã€‚ç„¶åï¼Œæˆ‘ä»¬è·å– `unwrapped_model` ï¼Œå®ƒæ˜¯æˆ‘ä»¬å®šä¹‰çš„åŸºæœ¬æ¨¡å‹ã€‚ `accelerator.prepare()` æ–¹æ³•ä¼šæ›´æ”¹æ¨¡å‹æ¥é€‚åº”åˆ†å¸ƒå¼è®­ç»ƒï¼Œå› æ­¤å®ƒä¸å†å…·æœ‰ `save_pretrained()` æ–¹æ³•ï¼›ä½¿ç”¨ `accelerator.unwrap_model()` æ–¹æ³•å¯ä»¥æ’¤æ¶ˆè¿™ä¸ªæ›´æ”¹ã€‚æœ€åï¼Œæˆ‘ä»¬è°ƒç”¨ `save_pretrained()` ï¼Œå‘Šè¯‰è¯¥æ–¹æ³•åº”è¯¥ä½¿ç”¨ `accelerator.save()` ä¿å­˜æ¨¡å‹ è€Œä¸æ˜¯ `torch.save()` ã€‚

å®Œæˆåï¼Œä½ åº”è¯¥æ‹¥æœ‰ä¸€ä¸ªäº§ç”Ÿä¸ä½¿ç”¨ `Trainer` è®­ç»ƒçš„æ¨¡å‹éå¸¸ç›¸ä¼¼çš„ç»“æœçš„æ¨¡å‹ã€‚ä½ å¯ä»¥åœ¨ [`huggingface-course/bert-finetuned-squad-accelerate`](https://huggingface.co/huggingface-course/bert-finetuned-squad-accelerate) æŸ¥çœ‹æˆ‘ä»¬ä½¿ç”¨æ­¤ä»£ç è®­ç»ƒçš„æ¨¡å‹ã€‚å¦‚æœä½ æƒ³æµ‹è¯•å¯¹è®­ç»ƒå¾ªç¯è¿›è¡Œçš„ä»»ä½•è°ƒæ•´ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡ç¼–è¾‘ä¸Šé¢æ˜¾ç¤ºçš„ä»£ç æ¥å®ç°ï¼

{/if}

## ä½¿ç”¨å¾®è°ƒæ¨¡å‹ [[ä½¿ç”¨å¾®è°ƒæ¨¡å‹]]

æˆ‘ä»¬å·²ç»å‘ä½ å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨åœ¨æ¨¡å‹ä¸­å¿ƒä¸Šè¿›è¡Œå¾®è°ƒçš„æ¨¡å‹ï¼Œå¹¶ä½¿ç”¨æ¨ç†å°éƒ¨ä»¶è¿›è¡Œæµ‹è¯•ã€‚è¦åœ¨æœ¬åœ°ä½¿ç”¨ `pipeline` æ¥ä½¿ç”¨å¾®è°ƒçš„æ¨¡å‹ï¼Œä½ åªéœ€æŒ‡å®šæ¨¡å‹æ ‡è¯†ç¬¦ï¼š

```py
from transformers import pipeline

# å°†å…¶æ›¿æ¢ä¸ºä½ è‡ªå·±çš„ checkpoint
model_checkpoint = "huggingface-course/bert-finetuned-squad"
question_answerer = pipeline("question-answering", model=model_checkpoint)

context = """
ğŸ¤— Transformers is backed by the three most popular deep learning libraries â€” Jax, PyTorch and TensorFlow â€” with a seamless integration
between them. It's straightforward to train your models with one before loading them for inference with the other.
"""
question = "Which deep learning libraries back ğŸ¤— Transformers?"
question_answerer(question=question, context=context)
```

```python out
{'score': 0.9979003071784973,
 'start': 78,
 'end': 105,
 'answer': 'Jax, PyTorch and TensorFlow'}
```

å¾ˆæ£’ï¼æˆ‘ä»¬çš„æ¨¡å‹ä¸ pipeline çš„é»˜è®¤æ¨¡å‹ä¸€æ ·æœ‰æ•ˆï¼
