<FrameworkSwitchCourse {fw} />

<!-- DISABLE-FRONTMATTER-SECTIONS -->

# 章末小测验 [[章末小测验]]

<CourseFloatingBanner
    chapter={7}
    classNames="absolute z-10 right-0 top-0"
/>

让我们测试一下您在本章中学到了什么！

### 1.你能利用Grado做什么？
<Question
	choices={[
        {
			text: "为您的机器学习模型创建一个演示",
			explain: "通过几行 Python 代码，您可以使用我们的预构建组件库为 ML 模型生成一个演示。",
			correct: true
		},
		{
			text: "与他人分享你的机器学习模型",
			explain: "在启动方法中使用 <code> share = True </code> 参数，可以生成一个共享链接发送给任何人。",
            correct: true
		},
		{
			text: "调试模型",
			explain: "Grado演示的一个优点是能够用真实数据测试模型，您可以实时更改并观察模型的预测变化，从而帮助您调试模型。",
			correct: true
		},
		{
			text: "训练你的模型",
			explain: "在你的模型被训练之后，Grado 被设计用来进行模型推理。",
		}
	]}
/>

### 2.Grado只在 PyTorch 模型上工作
<Question
	choices={[
        {
			text: "没错",
			explain: "Grdio 可以处理 PyTorch 模型，但除此之外也可以处理任何类型的机器学习模型！"
        },
        {
			text: "不正确",
			explain: "Grdio 是不依赖模型的，这意味着您可以为任何类型的机器学习模型创建演示。",
			correct: true
        }
	]}
/>

### 3.你可以在哪里发布一个 GRadio 演示？
<Question
	choices={[
        {
			text: "标准的 python IDEs",
			explain: "对于您最喜欢的 IDE，Grdio 工作得非常好。",
            correct: true
        },
        {
			text: "Google Colab 笔记本",
			explain: "你可以在你的 Google colab 笔记本上创建并启动一个演示。",
			correct: true
        },
        {
			text: "Jupyter笔记本",
			explain: "很好的选择 —— 您可以在您的Jupyter notebook创建并启动一个演示。",
			correct: true
        }
	]}
/>

### 4.Gdio 主要是为 NLP 模型设计的
<Question
	choices={[
        {
			text: "没错",
			explain: "GRadio 可以处理几乎所有的数据类型，而不仅仅是 NLP。"
        },
        {
			text: "假的",
			explain: "Grado 为开发人员提供了一个库，其中包含几乎所有数据类型的预构建组件。",
            correct: true
        }
	]}
/>

### 5.下列哪些特性是由 Grado 支持的？
<Question
	choices={[
        {
			text: "多输入多输出",
			explain: "多输入多输出是可能的。您所需要做的就是将输入和输出的列表传递给它们相应的参数",
            correct: true
        },
        {
			text: "数据持久性状态",
			explain: "可以在界面中添加状态。",
			correct: true
        },
        {
			text: "用户名和密码身份验证",
			explain: "将用户名/密码元组的列表传递给启动方法，以添加身份验证。",
			correct: true
        },
        {
			text: "自动分析谁在使用您的Grado演示",
			explain: "再试一次 —— Grado 不提供给开发人员关于谁使用他们的演示的分析。"
        },
        {
			text: "从“HuggingFace”的模型中心或“HuggingFace” Space加载模型",
			explain: "绝对可以 —— 使用 <code> gr. Interface.load () </code> 方法加载任何 Hugging Face 模型",
			correct: true
        }
	]}
/>

### 6.下列哪一种是从 Hub 或 Spaces 加载 Huggging Face 模型的有效方法？
<Question
	choices={[
        {
			text: "gr.Interface.load('huggingface/{user}/{model_name}')",
			explain: "这是从 Hub 加载 Hugging Face 模型的有效方法",
            correct: true
        },
        {
			text: "gr.Interface.load('model/{user}/{model_name}')",
			explain: "这是从 Hub 加载 Hugging Face 模型的有效方法",
			correct: true
        },
        {
			text: "gr.Interface.load('demos/{user}/{model_name}')",
			explain: "再试一次——你不能使用'demos'前缀来加载模型。"
        },
        {
			text: "gr.Interface.load('spaces/{user}/{model_name}')",
			explain: "这是从 Space 加载 Hugging Face 模型的有效方法",
			correct: true
        }
	]}
/>

### 7.创建您的 Gradio 接口时，您必须添加以下步骤：
<Question
	choices={[
        {
			text: "向预测函数中传入一个额外的参数，该参数表示接口的状态。",
			explain: "需要一个额外的参数来存储接口的历史记录或状态。",
            correct: true
        },
        {
			text: "在预测函数的末尾，将状态的更新值作为额外的返回值返回。",
			explain: "此历史记录或状态值需要由函数返回。",
            correct: true
        },
        {
			text: "在创建接口时添加状态输入和状态输出组件",
			explain: "Grado 提供了一个状态输入和输出组件来持久存储数据。",
            correct: true
        }
	]}
/>

### 8.Gradio 库包括以下哪些组件？
<Question
	choices={[
        {
			text: "文本框。",
			explain: "是的，可以使用 Textbox 组件创建文本框。",
            correct: true
        },
        {
			text: "图表。",
			explain: "目前没有图形组件。",
        },
        {
			text: "图像。",
			explain: "是的，您可以使用 Image 组件创建一个图像上传小部件。",
            correct: true
        },
        {
			text: "音频。",
			explain: "是的，您可以使用 Audio 组件创建一个音频上传小部件。",
            correct: true
        },
	]}
/>

### 9.Gradio允许你做什么？
<Question
	choices={[
        {
			text: "将多个演示合并到一个 Web 应用程序中",
			explain: "您可以使用`with gradio.Tabs ():`来为多个演示添加选项卡",
			correct: true
        },
        {
			text: "将单击/更改/等事件触发器分配给`Blocks`组件",
			explain: "在分配事件时，传入三个参数: fn: 应该调用的函数、输入: 组件的输入(list)和输出: 应该调用组件的输出(list)。",
			correct: true
        },
        {
			text: "自动确定哪些`Blocks`组件应该是交互的还是静态的",
			explain: "根据您定义的事件触发器，`Blocks`自动计算出组件是否应该接受用户输入。",
			correct: true
        },
		 {
			text: "创建多步演示; 这意味着允许您重用一个组件的输出作为下一个组件的输入",
			explain: "您可以使用组件作为一个事件触发器的输入，但作为另一个事件触发器的输出。",
            correct: true
        },
	]}
/>

### 10.你可以共享一个`Blocks`演示的公共链接，并创建一个`Blocks`的演示在HuggingFace空间。
<Question
	choices={[
        {
			text: "没错",
			explain: "就像`Interface`一样，所有的共享和托管功能对于`Blocks`演示都是一样的！",
			correct: true
        },
        {
			text: "不正确",
			explain: "就像`Interface`一样，所有的共享和托管功能对于`Blocks`演示都是一样的！",
			correct: false
        }
	]}
/>