<!-- DISABLE-FRONTMATTER-SECTIONS -->

# Đố vui cuối chương

Cùng kiểm tra xem bạn đã học được những gì trong chương này!

### 1. Khi nào ta nên huấn luyện 1 tokenizer mới?

<Question
	choices={[
		{
			text: "Khi tập dữ liệu của bạn tương tự với tập dữ liệu được sử dụng bởi một mô hình huấn luyện trước hiện có và bạn muốn huấn luyện trước một mô hình mới",
			explain: "Trong trường hợp này, để tiết kiệm thời gian và tính toán tài nguyên, lựa chọn tốt hơn sẽ là sử dụng cùng một trình tokenize như mô hình được huấn luyện trước và thay vào đó tinh chỉnh mô hình đó."
		},
		{
			text: "Khi tập dữ liệu của bạn tương tự với tập dữ liệu được sử dụng bởi một mô hình huấn luyện trước hiện có và bạn muốn tinh chỉnh một mô hình mới bằng cách sử dụng mô hình huấn luyện trước này",
			explain: "Để tinh chỉnh một mô hình từ một mô hình đã được huấn luyện trước, bạn nên luôn sử dụng cùng một trình tokenizer."
		},
		{
			text: "Khi tập dữ liệu của bạn khác với tập dữ liệu được sử dụng bởi mô hình huấn luyện trước hiện có và bạn muốn huấn luyện trước một mô hình mới",
			explain: "Đúng! Trong trường hợp này, không có lợi ích gì khi sử dụng cùng một tokenizer.",
            correct: true
		},
        {
			text: "Khi tập dữ liệu của bạn khác với tập dữ liệu được sử dụng bởi một mô hình huấn luyện trước hiện có, nhưng bạn muốn tinh chỉnh một mô hình mới bằng cách sử dụng mô hình huấn luyện trước này",
			explain: "Để tinh chỉnh một mô hình từ một mô hình đã được huấn luyện trước, bạn nên luôn sử dụng cùng một trình tokenizer."
		}
	]}
/>

### 2. Ưu điểm của việc sử dụng trình tạo danh sách văn bản so với danh sách các danh sách văn bản khi sử dụng `train_new_from_iterator()` là gì?

<Question
	choices={[
		{
			text: "Đó là kiểu duy nhất mà phương thức <code>train_new_from_iterator()</code> chấp nhận.",
			explain: "Danh sách các danh sách văn bản là một loại trình tạo danh sách văn bản cụ thể, vì vậy phương pháp cũng sẽ chấp nhận điều này. Hãy thử lại!"
		},
		{
			text: "Bạn sẽ tránh tải toàn bộ tập dữ liệu vào bộ nhớ cùng một lúc.",
			explain: "Đúng vậy! Mỗi loạt văn bản sẽ được giải phóng khỏi bộ nhớ khi bạn lặp lại và phần thu được sẽ đặc biệt rõ ràng nếu bạn sử dụng 🤗 Datasets để lưu trữ văn bản của mình.",
			correct: true
		},
		{
			text: "Điều này sẽ cho phép thư viện 🤗 Tokenizers sử dụng quá trình xử lý đa luồng.",
			explain: "Không, với cách nào xử lý đa luồng cũng sẽ được sử dụng."
		},
        {
			text: "Tokenizer mà bạn huấn luyện sẽ tạo ra các văn bản tốt hơn.",
			explain: "Tokenize không tạo ra văn bản -- bạn có đang nhầm lẫn với mô hình ngôn ngữ không?"
		}
	]}
/>

### 3. Ưu điểm của tokenize "nhanh" là gì?

<Question
	choices={[
		{
			text: "Nó có thể xử lý dữ liệu đầu vào nhanh hơn tokenizer chậm khi bạn gộp nhiều đầu vào với nhau.",
			explain: "Đúng! Nhờ tính năng song song được triển khai trong Rust, nó sẽ nhanh hơn trên các lô đầu vào. Bạn có thể nghĩ đến lợi ích nào khác không?",
			correct: true
		},
		{
			text: "Tokenizer nhanh luôn tokenize nhanh hơn các trình chậm khác.",
			explain: "Một tokenizer nhanh có thể chậm hơn khi bạn chỉ nhận một hoặc một vài đoạn văn bản, vì nó không thể sử dụng song song."
		},
		{
			text: "Nó có thể áp dụng đệm và cắt bớt.",
			explain: "Đúng, nhưng tokenize chậm cũng làm được điều đó."
		},
        {
			text: "Nó có một số tính năng bổ sung cho phép bạn ánh xạ các tokenize với khoảng văn bản đã tạo ra chúng.",
			explain: "Thật vậy - chúng được gọi là ánh xạ offset. Tuy nhiên, đó không phải là lợi thế duy nhất.",
			correct: true
		}
	]}
/>

### 4. Pipeline `token-classification`  xử lý các thực thể trải dài trên nhiều token như thế nào?

<Question
	choices={[
		{
			text: "Các thực thể có cùng nhãn được hợp nhất thành một thực thể.",
			explain: "Đó đơn giản hóa mọi thứ một chút rồi. Hãy thử lại!"
		},
		{
			text: "Có một nhãn cho sự bắt đầu của một thực thể và một nhãn cho sự tiếp tục của một thực thể.",
			explain: "Chính xác!",
			correct: true
		},
		{
			text: "Trong một từ nhất định, miễn là token đầu tiên có nhãn của thực thể, toàn bộ từ được coi là được gắn nhãn với thực thể đó.",
			explain: "Đó là một chiến lược để xử lý các thực thể. Còn những câu trả lời nào khác ở đây áp dụng không?",
			correct: true
		},
        {
			text: "Khi token có nhãn của một thực thể nhất định, bất kỳ token nào khác phía sau có cùng nhãn được coi là một phần của cùng một thực thể, trừ khi nó được gắn nhãn là phần bắt đầu của một thực thể mới.",
			explain: "Đó là cách phổ biến nhất để nhóm các thực thể lại với nhau - tuy nhiên, đó không phải là câu trả lời đúng duy nhất.",
			correct: true
		}
	]}
/>

### 5. Pipeline `question-answering` xử lý ngữ cảnh dài như thế nào?

<Question
	choices={[
		{
			text: "Nó không thực sự xử lý, vì nó cắt đi những ngữ cảnh dài quá độ dài tối đa được chấp nhận của mô hình.",
			explain: "Có một thủ thuật bạn có thể sử dụng để xử lý các ngữ cảnh dài. Bạn có nhớ nó là gì không?"
		},
		{
			text: "Nó chia ngữ cảnh thành nhiều phần và trung bình kết quả thu được từ các phần.",
			explain: "Không, nó khá vô nghĩa khi lấy trung bình các kết quả, do có một số phần của ngữ cảnh không chứa câu trả lời."
		},
		{
			text: "Nó chia ngữ cảnh thành nhiều phần (có giao thoa) và tìm điểm cao nhất cho câu trả lời mỗi phần.",
			explain: "Đó là câu trả lời chính xác!",
			correct: true
		},
        {
			text: "Nó chia ngữ cảnh thành nhiều phần (không giao thoa, để tăng hiệu quả) và tìm điểm cao nhất cho câu trả lời mỗi phần.",
			explain: "Không, nó bao gồm một số trùng lặp giữa các phần để tránh tình huống câu trả lời sẽ bị chia thành hai phần."
		}
	]}
/>

### 6. Chuẩn hoá là gì?

<Question
	choices={[
		{
			text: "Đó là bất kỳ thao tác dọn dẹp nào mà tokenizer thực hiện trên các văn bản trong giai đoạn đầu.",
			explain: "Đúng vậy - ví dụ: nó có thể liên quan đến việc xóa dấu hoặc khoảng trắng, hoặc viết thường các đầu vào.",
			correct: true
		},
		{
			text: "Đó là kĩ thuật gia tăng dữ liệu bao gồm khả năng tạo ta các văn bản chuẩn hơn bằng cách loại bỏ từ hiếm.",
			explain: "Điều đó không chính xác! Hãy thử lại."
		},
		{
			text: "Đó là bước hậu xử lý cuối cùng khi tokenizer thêm các token đặc biệt.",
			explain: "Bước mô tả trên chỉ đơn giản là hậu xử lý."
		},
        {
			text: "Đó là khi biểu diễn từ được tạo ra với trung bình bằng 0 và độ lệch chuẩn bằng 1, được tính bằng cách trừ trung bình và chia cho độ lệch chuẩn.",
			explain: "Quá trình này thường được gọi là chuẩn hoá khi áp dụng lên các giá trị pixel trong thị giác máy tính, nhưng nó không phải ý nghĩa của chuẩn hoá trong NLP."
		}
	]}
/>

### 7. Pre-tokenization cho một tokenizer từ phụ là sao?

<Question
	choices={[
		{
			text: "Đó là bước trước khi tokenize, áp dụng phương pháp tăng dữ liệu (như tạo các lớp che ngẫu nhiên).",
			explain: "Không, bước này chỉ là một phần của tiền xử lý thôi."
		},
		{
			text: "Đó là bước trước khi tokenize, áp dụng các bước dọn dẹp cho văn bản.",
			explain: "Không, bước này chỉ là bước chuẩn hoá thôi."
		},
		{
			text: "Đó là bước trước khi tokenize, áo dụng mô hình để chia đầu vào thành các từ.",
			explain: "Chính xác!",
			correct: true
		},
        {
			text: "Đó là bước trước khi tokenize, áp dụng mô hình để chia đầu vào thành các token.",
			explain: "Không, chia đầu vào thành các token là nhiệm vụ của mô hình tokenize."
		}
	]}
/>

### 8. Chọn các câu áp dụng mô hình BPE để tokenize?

<Question
	choices={[
		{
			text: "BPE là một thuật toán tokenize từ phụ bắt đầu với một từ vựng nhỏ và học các quy tắc hợp nhất.",
			explain: "Đây quả thực là câu trả lời!",
			correct: true
		},
		{
			text: "BPE là một thuật tokenize từ phụ bắt đầu với một lượng từ vựng lớn và loại bỏ dần các token khỏi nó.",
			explain: "Không, đây là hướng tiếp cận của thuật toán tokenize khác."
		},
		{
			text: "BPE tokenizer học các quy tắc hợp nhất bằng cách gộp các cặp token có tần suất cao nhất.",
			explain: "Chính xác!",
			correct: true
		},
		{
			text: "BPE tokenizer học các quy tắc hợp nhất bằng cách gộp các cặp token tối đa hoá điểm của các cặp tần suất cao so với các phần cá nhân có tần suất ít hơn.",
			explain: "Không, đây là chiến lược của thuật toán tokenie khác."
		},
		{
			text: "BPE tokenize các từ thành các từ phụ bằng cách chia chúng thành các ký tự và áp dụng quy tắc hợp nhất.",
			explain: "Chính xác!",
			correct: true
		},
		{
			text: "BPE tokenize các từ thành các từ phụ bằng cách tìm từ phụ dài nhất bắt đầu từ phần đầu có trong từ vựng, sau đó lặp lại quy trình cho phần còn lại của văn bản.",
			explain: "Không, đây là cách phương pháp tokenize khác làm."
		},
	]}
/>

### 9. Chọn các câu áp dụng mô hình WordPiece để tokenize?

<Question
	choices={[
		{
			text: "WordPiece là một thuật toán tokenize từ phụ bắt đầu với một từ vựng nhỏ và học các quy tắc hợp nhất.",
			explain: "Đây quả thực là câu trả lời!",
			correct: true
		},
		{
			text: "WordPiece là một thuật tokenize từ phụ bắt đầu với một lượng từ vựng lớn và loại bỏ dần các token khỏi nó.",
			explain: "Không, đây là hướng tiếp cận của thuật toán tokenize khác."
		},
		{
			text: "WordPiece tokenizer học các quy tắc hợp nhất bằng cách gộp các cặp token có tần suất cao nhất.",
			explain: "Không, đây là chiến lược của thuật toán tokenie khác."
		},
		{
			text: "WordPiece tokenizer học các quy tắc hợp nhất bằng cách gộp các cặp token tối đa hoá điểm của các cặp tần suất cao với các token cá nhân của nó có tần suất ít hơn.",
			explain: "Chính xác!",
			correct: true
		},
		{
			text: "WordPiece tokenize từ thành các từ phụ bằng cách tìm ra những phân đoạn có khả năng tách thành token nhất dựa theo mô hình.",
			explain:  "Không, đây là cách phương pháp tokenize khác làm."
		},
		{
			text: "WordPiece tokenize các từ thành các từ phụ bằng cách tìm từ phụ dài nhất bắt đầu từ phần đầu có trong từ vựng, sau đó lặp lại quy trình cho phần còn lại của văn bản.",
			explain: "Đúng, đây chính là cách WordPiece xử lý mã hoá.",
			correct: true
		},
	]}
/>

### 10. Chọn các câu áp dụng mô hình Unigram để tokenize?

<Question
	choices={[
		{
			text: "Unigram là một thuật toán tokenize từ phụ bắt đầu với một từ vựng nhỏ và học các quy tắc hợp nhất.",
			explain: "Không, đây là chiến lược của thuật toán tokenie khác."
		},
		{
			text: "Unigram là một thuật tokenize từ phụ bắt đầu với một lượng từ vựng lớn và loại bỏ dần các token khỏi nó.",
			explain: "Chính xác!",
			correct: true
		},
		{
			text: "Unigram điều chỉnh vốn từ vựng của nó bằng cách giảm thiểu sự mất mát được tính trên toàn bộ kho ngữ liệu.",
			explain: "Chính xác!",
			correct: true
		},
		{
			text: "Unigram điều chỉnh vốn từ vựng của nó bằng cách chỉ giữ lại những từ phụ hay xuất hiện.",
			explain:  "Không hính xác!",
		},
		{
			text: "Unigram tokenize từ thành các từ phụ bằng cách tìm ra những phân đoạn có khả năng tách thành token nhất dựa theo mô hình.",
			explain:  "Chính xác!",
			correct: true
		},
		{
			text: "Unigram tokenizes từ thành các từ phụ bằng cách tách từ đó thành kí tự rồi áp dụng quy tắc hợp nhất.",
			explain: "Không, đây là chiến lược của thuật toán tokenie khác."
		},
	]}
/>
