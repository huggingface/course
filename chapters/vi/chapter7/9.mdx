<FrameworkSwitchCourse {fw} />

<!-- DISABLE-FRONTMATTER-SECTIONS -->

# Đố vui cuối chương

Cùng kiểm tra xem bạn đã học được những gì trong chương này!

### 1. Tác vụ nào sau đây có thể được coi là vấn đề phân loại token?

<Question
	choices={[
		{
			text: "Tìm các thành phần ngữ pháp trong một câu.",
			explain: "Đúng! Sau đó, chúng tôi có thể gắn nhãn mỗi từ là danh từ, động từ, v.v.",
			correct: true
		},
		{
			text: "Tìm xem một câu có đúng ngữ pháp hay không.",
			explain: "Không, đây là một bài toán phân loại chuỗi."
		},
		{
			text: "Tìm thực thể người được đề cập trong một câu.",
			explain: "Đúng! Chúng ta có thể gắn nhãn từng từ có phải là thực thể người không.",
            correct: true
		},
        {
			text: "Tìm đoạn từ trong một câu trả lời cho một câu hỏi.",
			explain: "Không, đó sẽ là một vấn đề hỏi đáp."
		}
	]}
/>

### 2. Phần tiền xử lý để phân loại token khác với các pipeline tiền xử lý khác ở điểm nào?

<Question
	choices={[
		{
			text: "Không cần phải làm gì cả; các văn bản đã được tokenize",
			explain: "Các văn bản thực sự được cung cấp dưới dạng các từ riêng biệt, nhưng chúng ta vẫn cần áp dụng mô hình tokenize từ phụ."
		},
		{
			text: "Các văn bản được cung cấp dưới dạng từ, vì vậy chúng ta chỉ cần áp dụng tokenize từ phụ.",
			explain: "Chính xác! Điều này khác với quy trình tiền xử lý thông thường, ở đó chúng ta cần áp dụng quy trình tokenize đầy đủ. Bạn có thể nghĩ xem còn sự khác biệt nào khác không?",
			correct: true
		},
		{
			text: "Ta sử dụng <code>-100</code> để đánh nhãn các token đặc biệt.",
			explain: "Điều đó không dành riêng cho việc phân loại token -- ta luôn sử dụng <code>-100</code> như nhãn của token ta muốn bỏ quả trong hàm mất mát."
		},
		{
			text: "Chúng ta cần đảm bảo cắt bớt hoặc đệm các nhãn có cùng kích thước với các đầu vào khi áp dụng phép cắt bớt/đệm.",
			explain: "Thật vậy! Tuy nhiên đó không phải là sự khác biệt duy nhất.",
			correct: true
		}
	]}
/>

### 3. Vấn đề gì phát sinh khi ta tokenize các từ trong bài toán phân loại token và muốn đánh nhãn token?

<Question
	choices={[
		{
			text: "Trình tokenizer thêm các kí tự token đặc biệt và ta không có nhãn cho chúng.",
			explain: "Ta đãnh nhãn <code>-100</code> cho chúng để chúng bị bỏ qua khi tính sự mất mát."
		},
		{
			text: "Mỗi từ có thể tạo ra nhiều token, nên đến cuối ta sẽ có nhiều token hơn số nhãn.",
			explain: "Đó là vấn đề chính và chúng ta cần phải căn chỉnh các nhãn gốc với các token.",
			correct: true
		},
		{
			text: "Các token được thêm không có nhãn, nên không có vấn đề gì.",
			explain: "Không chính xác; ta cần số nhãn tương ứng số token nếu không mô hình sẽ báo lỗi."
		}
	]}
/>

### 4. "Thích ứng chuyên môn" là gì?

<Question
	choices={[
		{
			text: "Đó là khi chúng ta chạy một mô hình trên tập dữ liệu và nhận các dự đoán cho từng mẫu trong tập dữ liệu đó.",
			explain: "Không, đây chỉ là chạy quá trình luận suy."
		},
		{
			text: "Đó là khi chúng ta huấn luyện một mô hình trên tập dữ liệu.",
			explain: "Không, đây là huấn luyện một mô hình; không có sự thích nghi ở đây."
		},
		{
			text: "Đó là khi chúng ta tinh chỉnh một mô hình được huấn luyện trước trên một tập dữ liệu mới và nó đưa ra các dự đoán phù hợp hơn với tập dữ liệu đó",
			explain: "Đúng! Mô hình đã điều chỉnh kiến ​​thức của nó để phù hợp với tập dữ liệu mới.",
            correct: true
		},
        {
			text: "Đó là khi chúng ta thêm các mẫu bị phân loại sai vào tập dữ liệu để làm cho mô hình mạnh mẽ hơn.",
			explain: "Đó chắc chắn là điều bạn nên làm nếu huấn luyện lại mô hình của mình thường xuyên, nhưng đó không phải là thích ứng chuyên môn."
		}
	]}
/>

### 5. Các nhãn trong bài toán mô hình ngôn ngữ bị ẩn đi là gì?

<Question
	choices={[
		{
			text: "Một số token đầu vào bị che ngẫu nhiên và nhãn là các token đầu vào ban đầu.",
			explain: "Chính nó!",
            correct: true
		},
		{
			text: "Một số token đầu vào bị che ngẫu nhiên và nhãn là các token đầu vào ban đầu, được dịch sang bên trái.",
			explain: "Không, dịch các nhãn sang bên trái tương ứng với dự đoán từ tiếp theo hay mô hình ngôn ngữ nhân quả."
		},
		{
			text: "Một số token đầu vào bị che ngẫu nhiên và nhãn là các câu phủ định hay khẳng định.",
			explain: "Đó là vấn đề phân loại chuỗi với tăng cường dữ liệu, không phải mô hình ngôn ngữ bị che đi."
		},
        {
			text: "Một số token trong hai câu đầu vào bị che đi ngẫu nhiên, và nhãn là hai câu đó có giống nhau hay không.",
			explain: "Đó là vấn đề phân loại chuỗi với tăng cường dữ liệu, không phải mô hình ngôn ngữ bị che đi."
		}
	]}
/>

### 6. Tác vụ nào sau đây có thể được coi là bài toán chuỗi sang chuỗi?

<Question
	choices={[
		{
			text: "Viết đánh giá ngắn về tài liệu dài",
			explain: "Đúng, đó là một bài toán tóm tắt. Hãy thử một câu trả lời khác!",
            correct: true
		},
		{
			text: "Trả lời câu hỏi về một tài liệu",
			explain: "Đây có thể được coi là một bài toán chuỗi sang chuỗi. Tuy nhiên, đây không phải là câu trả lời đúng duy nhất.",
            correct: true
		},
		{
			text: "Dịch một văn bản bằng tiếng Trung sang tiếng Anh",
			explain: "Đó chắc chắn là bài toán chuỗi sang chuỗi. Bạn có thể tìm thấy đáp án nào nữa không?",
            correct: true
		},
        {
			text: "Sửa các tin nhắn do cháu trai/ bạn tôi gửi để chúng được viết bằng tiếng Anh chuẩn",
			explain: "Đó là một dạng dịch máy, nên chắc chắn là bài toán chuỗi sang chuỗi. Tuy nhiên, đó không phải là đáp án đúng duy nhất!",
			correct: true
		}
	]}
/>

### 7. Đây là phuwong pháp phù hợp để tiền xử lý dữ liệu cho bài toán chuỗi sang chuỗi?

<Question
	choices={[
		{
			text: "Đầu vào và nhãn phải được gửi cùng nhau tới tokenizer qua <code>inputs=...</code> và <code>targets=...</code>.",
			explain: "Đây có thể là một API mà chúng tôi sẽ thêm vào trong tương lai, nhưng điều đó không khả thi ở thời điểm hiện tại."
		},
		{
			text: "Đầu vào và nhãn đều phải được tiền xử lý, trong hai lệch gọi riêng biệt tới tokenizer.",
			explain: "Điều đó đúng, nhưng chưa đủ. Bạn cần phải làm gì đó nữa để đảm bảo trình tokenizer xử lý đúng cả hai."
		},
		{
			text: "Như thường lệ, chúng ta chỉ phhải tokenize đầu vào.",
			explain: "Không phải với bài toán phân loại chuỗi; nhãn cũng là văn bản nên ta cần chuyển sang dạng số!"
		},
        {
			text: "Đầu vào phải đước gửi tới trình tokenizer, và nhãn cũng vậy, nhưng theo trình quản lý ngữ cảnh đặc biệt.",
			explain: "Đúng vậy, tokenizer cần xử lý nhãn dựa trên trình quản lý ngữ cảnh.",
			correct: true
		}
	]}
/>

{#if fw === 'pt'}

### 8. Vì sao lại có lớp con `Trainer` cho các bài toán chuỗi sang chuỗi?

<Question
	choices={[
		{
			text: "Vì các vấn đề chuỗi sang chuỗi sử dụng một hàm mất mát tuỳ chỉnh để bỏ qua tập hợp nhãn <code>-100</code>",
			explain: "Đây không phải là tuỳ chỉnh mất mát, mà là cách sự mất mát vẫn luôn được tính toán."
		},
		{
			text: "Vì các vấn đề chuỗi sang chuỗi cần một vòng đánh giá đặc biệt",
			explain: "Chính xác. Các dự đoán mô hình chuỗi sang chuỗi thường được chạy sử dụng phương thức <code>generate()</code>.",
			correct: true
		},
		{
			text: "Bởi vì nhãn là văn bản trong bài toán chuỗi sang chuỗi",
			explain: "<code>Trainer</code> không thực sự quan tâm vì chúng đã được tiền xử lý trước đó."
		},
        {
			text: "Vì ta sử dụng hai mô hình trong bài toán chuỗi sang chuỗi",
			explain: "Chúng ta sử dụng hai mô hình cùng một cách, một trình mã hoá và một trình giải mã, nhưng ta sẽ nhóm chúng lại trong một mô hình."
		}
	]}
/>

{:else}

### 9. Vì sao không cần thiết chỉ định hàm mất mát khi gọi `compile()` trong mô hình Transformer?

<Question
	choices={[
		{
			text: "Vì các mô hình Transformer models được huấn luyện phi giám sát",
			explain: "Không hẳn -- kể cả học phi giám sát cùng cần hàm mất mát!"
		},
		{
			text: "Vì mất mát bên trong của đầu ra được sử dụng theo mặc định",
			explain: "Chính xác!",
			correct: true
		},
		{
			text: "Vì thay vào đó chúng ta tính các thước đo sau khi huấn luyện",
			explain: "Ta thường làm vậy, nhưng nó không giải thích cho việc nhận giá trị mất mát khi ta tối ưu trong khi huấn luyện."
		},
        {
			text: "Vì sự mất mát được chỉ định cụ thể trong `model.fit()`",
			explain: "Không, hàm mất mát luôn cố định khi bạn chạy `model.compile()`, và không thể thay đổi trong `model.fit()`."
		}
	]}
/>

{/if}

### 10. Khi nào bạn nên huấn luyện trước một mô hình mới?

<Question
	choices={[
		{
			text: "Khi không có mô hình huấn luyện sẵn cho ngôn ngữ của bạn",
			explain: "Chính xác.",
			correct: true
		},
		{
			text: "Khi bạn có rất nhiều dữ liệu có sẵn, ngay cả khi đã có một mô hình huấn luyện trước có thể hoạt động trên đó",
			explain: "Trong trường hợp này, bạn nên sử dụng mô hình đã được huấn luyện sẵn và tinh chỉnh theo dữ liệu của bạn, tránh chi phí tính toán lớn."
		},
		{
			text: "Khi bạn lăn tăn về sự sai lệch của mô hình huấn luyện trước bạn sử dụng",
			explain: "Đúng, nhưng bạn phải đảm bảo rằng dữ liệu bạn sử dụng cho huấn luyện sẽ luôn tốt hơn.",
			correct: true
		},
        {
			text: "Khi các mô hình huấn luyện trước có sẵn không đủ tốt",
			explain: "Bạn có chắc là bạn đã gỡ lỗi đúng cách cho quá trình huấn luyện của mình không?"
		}
	]}
/>

### 11. Vì sao ta dễ huấn luyện trước một mô hình ngôn ngữ khi có khối lượng văn bản khổng lồ?

<Question
	choices={[
		{
			text: "Vì có rất nhiều dữ liệu văn bản có sẵn trên mạng",
			explain: "Dù đúng, nhưng nó không thực sự là đáp án cho câu hỏi. Hãy thử lại!"
		},
		{
			text: "Vì mục đích huấn luyện trước không cần con người gán nhãn dữ liệu the pretraining objective does not require humans to label the data",
			explain: "Chính xác, mô hình ngôn ngữ là bài toán tự giám sát.",
			correct: true
		},
		{
			text: "Vì thư viện 🤗 Transformers chỉ yêu cầu một vài dòng mã để bắt đầu huấn luyện",
			explain: "Dù đúng, nhưng nó không thực sự là đáp án cho câu hỏi. Hãy thử đáp án khác"
		}
	]}
/>

### 12. Đâu là những thách thức chính khi tiền xử lí dữ liệu cho tác vụ hỏi đáp?

<Question
	choices={[
		{
			text: "Bạn cần tokenize đầu vào.",
			explain: "Chính xác, nhưng đó có thực sự là một thách thức chính?"
		},
		{
			text: "Bạn cần xử lý chuỗi ngữ cảnh dài nhận nhiều đặc trưng huấn luyện có thể chứa đáp án bên trong hoặc không.",
			explain: "Đây chắc chắn là một trong những thách thức.",
			correct: true
		},
		{
			text: "Bạn cần tokenize câu trả lời của câu hỏi cũng như đầu vào.",
			explain: "Không, trừ khi bạn đang coi vấn đề hỏi đáp là một tác vụ chuỗi sang chuỗi."
		},
       {
			text: "Từ mảng câu trả lời trong văn bản, bạn phải tìm ra token bắt đầu và kết thúc trong đầu vào đã được tokenize.",
			explain: "Đây chính là một trong những phần khó nhất, chính xác!",
			correct: true
		}
	]}
/>

### 13. Làm thể nào để hậu xử lý trong bài toán hỏi đáp?

<Question
	choices={[
		{
			text: "Mô hình cung cấp cho bạn vị trí bắt đầu và kết thúc của câu trả lời và bạn chỉ cần giải mã khoảng token tương ứng..",
			explain: "Đó có thể là một cách để làm điều đó, nhưng nó hơi quá đơn giản."
		},
		{
			text: "Mô hình cung cấp cho bạn vị trí bắt đầu và kết thúc của câu trả lời cho mỗi đặc trưng được tạo bởi một mẫu và bạn chỉ cần giải mã khoảng token tương ứng của cái có điểm tốt nhất.",
			explain: "Nó gần giống quá trình hậu xử lý chúng ta đã học, nhưng nó không hoàn toàn đúng."
		},
		{
			text: "Mô hình cung cấp cho bạn vị trí bắt đầu và kết thúc của câu trả lời cho mỗi đặc trưng được tạo bởi một mẫu và bạn chỉ cần đối sánh chúng với khoảng trong ngữ cảnh của cái có điểm tốt nhất.",
			explain: "Chính nó!",
			correct: true
		},
        {
			text: "Mô hình tạo ra một câu trả lời và bạn chỉ cần giải mã nó.",
			explain: "Không, trừ khi bạn đang coi vấn đề hỏi đáp là một tác vụ chuỗi sang chuỗi."
		}
	]}
/>
