<FrameworkSwitchCourse {fw} />

<!-- DISABLE-FRONTMATTER-SECTIONS -->

# Quiz de final de capÃ­tulo

<CourseFloatingBanner chapter={3} classNames="absolute z-10 right-0 top-0" />

A ver quÃ© has aprendido en este capÃ­tulo:

### 1. El dataset `emotion` contiene mensajes de Twitter etiquetados con emociones. BÃºscalo en el [Hub](https://huggingface.co/datasets), y lee la tarjeta del dataset. Â¿CuÃ¡l de estas no es una de sus emociones bÃ¡sicas?

<Question
  choices={[
    {
      text: "AlegrÃ­a",
      explain:
        "IntÃ©ntalo de nuevo: Â¡esta emociÃ³n sÃ­ estÃ¡ presente en ese dataset!",
    },
    {
      text: "Amor",
      explain:
        "IntÃ©ntalo de nuevo: Â¡esta emociÃ³n sÃ­ estÃ¡ presente en ese dataset!",
    },
    {
      text: "ConfusiÃ³n",
      explain:
        "Â¡Correcto! La confusiÃ³n no es una de las seis emociones bÃ¡sicas.",
      correct: true,
    },
    {
      text: "Sorpresa",
      explain: "Â¡Sorpresa! IntÃ©ntalo de nuevo.",
    },
  ]}
/>

### 2. Busca el dataset `ar_sarcasm` en el [Hub](https://huggingface.co/datasets). Â¿Con quÃ© tarea es compatible?

<Question
  choices={[
    {
      text: "ClasificaciÃ³n de sentimientos",
      explain: "Â¡Correcto! Dale las gracias a las etiquetas.",
      correct: true,
    },
    {
      text: "TraducciÃ³n automÃ¡tica",
      explain:
        "No es correcto, echa otro vistazo a la <a href='https://huggingface.co/datasets/ar_sarcasm'>tarjeta del dataset</a>.",
    },
    {
      text: "Reconocimiento de entidades nombradas",
      explain:
        "No es correcto, echa otro vistazo a la <a href='https://huggingface.co/datasets/ar_sarcasm'>tarjeta del dataset</a>.",
    },
    {
      text: "Responder preguntas",
      explain:
        "No es correcto, echa otro vistazo a la <a href='https://huggingface.co/datasets/ar_sarcasm'>tarjeta del dataset</a>.",
    },
  ]}
/>

### 3. Â¿CÃ³mo se procesan un par de frases segÃºn el modelo BERT?

<Question
  choices={[
    {
      text: "tokens_frase_1 [SEP] tokens_frase_2",
      explain:
        "Se necesita un token especial <code>[SEP]</code> para separar las dos frases, Â¡pero falta algo mÃ¡s!",
    },
    {
      text: "[CLS] tokens_frase_1 tokens_frase_2",
      explain:
        "Se necesita un token especial <code>[CLS]</code> al principio, Â¡pero falta algo mÃ¡s!",
    },
    {
      text: "[CLS] tokens_frase_1 [SEP] tokens_frase_2 [SEP]",
      explain: "Â¡Correcto!",
      correct: true,
    },
    {
      text: "[CLS] tokens_frase_1 [SEP] tokens_frase_2",
      explain:
        "Se necesita un token especial <code>[CLS]</code> al principio y un token especial <code>[SEP]</code> para separar las dos frases, Â¡pero falta algo mÃ¡s!",
    },
  ]}
/>

{#if fw === 'pt'}

### 4. Â¿CuÃ¡les son las ventajas del mÃ©todo `Dataset.map()`?

<Question
  choices={[
    {
      text: "Los resultados de la funciÃ³n se almacenan en cachÃ©, por lo que no tardaremos nada en volver a ejecutar el cÃ³digo.",
      explain:
        "Esta es una de las grandes ventajas de este mÃ©todo. Aunque no es la Ãºnica...",
      correct: true,
    },
    {
      text: "Puede aplicar multiprocesamiento para ir mÃ¡s rÃ¡pido que si se aplicara la funciÃ³n a cada elemento del conjunto de datos.",
      explain:
        "Esta es una caracterÃ­stica interesante de este mÃ©todo, Â¡pero no es la Ãºnica.",
      correct: true,
    },
    {
      text: "No carga todo el conjunto de datos en memoria, sino que guarda los resultados en cuanto se procesa un elemento.",
      explain: "Es una de las ventajas de este mÃ©todo, Â¡pero hay mÃ¡s!",
      correct: true,
    },
  ]}
/>

### 5. Â¿QuÃ© significa padding dinÃ¡mico?

<Question
  choices={[
    {
      text: "Es cuando se rellenan las entradas de cada lote con la longitud mÃ¡xima de todo el conjunto de datos.",
      explain:
        "SÃ­ que implica rellenar al crear el lote, pero no hasta la longitud mÃ¡xima en todo el conjunto de datos.",
    },
    {
      text: "Es cuando rellenas tus entradas cuando se crea el lote, a la longitud mÃ¡xima de las frases de ese lote.",
      explain:
        'Â¡Correcto! La parte "dinÃ¡mica" proviene del hecho de que el tamaÃ±o de cada lote se determina en el momento de la creaciÃ³n, y como resultado todos sus lotes pueden tener diferentes formas.',
      correct: true,
    },
    {
      text: "Es cuando se rellenan las entradas para que cada frase tenga el mismo nÃºmero de tokens que la anterior en el conjunto de datos.",
      explain:
        "Incorrecto, no tiene sentido mirar el orden de las muestras del conjunto de datos ya que lo barajamos durante el entrenamiento.",
    },
  ]}
/>

### 6. Â¿CuÃ¡l es el objetivo de la funciÃ³n "collate"?

<Question
  choices={[
    {
      text: "Se asegura de que todas las secuencias del conjunto de datos tengan la misma longitud.",
      explain:
        'Una funciÃ³n "collate" estÃ¡ relacionada con el procesamiento de lotes individuales, no del conjunto de datos al completo. AdemÃ¡s, estamos hablando de funciones "collate" genÃ©ricas, no <code>DataCollatorWithPadding</code> en especial.',
    },
    {
      text: "Combina todas las muestras del conjunto de datos en un lote.",
      explain:
        'Â¡Correcto! Puedes pasar una funciÃ³n "collate" como argumento a un <code>DataLoader</code>. Nosotros usamos la funciÃ³n <code>DataCollatorWithPadding</code>, que rellena todos los elementos de un lote para que tengan la misma longitud.',
      correct: true,
    },
    {
      text: "Preprocesa todo el conjunto de datos.",
      explain:
        'Eso serÃ­a una funciÃ³n de preprocesamiento, no una funciÃ³n "collate".',
    },
    {
      text: "Trunca las secuencias del conjunto de datos.",
      explain:
        'Una funciÃ³n "collate" estÃ¡ relacionada con el procesamiento de lotes individuales, no del conjunto de datos completo. Si quieres truncar, puedes utilizar el argumento <code>truncate</code> del <code>tokenizer</code>.',
    },
  ]}
/>

### 7. Â¿QuÃ© ocurre cuando instancias una de las clases `AutoModelForXxx` con un modelo del lenguaje preentrenado (como `bert-base-uncased`) que corresponde a una tarea distinta de aquella para la que fue entrenado?

<Question
  choices={[
    {
      text: "Nada, pero recibes una advertencia.",
      explain: "Recibes una advertencia, pero eso no es todo.",
    },
    {
      text: "La cabeza del modelo preentrenado se elimina y en su lugar se inserta una nueva cabeza adecuada para la tarea.",
      explain:
        "Correcto. Por ejemplo, cuando usamos <code>AutoModelForSequenceClassification</code> con <code>bert-base-uncased</code>, recibimos una advertencia al instanciar el modelo. La cabeza preentrenada no se puede utilizar para la tarea de clasificaciÃ³n de secuencias, por lo que es eliminada y se instancia una nueva cabeza con pesos aleatorios.",
      correct: true,
    },
    {
      text: "La cabeza del modelo preentrenado es eliminada.",
      explain: "Se necesita hacer algo mÃ¡s, intÃ©ntalo de nuevo.",
    },
    {
      text: "Nada, ya que el modelo se puede seguir ajustando para la otra tarea.",
      explain:
        "La cabeza del modelo preentrenado no fue entrenada para resolver esta tarea, Â¡asÃ­ que deberÃ­amos eliminarla!",
    },
  ]}
/>

### 8. Â¿Para quÃ© sirve `TrainingArguments`?

<Question
  choices={[
    {
      text: "Contiene todos los hiperparÃ¡metros utilizados para el entrenamiento y la evaluaciÃ³n con <code>Trainer</code>.",
      explain: "Â¡Correcto!",
      correct: true,
    },
    {
      text: "Especifica el tamaÃ±o del modelo.",
      explain:
        "El tamaÃ±o del modelo viene definido por la configuraciÃ³n del modelo, no por la clase <code>TrainingArguments</code>.",
    },
    {
      text: "Solo contiene los hiperparÃ¡metros utilizados para la evaluaciÃ³n.",
      explain:
        "En el ejemplo especificamos dÃ³nde se guardarÃ¡n el modelo y sus checkpoints. Â¡IntÃ©ntalo de nuevo!",
    },
    {
      text: "Solo contiene los hiperparÃ¡metros utilizados para el entrenamiento.",
      explain:
        "En el ejemplo tambiÃ©n utilizamos <code>evaluation_strategy</code>, que afecta a la evaluaciÃ³n. Â¡IntÃ©ntalo de nuevo!",
    },
  ]}
/>

### 9. Â¿Por quÃ© deberÃ­as utilizar la librerÃ­a ðŸ¤— Accelerate?

<Question
  choices={[
    {
      text: "Facilita acceso a modelos mÃ¡s rÃ¡pidos.",
      explain:
        "No, la librerÃ­a ðŸ¤— Accelerate library no proporciona modelos.",
    },
    {
      text: "Proporciona una API de alto nivel para que no tenga que implementar mi propio bucle de entrenamiento.",
      explain:
        "Eso es lo que hicimos con <code>Trainer</code>, no con la librerÃ­a ðŸ¤— Accelerate. Â¡Vuelve a intentarlo!",
    },
    {
      text: "Hace que nuestros bucles de entrenamiento funcionen con estrategias distribuidas.",
      explain:
        "Â¡Correcto! Con ðŸ¤— Accelerate, tus bucles de entrenamiento funcionarÃ¡n para mÃºltiples GPUs y TPUs.",
      correct: true,
    },
    {
      text: "Ofrece mÃ¡s funciones de optimizaciÃ³n.",
      explain:
        "No, la librerÃ­a ðŸ¤— Accelerate no proporciona ninguna funciÃ³n de optimizaciÃ³n.",
    },
  ]}
/>

{:else}

### 4. Â¿QuÃ© ocurre cuando instancias una de las clases `TFAutoModelForXxx` con un modelo del lenguaje preentrenado (como `bert-base-uncased`) que corresponde a una tarea distinta de aquella para la que fue entrenado?

<Question
  choices={[
    {
      text: "Nada, pero recibes una advertencia.",
      explain: "Recibes una advertencia, pero eso no es todo.",
    },
    {
      text: "La cabeza del modelo preentrenado se elimina y en su lugar se inserta una nueva cabeza adecuada para la tarea.",
      explain:
        "Correcto. Por ejemplo, cuando usamos <code>TFAutoModelForSequenceClassification</code> con <code>bert-base-uncased</code>, recibimos una advertencia al instanciar el modelo. La cabeza preentrenada no se puede utilizar para la tarea de clasificaciÃ³n de secuencias, por lo que es eliminada y se instancia una nueva cabeza con pesos aleatorios.",
      correct: true,
    },
    {
      text: "La cabeza del modelo preentrenado es eliminada",
      explain: "Se necesita hacer algo mÃ¡s, intÃ©ntalo de nuevo.",
    },
    {
      text: "Nada, ya que el modelo se puede seguir ajustando para la otra tarea.",
      explain:
        "La cabeza del modelo preentrenado no fue entrenada para resolver esta tarea, Â¡asÃ­ que deberÃ­amos eliminarla!",
    },
  ]}
/>

### 5. Los modelos TensorFlow de `transformers` ya son modelos Keras. Â¿QuÃ© ventajas ofrece esto?

<Question
  choices={[
    {
      text: "Los modelos funcionan directamente en una TPU.",
      explain:
        "Â¡Casi! Se necesitan unos pequeÃ±os cambios adicionales. Por ejemplo, es necesario ejecutar todo en un entorno <code>TPUStrategy</code>, incluyendo la inicializaciÃ³n del modelo.",
    },
    {
      text: "Puede aprovechar los mÃ©todos existentes, como <code>compile()</code>, <code>fit()</code> y <code>predict()</code>.",
      explain:
        "Â¡Correcto! Una vez que tienes los datos, entrenar el modelo requiere muy poco esfuerzo.",
      correct: true,
    },
    {
      text: "Tienes la oportunidad de aprender Keras a la vez que transformadores.",
      explain: "Correcto, pero estamos buscando otra respuesta :)",
      correct: true,
    },
    {
      text: "Puede calcular fÃ¡cilmente las mÃ©tricas relacionadas con el dataset.",
      explain:
        "Keras nos ayuda con el entrenamiento y la evaluaciÃ³n del modelo, no con el cÃ¡lculo de mÃ©tricas relacionadas con el dataset.",
    },
  ]}
/>

### 6. Â¿CÃ³mo puedes definir tu propia mÃ©trica personalizada?

<Question
  choices={[
    {
      text: "Creando una subclase de <code>tf.keras.metrics.Metric</code>.",
      explain: "Â¡Genial!",
      correct: true,
    },
    {
      text: "Utilizando la API funcional de Keras.",
      explain: "Â¡IntÃ©ntalo de nuevo!",
    },
    {
      text: "Utilizando una funciÃ³n cuya firma sea <code>metric_fn(y_true, y_pred)</code>.",
      explain: "Â¡Correcto!",
      correct: true,
    },
    {
      text: "BuscÃ¡ndolo en Google.",
      explain:
        "Esta no es la respuesta que estamos buscando, pero te podrÃ­a ayudar a encontrarla.",
      correct: true,
    },
  ]}
/>

{/if}
