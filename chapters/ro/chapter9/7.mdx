# Introducere Ã®n Gradio Blocks[[introduction-to-gradio-blocks]]

<CourseFloatingBanner chapter={9}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter9/section7.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter9/section7.ipynb"},
]} />

Ãn secÈ›iunile anterioare am explorat È™i am creat demo-uri folosind clasa `Interface`. Ãn aceastÄƒ secÈ›iune vom introduce API-ul nostru de nivel scÄƒzut **recent dezvoltat** numit `gradio.Blocks`.

Acum, care este diferenÈ›a Ã®ntre `Interface` È™i `Blocks`?

- âš¡ `Interface`: un API de nivel Ã®nalt care vÄƒ permite sÄƒ creaÈ›i un demo complet de machine learning simplu prin furnizarea unei liste de intrÄƒri È™i ieÈ™iri.

- ğŸ§± `Blocks`: un API de nivel scÄƒzut care vÄƒ permite sÄƒ aveÈ›i control complet asupra fluxurilor de date È™i layout-ului aplicaÈ›iei dvs. PuteÈ›i construi aplicaÈ›ii foarte complexe, cu mai mulÈ›i paÈ™i folosind `Blocks` (ca Ã®n "piese de construcÈ›ie").


### De ce Blocks ğŸ§±?[[why-blocks-]]

AÈ™a cum am vÄƒzut Ã®n secÈ›iunile anterioare, clasa `Interface` vÄƒ permite sÄƒ creaÈ›i cu uÈ™urinÈ›Äƒ demo-uri complete de machine learning cu doar cÃ¢teva linii de cod. API-ul `Interface` este extrem de uÈ™or de folosit, dar Ã®i lipseÈ™te flexibilitatea pe care o oferÄƒ API-ul `Blocks`. De exemplu, aÈ›i putea dori sÄƒ:

- GrupaÈ›i demo-uri Ã®nrudite ca file multiple Ã®ntr-o aplicaÈ›ie web
- SchimbaÈ›i layout-ul demo-ului dvs., de ex. sÄƒ specificaÈ›i unde sunt localizate intrÄƒrile È™i ieÈ™irile
- AveÈ›i interfeÈ›e cu mai mulÈ›i paÈ™i, Ã®n care ieÈ™irea unui model devine intrarea urmÄƒtorului model, sau sÄƒ aveÈ›i fluxuri de date mai flexibile Ã®n general
- SchimbaÈ›i proprietÄƒÈ›ile unei componente (de exemplu, opÈ›iunile dintr-un dropdown) sau vizibilitatea sa pe baza intrÄƒrii utilizatorului

Vom explora toate aceste concepte mai jos.

### Crearea unui demo simplu folosind Blocks[[creating-a-simple-demo-using-blocks]]

DupÄƒ ce aÈ›i instalat Gradio, rulaÈ›i codul de mai jos ca script Python, notebook Jupyter sau notebook Colab.

```py
import gradio as gr


def flip_text(x):
    return x[::-1]


demo = gr.Blocks()

with demo:
    gr.Markdown(
        """
    # Flip Text!
    Start typing below to see the output.
    """
    )
    input = gr.Textbox(placeholder="Flip this text")
    output = gr.Textbox()

    input.change(fn=flip_text, inputs=input, outputs=output)

demo.launch()
```

<iframe src="https://course-demos-flip-text.hf.space" frameBorder="0" height="400" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

Acest exemplu simplu de mai sus introduce 4 concepte care stau la baza Blocks:

1. Blocks vÄƒ permite sÄƒ construiÈ›i aplicaÈ›ii web care combinÄƒ markdown, HTML, butoane È™i componente interactive simplu prin instanÈ›ierea obiectelor Ã®n Python Ã®ntr-un context `with gradio.Blocks`.
> [!TIP]
> ğŸ™‹DacÄƒ nu sunteÈ›i familiarizaÈ›i cu declaraÈ›ia `with` Ã®n Python, vÄƒ recomandÄƒm sÄƒ consultaÈ›i excelentul [tutorial](https://realpython.com/python-with-statement/) de la Real Python. ÃntoarceÈ›i-vÄƒ aici dupÄƒ citirea acestuia ğŸ¤—
Ordinea Ã®n care instanÈ›iaÈ›i componentele conteazÄƒ deoarece fiecare element este redat Ã®n aplicaÈ›ia web Ã®n ordinea Ã®n care a fost creat. (Layout-uri mai complexe sunt discutate mai jos)

2. PuteÈ›i defini funcÈ›ii Python obiÈ™nuite oriunde Ã®n codul dvs. È™i sÄƒ le rulaÈ›i cu intrÄƒri de la utilizator folosind `Blocks`. Ãn exemplul nostru, avem o funcÈ›ie simplÄƒ care "inverseazÄƒ" textul de intrare, dar puteÈ›i scrie orice funcÈ›ie Python, de la un calcul simplu la procesarea predicÈ›iilor dintr-un model de machine learning.

3. PuteÈ›i atribui evenimente oricÄƒrei componente `Blocks`. Aceasta va rula funcÈ›ia dvs. cÃ¢nd componenta este apÄƒsatÄƒ, schimbatÄƒ, etc. CÃ¢nd atribuiÈ›i un eveniment, transmiteÈ›i trei parametri: `fn`: funcÈ›ia care ar trebui apelatÄƒ, `inputs`: (lista) componentei(lor) de intrare, È™i `outputs`: (lista) componentelor de ieÈ™ire care ar trebui apelate.

   Ãn exemplul de mai sus, rulÄƒm funcÈ›ia `flip_text()` cÃ¢nd valoarea din `Textbox`-ul numit intrare `input` se schimbÄƒ. Evenimentul citeÈ™te valoarea din `input`, o transmite ca parametru de nume la `flip_text()`, care apoi returneazÄƒ o valoare care este atribuitÄƒ celui de-al doilea `Textbox` numit `output`.

   Pentru a vedea o listÄƒ a evenimentelor pe care le suportÄƒ fiecare componentÄƒ, consultaÈ›i [documentaÈ›ia](https://www.gradio.app/docs/) Gradio.

4. Blocks determinÄƒ automat dacÄƒ o componentÄƒ ar trebui sÄƒ fie interactivÄƒ (sÄƒ accepte intrÄƒri de la utilizator) sau nu, pe baza declanÈ™atorilor de evenimente pe care Ã®i definiÈ›i. Ãn exemplul nostru, prima cutie de text este interactivÄƒ, deoarece valoarea sa este folositÄƒ de funcÈ›ia `flip_text()`. A doua cutie de text nu este interactivÄƒ, deoarece valoarea sa nu este niciodatÄƒ folositÄƒ ca intrare. Ãn unele cazuri, aÈ›i putea dori sÄƒ suprascriaÈ›i acest lucru, ceea ce puteÈ›i face prin transmiterea unui boolean la parametrul `interactive` al componentei (de ex. `gr.Textbox(placeholder="Flip this text", interactive=True)`).

### Personalizarea layout-ului demo-ului dvs.[[customizing-the-layout-of-your-demo]]

Cum putem folosi `Blocks` pentru a personaliza layout-ul demo-ului nostru? Ãn mod implicit, `Blocks` redÄƒ componentele pe care le creaÈ›i vertical Ã®ntr-o coloanÄƒ. PuteÈ›i schimba asta prin crearea de coloane suplimentare `with gradio.Column():` sau rÃ¢nduri `with gradio.Row():` È™i crearea componentelor Ã®n acele contexte.

IatÄƒ ce ar trebui sÄƒ È›ineÈ›i minte: orice componente create sub o `Column` (aceasta este È™i setarea implicitÄƒ) vor fi aranjate vertical. Orice componentÄƒ creatÄƒ sub un `Row` va fi aranjatÄƒ orizontal, similar cu [modelul flexbox Ã®n dezvoltarea web](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox).

Ãn final, puteÈ›i crea È™i file pentru demo-ul dvs. folosind managerul de context `with gradio.Tabs()`. Ãn acest context, puteÈ›i crea file multiple prin specificarea `with gradio.TabItem(name_of_tab):` copii. Orice componentÄƒ creatÄƒ Ã®n interiorul unui context `with gradio.TabItem(name_of_tab):` apare Ã®n acea filÄƒ.

Acum sÄƒ adÄƒugÄƒm o funcÈ›ie `flip_image()` la demo-ul nostru È™i sÄƒ adÄƒugÄƒm o filÄƒ nouÄƒ care inverseazÄƒ imaginile. Mai jos este un exemplu cu 2 file È™i foloseÈ™te È™i un Row:

```py
import numpy as np
import gradio as gr

demo = gr.Blocks()


def flip_text(x):
    return x[::-1]


def flip_image(x):
    return np.fliplr(x)


with demo:
    gr.Markdown("Flip text or image files using this demo.")
    with gr.Tabs():
        with gr.TabItem("Flip Text"):
            with gr.Row():
                text_input = gr.Textbox()
                text_output = gr.Textbox()
            text_button = gr.Button("Flip")
        with gr.TabItem("Flip Image"):
            with gr.Row():
                image_input = gr.Image()
                image_output = gr.Image()
            image_button = gr.Button("Flip")

    text_button.click(flip_text, inputs=text_input, outputs=text_output)
    image_button.click(flip_image, inputs=image_input, outputs=image_output)

demo.launch()
```

<iframe src="https://course-demos-flip-text-image.hf.space" frameBorder="0" height="450" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>


VeÈ›i observa cÄƒ Ã®n acest exemplu, am creat È™i o componentÄƒ `Button` Ã®n fiecare filÄƒ, È™i am atribuit un eveniment de clic fiecÄƒrui buton, care este ceea ce ruleazÄƒ de fapt funcÈ›ia.

### Explorarea evenimentelor È™i stÄƒrii[[exploring-events-and-state]]

La fel cum puteÈ›i controla layout-ul, `Blocks` vÄƒ oferÄƒ control fin asupra evenimentelor care declanÈ™eazÄƒ apelurile de funcÈ›ii. Fiecare componentÄƒ È™i multe layout-uri au evenimente specifice pe care le suportÄƒ.

De exemplu, componenta `Textbox` are 2 evenimente: `change()` (cÃ¢nd valoarea din interiorul cutiei de text se schimbÄƒ), È™i `submit()` (cÃ¢nd un utilizator apasÄƒ tasta enter Ã®n timp ce este focalizat pe cutia de text). Componentele mai complexe pot avea È™i mai multe evenimente: de exemplu, componenta `Audio` are È™i evenimente separate pentru cÃ¢nd fiÈ™ierul audio este redat, È™ters, Ã®ntrerupt, etc. ConsultaÈ›i documentaÈ›ia pentru evenimentele pe care le suportÄƒ fiecare componentÄƒ.

PuteÈ›i ataÈ™a declanÈ™atorul de eveniment la niciunul, unul sau mai multe dintre aceste evenimente. CreaÈ›i un declanÈ™ator de eveniment prin apelarea numelui evenimentului pe instanÈ›a componentei ca funcÈ›ie -- de ex. `textbox.change(...)` sau `btn.click(...)`. FuncÈ›ia primeÈ™te trei parametri, aÈ™a cum s-a discutat mai sus:

- `fn`: funcÈ›ia care sÄƒ ruleze
- `inputs`: o (listÄƒ de) componentÄƒ(e) ale cÄƒror valori ar trebui furnizate ca parametri de intrare la funcÈ›ie. Valoarea fiecÄƒrei componente este mapatÄƒ la parametrul funcÈ›iei corespunzÄƒtor, Ã®n ordine. Acest parametru poate fi None dacÄƒ funcÈ›ia nu primeÈ™te parametri.
- `outputs`: o (listÄƒ de) componentÄƒ(e) ale cÄƒror valori ar trebui actualizate pe baza valorilor returnate de funcÈ›ie. Fiecare valoare returnatÄƒ seteazÄƒ valoarea componentei corespunzÄƒtoare, Ã®n ordine. Acest parametru poate fi None dacÄƒ funcÈ›ia nu returneazÄƒ nimic.

PuteÈ›i face chiar ca componenta de intrare È™i ieÈ™ire sÄƒ fie aceeaÈ™i componentÄƒ, aÈ™a cum facem Ã®n acest exemplu care foloseÈ™te un model GPT pentru completarea textului:

```py
import gradio as gr

api = gr.Interface.load("huggingface/EleutherAI/gpt-j-6B")


def complete_with_gpt(text):
    # Use the last 50 characters of the text as context
    return text[:-50] + api(text[-50:])


with gr.Blocks() as demo:
    textbox = gr.Textbox(placeholder="Type here and press enter...", lines=4)
    btn = gr.Button("Generate")

    btn.click(complete_with_gpt, textbox, textbox)

demo.launch()
```

<iframe src="https://course-demos-blocks-gpt.hf.space" frameBorder="0" height="300" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

### Crearea demo-urilor cu mai mulÈ›i paÈ™i[[creating-multi-step-demos]]

Ãn unele cazuri, aÈ›i putea dori un _demo cu mai mulÈ›i paÈ™i_, Ã®n care reutilizaÈ›i ieÈ™irea unei funcÈ›ii ca intrare la urmÄƒtoarea. Acest lucru este foarte uÈ™or de fÄƒcut cu `Blocks`, deoarece puteÈ›i folosi o componentÄƒ pentru intrarea unei declanÈ™Äƒri de eveniment, dar ieÈ™irea alteia. PriviÈ›i componenta text din exemplul de mai jos, valoarea sa este rezultatul unui model speech-to-text, dar este transmisÄƒ È™i Ã®ntr-un model de analizÄƒ de sentiment:

```py
from transformers import pipeline

import gradio as gr

asr = pipeline("automatic-speech-recognition", "facebook/wav2vec2-base-960h")
classifier = pipeline("text-classification")


def speech_to_text(speech):
    text = asr(speech)["text"]
    return text


def text_to_sentiment(text):
    return classifier(text)[0]["label"]


demo = gr.Blocks()

with demo:
    audio_file = gr.Audio(type="filepath")
    text = gr.Textbox()
    label = gr.Label()

    b1 = gr.Button("Recognize Speech")
    b2 = gr.Button("Classify Sentiment")

    b1.click(speech_to_text, inputs=audio_file, outputs=text)
    b2.click(text_to_sentiment, inputs=text, outputs=label)

demo.launch()
```

<iframe src="https://course-demos-blocks-multi-step.hf.space" frameBorder="0" height="600" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

### Actualizarea ProprietÄƒÈ›ilor Componentei[[updating-component-properties]]

PÃ¢nÄƒ acum, am vÄƒzut cum sÄƒ creÄƒm evenimente pentru a actualiza valoarea unei alte componente. Dar ce se Ã®ntÃ¢mplÄƒ dacÄƒ doriÈ›i sÄƒ schimbaÈ›i alte proprietÄƒÈ›i ale unei componente, cum ar fi vizibilitatea unei cutii de text sau opÈ›iunile dintr-un grup de butoane radio? PuteÈ›i face acest lucru prin returnarea metodei `update()` a unei clase de componentÄƒ Ã®n loc de o valoare de returnare obiÈ™nuitÄƒ din funcÈ›ia dvs.

Acest lucru este cel mai uÈ™or ilustrat cu un exemplu:

```py
import gradio as gr


def change_textbox(choice):
    if choice == "short":
        return gr.Textbox.update(lines=2, visible=True)
    elif choice == "long":
        return gr.Textbox.update(lines=8, visible=True)
    else:
        return gr.Textbox.update(visible=False)


with gr.Blocks() as block:
    radio = gr.Radio(
        ["short", "long", "none"], label="What kind of essay would you like to write?"
    )
    text = gr.Textbox(lines=2, interactive=True)

    radio.change(fn=change_textbox, inputs=radio, outputs=text)
    block.launch()
```

<iframe src="https://course-demos-blocks-update-component-properties.hf.space" frameBorder="0" height="300" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

Tocmai am explorat toate conceptele de bazÄƒ ale `Blocks`! La fel ca Ã®n cazul `Interface`-urilor, puteÈ›i crea demo-uri cool care pot fi partajate folosind `share=True` Ã®n metoda `launch()` sau implementate pe [Hugging Face Spaces](https://huggingface.co/spaces). 