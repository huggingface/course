# Partajarea demo-urilor cu al탵ii[[sharing-demos-with-others]]

<CourseFloatingBanner chapter={9}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter9/section4.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter9/section4.ipynb"},
]} />

Acum c캒 a탵i construit un demo, probabil dori탵i s캒 칥l partaja탵i cu al탵ii. Demo-urile Gradio
pot fi partajate 칥n dou캒 moduri: folosind un ***link de partajare temporar*** sau ***g캒zduire permanent캒 pe Spaces***.

Vom acoperi ambele abord캒ri 칥n cur칙nd. Dar 칥nainte s캒 v캒 partaja탵i demo-ul, este posibil s캒 dori탵i s캒 칥l 칥nfrumuse탵a탵i 游눈.

### 칉nfrumuse탵area demo-ului Gradio:[[polishing-your-gradio-demo]]

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter9/gradio-demo-overview.png" alt="Overview of a gradio interface">
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter9/gradio-demo-overview-dark.png" alt="Overview of a gradio interface">
</div>

Pentru a ad캒uga con탵inut suplimentar la demo-ul dvs., clasa `Interface` suport캒 c칙탵iva parametri op탵ionali:
    - `title`: pute탵i da un titlu demo-ului dvs., care apare _deasupra_ componentelor de intrare 탳i ie탳ire.
    - `description`: pute탵i da o descriere (칥n text, Markdown sau HTML) pentru interfa탵캒, care apare deasupra componentelor de intrare 탳i ie탳ire 탳i sub titlu.
    - `article`: pute탵i scrie 탳i un articol extins (칥n text, Markdown sau HTML) explic칙nd interfa탵a. Dac캒 este furnizat, apare _sub_ componentele de intrare 탳i ie탳ire.
    - `theme`: nu v캒 plac culorile implicite? Seta탵i tema s캒 foloseasc캒 una dintre `default`, `huggingface`, `grass`, `peach`. Pute탵i ad캒uga 탳i prefixul `dark-`, de ex. `dark-peach` pentru tema 칥ntunecat캒 (sau doar `dark` pentru tema 칥ntunecat캒 implicit캒).
    - `examples`: pentru a face demo-ul *mult mai u탳or de folosit*, pute탵i furniza exemple de intr캒ri pentru func탵ie. Acestea apar sub componentele UI 탳i pot fi folosite pentru a popula interfa탵a. Acestea ar trebui furnizate ca o list캒 imbricat캒, 칥n care lista exterioar캒 const캒 din exemple 탳i fiecare list캒 interioar캒 const캒 dintr-o intrare corespunz캒toare fiec캒rei componente de intrare.
    - `live`: dac캒 dori탵i s캒 face탵i demo-ul "live", adic캒 modelul s캒 ruleze din nou de fiecare dat캒 c칙nd intrarea se schimb캒, pute탵i seta `live=True`. Acest lucru are sens s캒 se foloseasc캒 cu modele rapide (vom vedea un exemplu la sf칙r탳itul acestei sec탵iuni)
Folosind op탵iunile de mai sus, ajungem la o interfa탵캒 mai complet캒. Rula탵i codul de mai jos pentru a putea conversa cu Rick 탳i Morty:

```py
title = "Ask Rick a Question"
description = """
The bot was trained to answer questions based on Rick and Morty dialogues. Ask Rick anything!
<img src="https://huggingface.co/spaces/course-demos/Rick_and_Morty_QA/resolve/main/rick.png" width=200px>
"""

article = "Check out [the original Rick and Morty Bot](https://huggingface.co/spaces/kingabzpro/Rick_and_Morty_Bot) that this demo is based off of."

gr.Interface(
    fn=predict,
    inputs="textbox",
    outputs="text",
    title=title,
    description=description,
    article=article,
    examples=[["What are you doing?"], ["Where should we time travel to?"]],
).launch()
```

Folosind op탵iunile de mai sus, ajungem la o interfa탵캒 mai complet캒. 칉ncerca탵i interfa탵a de mai jos:

<iframe src="https://course-demos-Rick-and-Morty-QA.hf.space" frameBorder="0" height="800" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

### Partajarea demo-ului cu link-uri temporare[[sharing-your-demo-with-temporary-links]]
Acum c캒 avem un demo func탵ional al modelului nostru de machine learning, s캒 칥nv캒탵캒m cum s캒 partaj캒m cu u탳urin탵캒 un link c캒tre interfa탵a noastr캒.
Interfe탵ele pot fi partajate public cu u탳urin탵캒 prin setarea `share=True` 칥n metoda `launch()`:

```python
gr.Interface(classify_image, "image", "label").launch(share=True)
```

Aceasta genereaz캒 un link public, partajabil pe care 칥l pute탵i trimite oricui! C칙nd trimite탵i acest link, utilizatorul din cealalt캒 parte poate 칥ncerca modelul 칥n browserul lor timp de p칙n캒 la 72 de ore. Deoarece procesarea se 칥nt칙mpl캒 pe dispozitivul dvs. (at칙ta timp c칙t dispozitivul dvs. r캒m칙ne pornit!), nu trebuie s캒 v캒 face탵i griji cu privire la 칥mpachetarea dependen탵elor. Dac캒 lucra탵i dintr-un notebook Google Colab, un link de partajare este 칥ntotdeauna creat automat. De obicei arat캒 cam a탳a: **XXXXX.gradio.app**. De탳i link-ul este servit printr-un link Gradio, suntem doar un proxy pentru serverul dvs. local 탳i nu stoc캒m datele trimise prin interfe탵e.

Re탵ine탵i totu탳i c캒 aceste link-uri sunt accesibile public, ceea ce 칥nseamn캒 c캒 oricine poate folosi modelul dvs. pentru predic탵ie! Prin urmare, asigura탵i-v캒 s캒 nu expune탵i informa탵ii sensibile prin func탵iile pe care le scrie탵i sau s캒 permite탵i modific캒ri critice pe dispozitivul dvs. Dac캒 seta탵i `share=False` (implicit), doar un link local este creat.

### G캒zduirea demo-ului pe Hugging Face Spaces[[hosting-your-demo-on-hugging-face-spaces]]

Un link de partajare pe care 칥l pute탵i transmite colegilor este cool, dar cum pute탵i g캒zdui permanent demo-ul 탳i s캒 칥l face탵i s캒 existe 칥n propriul s캒u "spa탵iu" pe internet?

Hugging Face Spaces ofer캒 infrastructura pentru a g캒zdui permanent modelul dvs. Gradio pe internet, **gratuit**! Spaces v캒 permite s캒 crea탵i 탳i s캒 칥mpinge탵i 칥ntr-un repo (public sau privat),
unde codul interfa탵a dvs. Gradio
va exista 칥ntr-un fi탳ier `app.py`. [Citi탵i un tutorial pas cu pas](https://huggingface.co/blog/gradio-spaces) pentru a 칥ncepe, sau urm캒ri탵i un videoclip exemplu mai jos.

<Youtube id="LS9Y2wDVI0k" />

## 九勇 S캒 aplic캒m![[lets-apply-it]]

Folosind ceea ce tocmai am 칥nv캒탵at 칥n sec탵iunile de p칙n캒 acum, s캒 cre캒m demo-ul de recunoa탳tere a schi탵elor pe care l-am v캒zut 칥n [sec탵iunea unu din acest capitol](/course/chapter9/1). S캒 ad캒ug캒m c칙teva personaliz캒ri la interfa탵a noastr캒 탳i s캒 set캒m `share=True` pentru a crea un link public pe care 칥l putem transmite.

Putem 칥nc캒rca etichetele din [class_names.txt](https://huggingface.co/spaces/dawood/Sketch-Recognition/blob/main/class_names.txt) 탳i s캒 칥nc캒rc캒m modelul pytorch pre-antrenat din [pytorch_model.bin](https://huggingface.co/spaces/dawood/Sketch-Recognition/blob/main/pytorch_model.bin). Desc캒rca탵i aceste fi탳iere urm캒rind link-ul 탳i f캒c칙nd clic pe download 칥n col탵ul din st칙nga sus al previzualiz캒rii fi탳ierului. S캒 arunc캒m o privire la codul de mai jos pentru a vedea cum folosim aceste fi탳iere pentru a 칥nc캒rca modelul nostru 탳i a crea o func탵ie `predict()`:
```py
from pathlib import Path
import torch
import gradio as gr
from torch import nn

LABELS = Path("class_names.txt").read_text().splitlines()

model = nn.Sequential(
    nn.Conv2d(1, 32, 3, padding="same"),
    nn.ReLU(),
    nn.MaxPool2d(2),
    nn.Conv2d(32, 64, 3, padding="same"),
    nn.ReLU(),
    nn.MaxPool2d(2),
    nn.Conv2d(64, 128, 3, padding="same"),
    nn.ReLU(),
    nn.MaxPool2d(2),
    nn.Flatten(),
    nn.Linear(1152, 256),
    nn.ReLU(),
    nn.Linear(256, len(LABELS)),
)
state_dict = torch.load("pytorch_model.bin", map_location="cpu")
model.load_state_dict(state_dict, strict=False)
model.eval()


def predict(im):
    x = torch.tensor(im, dtype=torch.float32).unsqueeze(0).unsqueeze(0) / 255.0
    with torch.no_grad():
        out = model(x)
    probabilities = torch.nn.functional.softmax(out[0], dim=0)
    values, indices = torch.topk(probabilities, 5)
    return {LABELS[i]: v.item() for i, v in zip(indices, values)}
```

Acum c캒 avem o func탵ie `predict()`. Urm캒torul pas este s캒 definim 탳i s캒 lans캒m interfa탵a noastr캒 gradio:

```py
interface = gr.Interface(
    predict,
    inputs="sketchpad",
    outputs="label",
    theme="huggingface",
    title="Sketch Recognition",
    description="Who wants to play Pictionary? Draw a common object like a shovel or a laptop, and the algorithm will guess in real time!",
    article="<p style='text-align: center'>Sketch Recognition | Demo Model</p>",
    live=True,
)
interface.launch(share=True)
```

<iframe src="https://course-demos-Sketch-Recognition.hf.space" frameBorder="0" height="650" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>


Observa탵i parametrul `live=True` 칥n `Interface`, care 칥nseamn캒 c캒 demo-ul cu schi탵e face
o predic탵ie de fiecare dat캒 c칙nd cineva deseneaz캒 pe sketchpad (f캒r캒 buton de submit!).

칉n plus, am setat 탳i argumentul `share=True` 칥n metoda `launch()`.
Aceasta va crea un link public pe care 칥l pute탵i
trimite oricui! C칙nd trimite탵i acest link, utilizatorul din cealalt캒 parte poate 칥ncerca
modelul de recunoa탳tere a schi탵elor. Pentru a reitera, a탵i putea g캒zdui 탳i modelul pe Hugging Face Spaces,
care este modul 칥n care reu탳im s캒 칥ncorpor캒m demo-ul de mai sus.

Urm캒torul, vom acoperi alte moduri 칥n care Gradio poate fi folosit cu ecosistemul Hugging Face! 