<FrameworkSwitchCourse {fw} />

<!-- DISABLE-FRONTMATTER-SECTIONS

# Quiz pentru finalizarea capitolului[[end-of-chapter-quiz]]

<CourseFloatingBanner
    chapter={3}
    classNames="absolute z-10 right-0 top-0"
/>

TesteazÄƒ ce ai Ã®nvÄƒÈ›at Ã®n acest capitol!

### 1. Datasetul `emotion` conÈ›ine mesaje de pe Twitter cu labeluri cu emoÈ›ii. CÄƒutaÈ›i-l Ã®n [Hub](https://huggingface.co/datasets) È™i citiÈ›i card-ul datasetului. Care dintre acestea nu este una dintre emoÈ›iile sale de bazÄƒ?

<Question
	choices={[
		{
			text: "Fericire",
			explain: "ÃncercÄƒ din nou â€” emoÈ›ia asta este prezentÄƒ Ã®n acest dataset!"
		},
		{
			text: "Iubire",
			explain: "ÃncercÄƒ din nou â€” emoÈ›ia asta este prezentÄƒ Ã®n acest dataset!"
		},
		{
			text: "Confuzie",
			explain: "Corect! Confuzia nu este una dintre cele È™ase emoÈ›ii de bazÄƒ.",
            correct: true
		},
        {
			text: "SuprpizÄƒ",
			explain: "SuprizÄƒ! ÃncearcÄƒ din nou!"
		}
	]}
/>

### 2. CÄƒutaÈ›i datasetul `ar_sarcasm` Ã®n [Hub](https://huggingface.co/datasets). Care este sarcina pe care o sprijinÄƒ?

<Question
	choices={[
		{
			text: "Clasificarea sentimentului",
			explain: "Acesta este corect! PoÈ›i sÄƒ È™tii graÈ›ie etichetelor.",
            correct: true
		},
		{
			text: "Machine Translation",
			explain: "Acesta nu este corect â€” Ã®ncercaÈ›i din nou, Ã®n funcÈ›ie de cardul datasetului <a href='https://huggingface.co/datasets/ar_sarcasm'>ar_sarcasm</a>!"
		},
		{
			text: "ReconstrucÈ›ia entitÄƒÈ›ilor numite",
			explain: "Acesta nu este corect â€” Ã®ncercaÈ›i din nou, Ã®n funcÈ›ie de cardul datasetului <a href='https://huggingface.co/datasets/ar_sarcasm'>ar_sarcasm</a>!"
		},
        {
			text: "RÄƒspunsul Ã®ntrebÄƒrii",
			explain: "NesatisfÄƒcÄƒtor â€” Ã®ncercaÈ›i din nou!"
		}
	]}
/>

### 3. Cum se aÈ™teaptÄƒ modelul BERT ca o pereche de propoziÈ›ii sÄƒ fie procesate?

<Question
	choices={[
		{
			text: "Tokens_of_sentence_1 [SEP] Tokens_of_sentence_2",
			explain: "Este necesarÄƒ un token special <code>[SEP]</code> pentru a separa cele douÄƒ propoziÈ›ii, dar nu e doar asta!"
		},
		{
			text: "[CLS] Tokens_of_sentence_1 Tokens_of_sentence_2",
			explain:"Este necesarÄƒ un token special <code>[CLS]</code> pentru a separa cele douÄƒ propoziÈ›ii, dar nu e doar asta!
		},
		{
			text: "[CLS] Tokens_of_sentence_1 [SEP] Tokens_of_sentence_2 [SEP]",
			explain: "Acesta este corect!",
            correct: true
		},
        {
			text: "[CLS] Token-urile propoziÈ›iei_1 [SEP] Token-urile propoziÈ›iei_2",
			explain: "Este necesar un token special <code>[CLS]</code> la head, precum È™i un token special <code>[SEP]</code> pentru a separa cele douÄƒ propoziÈ›ii, dar nu e doar asta!"
		}
	]}
/>

{#if fw === 'pt'}
### 4. Care sunt beneficiile metodei `Dataset.map()`?

<Question
	choices={[
		{
			text: "Rezultatele funcÈ›iei sunt cached, deci nu va lua timp dacÄƒ re-executÄƒm codul.",
			explain: "Acest lucru este efectiv unul dintre beneficiile sale! Nu e doar asta...",
            correct: true
		},
		{
			text: "Se aplicÄƒ multiprocessing pentru a merge mai rapid decÃ¢t aplicarea funcÈ›iei la fiecare element al datasetului.",
			explain: "Acest lucru este efectiv o caracteristicÄƒ specialÄƒ a acestei metode, dar nu e doar asta...",
            correct: true
		},
		{
			text: "Nu Ã®ncarcÄƒ Ã®ntregul datasetul Ã®n memorie È™i salveazÄƒ rezultatele la fiecare element procesat.",
			explain: "Acest lucru este un avantaj al acestei metode. ExistÄƒ È™i altele...",
            correct: true
		},
	]}
/>

### 5. Ce Ã®nseamnÄƒ "dynamic padding"?

<Question
	alegeri={[  
		{
			text: "Dynamic padding este atunci cÃ¢nd faci padding inputurilor pentru fiecare batch la lungimea maximÄƒ din Ã®ntregul dataset.",
			explain: "Acest lucru implicÄƒ paddingul, dar nu la lungimea maximÄƒ a Ã®ntregului dataset."
		},
		{
			text: "Dynamic padding este atunci cÃ¢nd faci padding inputurilor pentru fiecare batch, la lungimea maximÄƒ a propoziÈ›iilor din acel batch.",
			explain: "Este corect! Partea \"dynamic\" vine din faptul cÄƒ dimensiunea fiecÄƒrui batch este determinatÄƒ la momentul creÄƒrii lui, iar toate batch-urile pot avea shape-uri diferite ca rezultat.",
            correct: true
		},
		{
			text: "Dynamic padding este atunci cÃ¢nd faci padding inputurilor pentru ca fiecare propoziÈ›ie sÄƒ aibÄƒ acelaÈ™i numÄƒr de tokenuri ca Ã®n precedentul dataset.",
			explain: "Este greÈ™it, È™i nu are nici un sens sÄƒ ne uitÄƒm la ordinea din dataset, deoarece Ã®l amestecÄƒm Ã®n timpul antrenÄƒrii."
		},
	]}
/>

### 6. Care este scopul unei funcÈ›ii collate?

<Question
	alegeri={[  
		{
			text: "AsigurÄƒ cÄƒ toate secvenÈ›ele din dataset au aceeaÈ™i lungime.",
			explain: "O funcÈ›ie collate este implicatÄƒ Ã®n gestionarea a cÃ¢te unui batch, nu Ã®ntregului dataset. De asemenea, vorbim despre funcÈ›ii generice, nu <code>DataCollatorWithPadding</code> specific."
		},
		{
			text: "AdunÄƒ toate sampleurile dintr-un batch.",
			explain: "Corect! PoÈ›i sÄƒ dai ca argument o funcÈ›ie collate Ã®n constructorul unui <code>DataLoader</code>. Am folosit funcÈ›ia <code>DataCollatorWithPadding</code>, care face padding tuturor elementelor dintr-un batch, astfel Ã®ncÃ¢t ele sÄƒ aibÄƒ aceeaÈ™i lungime.",
            correct: true
		},
		{
			text: "PreproceseazÄƒ Ã®ntregul dataset.",
			explain: "Acest lucru ar fi o funcÈ›ie de preprocesare, nu una collate."
		},
        {
			text: "Taie secvenÈ›ele din dataset.",
			explain: "O funcÈ›ie collate este implicatÄƒ Ã®n gestionarea a cÃ¢te un batch, nu Ã®ntregului dataset. DacÄƒ eÈ™ti interesat Ã®n tÄƒierea acestora, poÈ›i utiliza argumentul <code>truncate</code> al unui <code>tokenizer</code>."
		}
	]}
/>

### 7. Ce se Ã®ntÃ¢mplÄƒ cÃ¢nd iniÈ›ializezi una dintre clasele `AutoModelForXxx` cu un pretrained language model (ca <code>bert-base-uncased</code>) care corespunde unei alte sarcini decÃ¢t aceea pentru care a fost antrenat?

<Question
	alegeri={[  
		{
			text: "Nimic, dar se afiÈ™eazÄƒ un warning.",
			explain: "Se afiÈ™eazÄƒ un warning, dar asta nu este totul!"
		},
		{
			text: "Headul modelului preantrenat al modelului este Ã®nlÄƒturat È™i Ã®nlocuit cu un head nou potrivit pentru sarcinÄƒ.",
			explain: "Corect. De exemplu, atunci cÃ¢nd am folosit <code>AutoModelForSequenceClassification</code> cu <code>bert-base-uncased</code>, am primit warningul la momentul iniÈ›ializÄƒrii modelului. Headul preantrenat nu este folosit pentru sarcina de clasificare a secvenÈ›elor, astfel Ã®ncÃ¢t el este Ã®nlÄƒturat È™i Ã®nlocuit cu un head nou, cu weights aleatorii.",
            correct: true
		},
		{
			text: "Headul modelului preantrenat este Ã®nlÄƒturat.",
			explain: "Trebuie sÄƒ se Ã®ntÃ¢mple Ã®ncÄƒ ceva. ÃncearcÄƒ din nou!"
		},
        {
			text: "Nimic, deoarece modelul poate avea fine-tuning pentru o sarcina diferitÄƒ.",
			explain: "Headul preantrenat al modelului nu a fost antrenat sÄƒ rezolve aceastÄƒ sarcinÄƒ, astfel Ã®ncÃ¢t el trebuie Ã®nlÄƒturat."
		}
	]}
/>

### 8. Care este scopul la `TrainingArguments`?

<Question
	alegeri={[  
		{
			text: "ConÈ›ine toÈ›i hyperparametrii utilizaÈ›i pentru antrenare È™i evaluare cu <code>Trainer</code>.",
			explain: "Corect!",
            correct: true
		},
		{
			text: "SpecificÄƒ dimensiunea modelului.",
			explain: "Dimensiunea modelului este definitÄƒ de configuraÈ›ia modelului, nu clasa <code>TrainingArguments</code>. "
		},
		{
			text: "ConÈ›ine doar hyperparametrii utilizaÈ›i pentru evaluare.",
			explain: "Ãn exemplul nostru, am specificat unde se va salva modelul È™i toate checkpoint-urile. ÃncearcÄƒ din nou!"
		},
        {
			text: "ConÈ›ine doar hyperparametrii utilizaÈ›i pentru antrenare.",
			explain: "Ãn exemplul nostru, am folosit un <code>evaluation_strategy</code>, astfel Ã®ncÃ¢t acest lucru afecteazÄƒ È™i evaluarea. ÃncearcÄƒ din nou!"
		}
	]}
/>

### 9. De ce ar trebui sÄƒ folosim biblioteca ğŸ¤— Accelerate?

<Question
	alegeri={[  
		{
			text: "OfereÄƒ acces la modele mai rapide.",
			explain: "Nu, biblioteca ğŸ¤— Accelerate nu oferÄƒ nici un model."
		},
		{
			text: "OferÄƒ un API de nivel Ã®nalt astfel Ã®ncÃ¢t sÄƒ nu trebuiascÄƒ sÄƒ implementÄƒm singuri un training loop.",
			explain: "Acest lucru este ceea ce am fÄƒcut cu <code>Trainer</code>, nu biblioteca ğŸ¤— Accelerate. ÃncearcÄƒ din nou!"
		},
		{
			text: "Face ca loopurile de antrenare sÄƒ funcÈ›ioneze pe distributed strategies.",
			explain: "Corect! Cu ğŸ¤— Accelerate, loopurile de antrenare vor funcÈ›iona pentru multiple GPU-uri È™i TPU-uri.",
            correct: true
		},
        {
			text: "OferÄƒ mai multe funcÈ›ii de optimizare.",
			explain: "Nu, biblioteca ğŸ¤— Accelerate nu oferÄƒ nici o funcÈ›iune de optimizare."
		}
	]}
/>

{:else}
### 4. Ce se Ã®ntÃ¢mplÄƒ cÃ¢nd iniÈ›ializezi una dintre clasele `TFAutoModelForXxx` cu un pretrained language model (ca <code>bert-base-uncased</code>) care corespunde unei alte sarcini decÃ¢t aceea pentru care a fost antrenat?

<Question
	alegeri={[  
		{
			text: "Nimic, dar se afiÈ™eazÄƒ un warning.",
			explain: "Se afiÈ™eazÄƒ un warning, dar asta nu este totul!"
		},
		{
			text: "Headul preantrenat al modelului este Ã®nlÄƒturat È™i Ã®nlocuit cu un head nou potrivit pentru sarcinÄƒ.",
			explain: "Corect. De exemplu, atunci cÃ¢nd am folosit <code>TFAutoModelForSequenceClassification</code> cu <code>bert-base-uncased</code>, am primit warningul la momentul iniÈ›ializÄƒrii modelului. Headul preantrenat nu este folosit pentru sarcina de clasificare a secvenÈ›elor, astfel Ã®ncÃ¢t el este Ã®nlÄƒturat È™i Ã®nlocuit cu un head nou, cu weights aleatorii.",
            correct: true
		},
		{
			text: "Headul preantrenat al modelului este Ã®nlÄƒturat.",
			explain: "Trebuie sÄƒ se Ã®ntÃ¢mple ceva mai mult. ÃncercÄƒ din nou!"
		},
        {
			text: "Nimic, deoarece modelul poate fi reantrenat pentru o sarcina diferitÄƒ.",
			explain: "Headul prentrenat al modelului nu a fost antrenat sÄƒ rezolve aceastÄƒ sarcinÄƒ, astfel Ã®ncÃ¢t el trebuie Ã®nlÄƒturat."
		}
	]}
/>

### 5. Modelele TensorFlow din `transformers` sunt deja modele Keras. Ce beneficiu oferÄƒ acest lucru?

<Question
	alegeri={[  
		{
			text: "Modelele funcÈ›ioneazÄƒ pe un TPU direct.",
			explain: "EÈ™ti aproape, dar sunt necesare mici schimbÄƒri. De exemplu, trebuie sÄƒ rulezi totul Ã®ntr-un <code>TPUStrategy</code> scop, inclusiv iniÈ›ializarea modelului."
		},
		{
			text: "PoÈ›i folosi metode existente precum <code>compile()</code>, <code>fit()</code>, È™i <code>predict()</code>.",
			explain: "Corect! OdatÄƒ ce ai datele, antrenarea pe acestea necesitÄƒ foarte puÈ›in lucru.",
            correct: true
		},
		{
			text: "PoÈ›i Ã®nvÄƒÈ›a È™i Keras precum È™i Transformers.",
			explain: "Corect, dar cÄƒutÄƒm altceva. :)",
			correct: true
		},
        {
			text: "PoÈ›i calcula uÈ™or metrice legate de dataset.",
			explain: "Keras ne ajutÄƒ cu antrenarea È™i evaluarea modelului, dar nu calculeazÄƒ metrice legate de dataset."
		}
	]}
/>

### 6. Cum poÈ›i defini o metricÄƒ personalizatÄƒ?

<Question
	alegeri={[  
		{
			text: "Prin subclassing pe <code>tf.keras.metrics.Metric</code>.",
			explain: "Excelent!",
			correct: true
		},
		{
			text: "Folosind API-ul Keras.",
			explain: "ÃncercÄƒ din nou!"
		},
		{
			text: "Prin intermediul callable cu semnatura <code>metric_fn(y_true, y_pred)</code>.",
			explain: "Corect!",
			correct: true
		},
        {
			text: "Prin cÄƒutarea pe Google.",
			explain: "Acest lucru nu este rÄƒspunsul pe care Ã®l cÄƒutÄƒm, dar ar trebui sÄƒ te ajute sÄƒ-l gÄƒseÈ™ti.",
            correct: true
		}
	]}
/>

{/if}