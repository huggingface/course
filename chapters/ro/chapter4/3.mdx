<FrameworkSwitchCourse {fw} />

# Partajarea modelelor preantrenate[[sharing-pretrained-models]]

{#if fw === 'pt'}

<CourseFloatingBanner chapter={4}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter4/section3_pt.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter4/section3_pt.ipynb"},
]} />

{:else}

<CourseFloatingBanner chapter={4}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter4/section3_tf.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter4/section3_tf.ipynb"},
]} />

{/if}

칉n urm캒toarele etape, vom explora modalit캒탵ile cele mai u탳oare de a partaja modelele preantrenate pe 游뱅 Hub. Exist캒 tooluri 탳i utilities disponibile care fac posibil캒 partajarea 탳i actualizarea modelelor direct pe Hub, despre care vom vorbi mai jos.

<Youtube id="9yY3RB_GSPM"/>

Recomand캒m tuturor utilizatorilor care antreneaz캒 modele s캒 contribuie prin partajarea lor cu comunitatea - partajarea modelelor, chiar 탳i atunci c칙nd sunt antrenate pe dateseturi foarte specifice, va ajuta la economisind timpul altor utilizatori 탳i resurselor 탳i va oferi acces la artefacte antrenate folositoare. 칉n schimb, pute탵i beneficia de munca altora!

Exist캒 trei moduri de a crea noi repositorii cu modele:

- Utiliz칙nd API-ul `push_to_hub`
- Utiliz칙nd biblioteca Python `huggingface_hub`
- Utiliz칙nd interfa탵a web

Odat캒 ce ave탵i creat un repository, pute탵i 칥nc캒rca fi탳iere 칥n el folosind git 탳i git-lfs. Vom trece 칥mpreun캒 prin crearea model repositories 탳i 칥nc캒rcarea fi탳ierelor 칥n el 칥n urm캒toarele sec탵iuni.


## Utiliz칙nd API-ul `push_to_hub`[[using-the-pushtohub-api]]

{#if fw === 'pt'}

<Youtube id="Zh0FfmVrKX0"/>

{:else}

<Youtube id="pUh5cGmNV8Y"/>

{/if}

Cea mai simpl캒 modalitate de a 칥nc캒rca fi탳iere pe Hub este utiliz칙nd API-ul `push_to_hub`.

칉nainte de a continua, ave탵i nevoie s캒 crea탵i un token de autentificare astfel 칥nc칙t API-ul `huggingface_hub` s캒 탳tie cine sunte탵i 탳i care sunt namespaces la care ave탵i acces de scriere. Asigura탵i-v캒 c캒 sunte탵i 칥ntr-un environment unde ave탵i instalat `transformers` (vedeti [Configurarea](/course/chapter0)). Dac캒 sunte탵i 칥ntr-un notebook, pute탵i folosi urm캒toarea func탵ie pentru a v캒 autentifica:

```python
from huggingface_hub import notebook_login

notebook_login()
```

칉n terminal, pute탵i rula urm캒toarea comand캒:

```bash
huggingface-cli login
```

칉n ambele cazuri, ve탵i fi ruga탵i s캒 introduce탵i numele utilizatorului 탳i parola, care sunt acelea탳i cu cele folosite la autentificare pe Hub. Dac캒 nu ave탵i 칥nc캒 un profil pe Hub, v캒 rug캒m s캒 crea탵i unul [aici](https://huggingface.co/join).

Excelent! Acum ave탵i tokenul de autentificare stocat 칥n folder-ul cache. Vom crea acum ni탳te repositorii!

{#if fw === 'pt'}

Dac캒 a탵i lucrat cu API-ul `Trainer` pentru a antrena un model, cea mai u탳oar캒 modalitate de a o 칥nc캒rca pe Hub este s캒 seta탵i `push_to_hub=True` c칙nd defini탵i `TrainingArguments`:

```py
from transformers import TrainingArguments

training_args = TrainingArguments(
    "bert-finetuned-mrpc", save_strategy="epoch", push_to_hub=True
)
```

C칙nd chema탵i `trainer.train()`, `Trainer` va 칥nc캒rca modelul pe Hub de fiecare dat캒 c칙nd este salvat (aici, la fiecare epoc캒) 칥ntr-un repository namespace-ul t캒u. Acest repository va fi numit dup캒 output directory-ul ales (aici `bert-finetuned-mrpc`), dar pute탵i alege un alt nume cu `hub_model_id = "un_nume_diferit"`.

Pentru a 칥nc캒rca modelul 칥ntr-o organiza탵ie din care face탵i parte, este suficient s캒 introduce탵i aceasta 칥n `hub_model_id = "organiza탵ia_mea/numele_repositoriului"`.

Odat캒 ce antrenarea s-a terminat, trebuie s캒 face탵i `trainer.push_to_hub()` pentru a 칥nc캒rca ultima versiune a modelului. Acesta va genera apoi un model card cu toate informa탵iile relevante, inclusiv metadatele despre hyperparametrii utiliza탵i 탳i rezultatele evalu캒rii! Aici este exemplul unui astfel de model card:

<div class="flex justify-center">
  <img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/model_card.png" alt="Un exemplu de un card auto-generat." width="100%"/>
</div>

{:else}

Dac캒 utiliza탵i Keras pentru a antrena modelul dumneavoastr캒, cea mai u탳oar캒 modalitate de a 칥nc캒rca-o pe Hub este s캒 transmite탵i un `PushToHubCallback` c칙nd chema탵i `model.fit()`:

```py
from transformers import PushToHubCallback

callback = PushToHubCallback(
    "bert-finetuned-mrpc", save_strategy="epoch", tokenizer=tokenizer
)
```

Apoi, ad캒uga탵i `callbacks=[callback]` 칥n apelul la `model.fit()`. Callback-ul va 칥nc캒rca apoi modelul pe Hub de fiecare dat캒 c칙nd se salveaz캒 (aici, la fiecare epoc캒) 칥ntr-un repository din namespace-ul t캒u. Acest repository va fi numit dup캒 output directory ales (aici `bert-finetuned-mrpc`), dar pute탵i alege un alt nume cu `hub_model_id = "un_nume_diferit"`.

Pentru a 칥nc캒rca modelul 칥ntr-o organiza탵ie din care face탵i parte, este suficient s캒 introduce탵i aceasta 칥n `hub_model_id = "organiza탵ia_mea/numele_repositoriului"`.

{/if}

La un nivel inferior, accesarea Hub-ului se poate face direct pe modele, tokenizers 탳i configurations objects prin metoda `push_to_hub()`. Aceast캒 metod캒 se ocup캒 at칙t de crearea repositoriului c칙t si de 칥nc캒rcarea modelului 탳i tokenizerului direct 칥n el. Nu este nevoie de o interac탵iune manual캒, precum fa탵a de API-ul pe care 칥l vom vedea mai jos.

Pentru a 칥n탵elege cum func탵ioneaz캒, lua탵i 칥n considerare ini탵ializarea unui model 탳i a unui tokenizer:

{#if fw === 'pt'}
```py
from transformers import AutoModelForMaskedLM, AutoTokenizer

checkpoint = "camembert-base"

model = AutoModelForMaskedLM.from_pretrained(checkpoint)
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
```
{:else}
```py
from transformers import TFAutoModelForMaskedLM, AutoTokenizer

checkpoint = "camembert-base"

model = TFAutoModelForMaskedLM.from_pretrained(checkpoint)
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
```
{/if}

Sunte탵i liberi s캒 face탵i orice a탵i vrea cu acestea - ad캒uga탵i tokens la tokenizer, antrena탵i modelul sau face탵i fine-tune. Odat캒 ce sunte탵i mul탵umi탵i de modelul ob탵inut, weighturile 탳i tokenizerul acestuia , pute탵i folosi metoda `push_to_hub()` disponibil캒 direct pe obiectul `model`:

```py
model.push_to_hub("dummy-model")
```
Acest lucru va crea un nou repository `dummy-model` 칥n profilul t캒u 탳i o va popula cu fi탳ierele modelului t캒u.
칉ncerca탵i acela탳i lucru cu tokenizerul, astfel 칥nc칙t toate fi탳ierele s캒 fie acum disponibile 칥n acest repository:

```py
tokenizer.push_to_hub("dummy-model")
```

Dac캒 apar탵ine탵i unei organiza탵ii, specifica탵i doar argumentul `organization` pentru a 칥nc캒rca 칥n namespace-ul acestei organiza탵ii:

```py
tokenizer.push_to_hub("dummy-model", organization="huggingface")
```

Dac캒 dori탵i s캒 utiliza탵i un anumit token Hugging Face, sunte탵i liberi s캒 specifica탵i acest lucru metodei `push_to_hub()`:

```py
tokenizer.push_to_hub("dummy-model", organization="huggingface", use_auth_token="<TOKEN>")
```

Acum, merge탵i la Model Hub pentru a g캒si modelul 칥nc캒rcat: *https://huggingface.co/user-or-organization/dummy-model*.

Ap캒sa탵i pe tabul "Files and versions", iar acum ar trebui s캒 vede탵i fi탳ierele vizibile 칥n urm캒torul screenshot:

{#if fw === 'pt'}
<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/push_to_hub_dummy_model.png" alt="Dummy model containing both the tokenizer and model files." width="80%"/>
</div>
{:else}
<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/push_to_hub_dummy_model_tf.png" alt="Dummy model containing both the tokenizer and model files." width="80%"/>
</div>
{/if}

> [!TIP]
> 九勇 **칉ncerca탵i!** Lua탵i modelul 탳i tokenizerul asociat cu checkpointul `bert-base-cased` 탳i 칥nc캒rca탵i-l pe un repo 칥n namespace-ul t캒u folosind metoda `push_to_hub()`. Verifica탵i c캒 repo-ul apare  칥n pagina dumneavoastr캒 칥nainte de a-l 탳terge.

A탵i v캒zut c캒 metoda `push_to_hub()` accept캒 mai multe argumente, ceea ce permite 칥nc캒rcarea 칥ntr-un repository specific sau namespace al unei organiza탵ii, sau utilizarea unui token API diferit. V캒 recomand캒m s캒 v캒 uita탵i la specifica탵ia metodei disponibil캒 direct 칥n [documenta탵ia 游뱅 Transformers](https://huggingface.co/transformers/model_sharing) pentru a 칥n탵elge ceea ce este posibil.

Metoda `push_to_hub()` este backed de packageul Python [`huggingface_hub`](https://github.com/huggingface/huggingface_hub), care ofer캒 un API direct la Hub-ul Hugging Face. Acesta este integrat 칥n 游뱅 Transformers 탳i 칥n mai multe biblioteci pentru machine learning, ca de exemplu [`allenlp`](https://github.com/allenai/allennlp). De탳i ne concentr캒m pe integrarea 칥n 游뱅 Transformers 칥n acest capitol, integrarea sa 칥n propriul dumneavoastr캒 cod sau bibliotec캒 este simplu.

S캒ri탵i la ultima sec탵iune pentru a vedea cum s캒 칥nc캒rca탵i fi탳ierele 칥n noul repository-ul creat!

## Utilizarea bibliotecii Python `huggingface_hub`[[using-the-huggingfacehub-python-library]]

Biblioteca Python `huggingface_hub` este un package care ofer캒 un set de instrumente pentru model 탳i datasets hubs. Ofer캒 metode simple 탳i clase pentru sarcini comune ca 
ob탵inerea informa탵iilor despre repositorii pe hub 탳i gestionarea lor. Ofer캒 API-uri simple care lucreaz캒 pe l칙ng캒 git pentru a gestiona con탵inutul acestor repositorii 탳i integrarea Hub-ului
칥n proiectele 탳i bibliotecile tale.

Similar cu utilizarea API-ului `push_to_hub`, asta va necesita un token de autentificare salvat 칥n cache. Pentru a face acest lucru, ve탵i avea nevoie s캒 folosi탵i comanda `login` din CLI, cum am men탵ionat 칥n sec탵iunea anterioar캒 (din nou, asigura탵i-v캒 prefixa탵i aceast캒 comand캒 cu simbolul `!` dac캒 rula탵i 칥n Google Colab):

```bash
huggingface-cli login
```

Packageul `huggingface_hub` ofer캒 mai multe metode 탳i clase utile pentru noi. 칉n primul r칙nd, exist캒 c칙teva metode pentru crearea, 탳tergerea 탳i gestionarea repositoriilor:

```python no-format
from huggingface_hub import (
    # Gestionarea utilizatorilor
    login,
    logout,
    whoami,

    # Crearea 탳i gestionarea repositoriilor
    create_repo,
    delete_repo,
    update_repo_visibility,

    # 탲i c칙teva metode pentru a ob탵ine/schimba informa탵iile despre con탵inut
    list_models,
    list_datasets,
    list_metrics,
    list_repo_files,
    upload_file,
    delete_file,
)
```




De asemenea, el ofer캒 clasa foarte puternic캒 `Repository` pentru gestionarea unei repository local. Vom explora aceste metode 탳i clasa 칥n urm캒toarele sec탵iuni pentru a 칥n탵elege cum s캒 le utiliza탵i.

Metoda `create_repo` poate fi utilizat캒 pentru crearea unui nou repository 칥n hub:

```py
from huggingface_hub import create_repo

create_repo("dummy-model")
```

Acesta va crea repositarul `dummy-model` 칥n namespace-ul t캒u. Dac캒 dori탵i, pute탵i specifica care organiza탵ie s캒 apar탵in캒 repositoriului folosind argumentul `organization`:

```py
from huggingface_hub import create_repo

create_repo("dummy-model", organization="huggingface")
```

Acesta va crea repositoriul `dummy-model` 칥n spa탵iul organiza탵iei `huggingface`, cu condi탵ia c캒 dumneavoastr캒 s캒 apartine탵i acestei organiza탵ii.
Alte argumente care pot fi utile sunt:

- `private`, pentru a specifica dac캒 repositarul trebuie s캒 fie vizibil celorla탵i sau nu.
- `token`, dac캒 dori탵i s캒 v캒 칥nlocui탵i token-ul stocat 칥n cache cu un anumit token.
- `repo_type`, dac캒 dori탵i s캒 crea탵i un `dataset` sau `space` 칥n loc de model. Valorile acceptate sunt `"dataset"` 탳i `"space"`.

Odat캒 ce repositoriul este creat, trebuie s캒 ad캒uga탵i fi탳ierele 칥n el! S캒ri탵i la sec탵iunea urm캒toare pentru a vedea cele trei moduri 칥n care se poate face acest lucru.

## Utilizarea interfe탵ei web[[using-the-web-interface]]

Interfa탵a web ofer캒 instrumente pentru a gestiona repositorii direct 칥n Hub. Cu ajutorul acestei interfe탵e, pute탵i crea u탳or repositorii, ad캒uga fi탳iere (탳i chiar 탳i fi탳iere mari!), explora modele, vizualiza diffuri, 탳i multe altele.

Pentru a crea un nou repositoriu, vizita탵i [huggingface.co/new](https://huggingface.co/new):

<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/new_model.png" alt="Pagin캒 care prezint캒 modelul utilizat pentru crearea unui nou repository." width="80%"/>
</div>

칉n primul r칙nd, specifica탵i de탵in캒torul repositoriului: acesta pute탵i fi fie dumneavoastr캒, fie orice organiza탵ie cu care sunte탵i afiliat. Dac캒 alege탵i o organiza탵ie, modelul va fi prezent pe pagina organiza탵iei 탳i to탵i membrii acesteia vor avea posibilitatea s캒 contribuie la repositoriu.

칉n al doilea r칙nd, introduce탵i numele modelului dumneavoastr캒. Acest lucru va fi 탳i denumirea repositoriului. 칉n final, pute탵i specifica dac캒 dori탵i ca modelul dumneavoastr캒 s캒 fie public sau privat. Modelele private nu sunt vizibile ceilorlal탵i.

Dup캒 crearea repositoriului, ar trebui s캒 vede탵i o pagin캒 ca aceasta:

<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/empty_model.png" alt="O pagin캒 goal캒 a modelului dup캒 crearea unui nou repository." width="80%"/>
</div>

Acesta este locul unde va fi g캒zduit modelul. Pentru a 칥ncepe s캒 popula탵i acesta, pute탵i ad캒uga un fi탳ier README direct din interfa탵a web.

<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/dummy_model.png" alt="Fi탳ierul README care arat캒 capacit캒탵ile Markdown." width="80%"/>
</div>

Fi탳ierul README este scris 칥n format Markdown - v캒 rug캒m s캒 fi탵i creativi cu el! A treia parte a acestui capitol se ocup캒 de crearea unui model card. Acestea sunt foarte importante pentru a aduce valoare modelului dumneavoastr캒, deoarece este acolo unde spune탵i celorlal탵i ce poate face.

Dac캒 v캒 uita탵i la sec탵iunea "Fi탳iere 탳i versiuni", ve탵i vedea c캒 nu sunt prea multe fi탳iere acolo 칥nc캒 - doar *README.md* pe care l-a탵i creat dumneavoastr캒 탳i *.gitattributes* care urm캒re탳te fi탳ierele mari.

<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/files.png" alt="Sec탵iunea 'Fi탳iere 탳i versiuni' arat캒 doar fi탳ierul .gitattributes 탳i README.md." width="80%"/>
</div>

Vom vedea mai t칙rziu cum s캒 ad캒uga탵i c칙teva fi탳iere noi.

## 칉nc캒rcarea fi탳ierelor modelului[[uploading-the-model-files]]

Sistemul pentru a gestiona fi탳ierele 칥n Hugging Face Hub se bazeaz캒 pe git pentru fi탳ierele obi탳nuite, 탳i pe git-lfs (care se descrifreaz캒 ca [Git Large File Storage](https://git-lfs.github.com/)) pentru fi탳ierele mai mari.

칉n sec탵iunea urm캒toare, vom discuta despre trei metode diferite de 칥nc캒rcare a fi탳ierelor 칥n Hub: prin `huggingface_hub` 탳i prin comanda git.

### Metoda `upload_file`[[the-uploadfile-approach]]

Prin `upload_file` nu este necesar s캒 instala탵i git 탳i git-lfs pe sistemul dumneavoastr캒. Acest lucru 칥ncarc캒 direct fi탳ierele 칥n 游뱅 Hub folosind HTTP POST requests. O limitare a acestei metode este c캒 ea nu se ocup캒 de fi탳iere care sunt mai mari de 5GB.
Dac캒 fi탳ierele dumneavoastr캒 sunt mai mari dec칙t 5 GB, v캒 rug캒m s캒 urma탵i celelalte dou캒 metode descrise mai jos.

API-ul poate fi folosit astfel:

```py
from huggingface_hub import upload_file

upload_file(
    "<path_to_file>/config.json",
    path_in_repo="config.json",
    repo_id="<namespace>/dummy-model",
)
```

Acest lucru va 칥nc캒rca fi탳ierul `config.json` disponibil la `<path_to_file>` la rootul repositoriului ca `config.json`, 칥n `dummy-model` repository.
Alte argumente utile pot fi:

- `token`, dac캒 dori탵i s캒 칥nlocui탵i tokenul stocat 칥n cache cu un alt token.
- `repo_type`, dac캒 dori탵i s캒 칥nc캒rca탵i 칥ntr-un `dataset` sau 칥ntr-un `space` 칥n locul modelului. Valorile acceptate sunt `"dataset"` 탳i `"space"`.

### Clasa `Repository`[[the-repository-class]]

Clasa `Repository` gestioneaz캒 un repository local 칥n-tro manier캒 asem캒n캒toare gitului. Ea abstrac탵ioneaz캒 majoritatea problemelor pe care le 칥nt칙lni탵i cu git pentru a oferi toate caracteristicile necesare.

Utilizarea acestei clase necesit캒 ca dumneavoastr캒 s캒 ave탵i instalat git 탳i git-lfs, a탳adar asigura탵i-v캒 c캒 ave탵i instalat git-lfs (vezi [aici](https://git-lfs.github.com/) pentru instruc탵iunile de instalare) 탳i setat 칥nainte de a 칥ncepe.

Pentru a v캒 juca cu repositoriul pe care l-am creat, pute탵i porni prin ini탵ializarea lui ca un folder local printr-un clonarea repositoriului remote:

```py
from huggingface_hub import Repository

repo = Repository("<path_to_dummy_folder>", clone_from="<namespace>/dummy-model")
```

Acesta a creat folderele `<path_to_dummy_folder>` 칥n folderul de lucru. Acest folder con탵ine doar fi탳ierul `.gitattributes` pentru c캒 acesta este singurul fi탳ier creat atunci c칙nd ini탵ializa탵i repositoriul prin `create_repo`.

Acum pute탵i folosi majoritatea metodelor tradi탵ionale ale gitului:

```py
repo.git_pull()
repo.git_add()
repo.git_commit()
repo.git_push()
repo.git_tag()
```

탲i altele! V캒 recomand캒m s캒 v캒 uita탵i la documenta탵ia `Repository` disponibil캒 [aici](https://github.com/huggingface/huggingface_hub/tree/main/src/huggingface_hub#advanced-programmatic-repository-management) pentru o 칥n탵elegere general캒 a tuturor metodelor disponibile.

Pentru moment, avem un model 탳i un tokenizer pe care dori탵i s캒 칥l trimite탵i 칥n hub. Am reu탳it s캒 clon캒m repositoriul local, deci putem salva fi탳ierele 칥n acesta.

칉n primul r칙nd asigura탵i-v캒 c캒 copia local캒 este la zi cu ultimele schimb캒ri:

```py
repo.git_pull()
```

Odat캒 ce am facut asta, salva탵i fi탳ierele modelului 탳i al tokenizerul:

```py
model.save_pretrained("<path_to_dummy_folder>")
tokenizer.save_pretrained("<path_to_dummy_folder>")
```

Folder-ul `<path_to_dummy_folder>` acum con탵ine toate fi탳ierele modelului dumneavoastr캒 탳i ale tokenizerul. Vom urma fluxul tradi탵ional de git ad캒ug칙nd fi탳iere 칥n zona de preg캒tire, f캒c칙nd commit 탳i push fi탳ierelor 칥n hub:

```py
repo.git_add()
repo.git_commit("Ad캒ugarea fi탳ierelor modelului 탳i ale tokenizerului")
repo.git_push()
```

Felicit캒ri! A탵i reu탳it s캒 칥nc캒rca탵i primele fi탳iere 칥n hub.

### Folosirea Git[[the-git-based-approach]]

Acesta este abordarea cea mai de baz캒 pentru 칥nc캒rcarea fi탳ierelor: vom face asta cu ajutorul git 탳i git-lfs direct. Cea mai grea parte este abstractizat캒 prin abord캒ri anterioare, dar exist캒 c칙teva excep탵ii cu metoda urm캒toare, a탳adar ne vom referi la un use-case mai complicat.

Pentru aceast캒 clas캒 se cere s캒 ave탵i instalate git 탳i git-lfs, a탳adar asigura탵i-v캒 c캒 ave탵i [git-lfs](https://git-lfs.github.com/) instalat (vede탵i aici instruc탵iunile de instalare) 탳i configurat 칥nainte s캒 칥ncepe탵i.

칉n primul r칙nd, ini탵ializa탵i git-lfs:

```bash
git lfs install
```

```bash
Updated git hooks.
Git LFS initialized.
```

Dup캒 ce a탵i f캒cut acest lucru, primul pas este s캒 face탵i o copie a repositoriului dumneavoastr캒:

```bash
git clone https://huggingface.co/<namespace>/<your-model-id>
```

Numele meu de utilizator este `lysandre` 탳i am folosit numele modelului `dummy`, a탳adar comanda mea se termin캒 cu urm캒torul rezultat:

```
git clone https://huggingface.co/lysandre/dummy
```

Acum am un folder denumit *dummy* 칥n folderul meu de lucru. Pot intra 칥n folder cu ajutorul `cd` 탳i pot examina con탵inutul:

```bash
cd dummy && ls
```

```bash
README.md
```

Dac캒 a탵i creat repositoriul dumneavoastr캒 folosind metod캒 din partea Hugging Face Hub, `create_repo` , acest folder ar trebui s캒 con탵in캒 doar un fi탳ier cu numele *.gitattributes*. Dac캒 a탵i urmat instruc탵iunile din sec탵iunea anterioar캒 pentru crearea repositoriului folosind interfa탵a web, atunci folderul ar trebui s캒 con탵in캒 un singur fi탳ier *README.md* 탳i, de asemenea, un fi탳ier cu numele *.gitattributes*, pe care nu-l pute탵i vedea.

Ad캒ugarea unui fi탳ier de m캒rime obi탳nuit캒, precum un fi탳ier de configurare, un vocabulary file sau orice alt tip de fi탳ier care au mai pu탵in de c칙탵iva megabytes se realizeaz캒 exact a탳a cum a탵i face 칥n orice sistem git. Cu toate acestea, pentru a 칥nc캒rca fi탳iere mai mari, este necesar캒 utilizarea a git-lfs pentru a le trimite spre *huggingface.co*.

S캒 ne 칥ntoarcem la Python pentru a genera un model 탳i tokenizer pe care am dori s캒 le facem commit 칥n repositoriul nostru dummy:

{#if fw === 'pt'}
```py
from transformers import AutoModelForMaskedLM, AutoTokenizer

checkpoint = "camembert-base"

model = AutoModelForMaskedLM.from_pretrained(checkpoint)
tokenizer = AutoTokenizer.from_pretrained(checkpoint)

# Face탵i orice cu modelul, antrena탵i-l, aplica탵i fine-tuning...

model.save_pretrained("<path_to_dummy_folder>")
tokenizer.save_pretrained("<path_to_dummy_folder>")
```
{:else}
```py
from transformers import TFAutoModelForMaskedLM, AutoTokenizer

checkpoint = "camembert-base"

model = TFAutoModelForMaskedLM.from_pretrained(checkpoint)
tokenizer = AutoTokenizer.from_pretrained(checkpoint)

# Face탵i orice cu modelul, antrena탵i-l, aplica탵i fine-tuning...

model.save_pretrained("<path_to_dummy_folder>")
tokenizer.save_pretrained("<path_to_dummy_folder>")
```
{/if}

Acum am salvat c칙teva artefacte de model 탳i tokenizer, a탳adar s캒 examin캒m din nou folderul *dummy*:

```bash
ls
```

{#if fw === 'pt'}
```bash
config.json  pytorch_model.bin  README.md  sentencepiece.bpe.model  special_tokens_map.json tokenizer_config.json  tokenizer.json
```
Dac캒 privi탵i la dimensiunile fi탳ierelor (de exemplu, folosind `ls -lh`), ar trebui s캒 vede탵i c캒 singurul outlier este model state dict file (*pytorch_model.bin*), care are mai mult de 400 MB.

{:else}
```bash
config.json  README.md  sentencepiece.bpe.model  special_tokens_map.json  tf_model.h5  tokenizer_config.json  tokenizer.json
```
Dac캒 privi탵i la dimensiunile fi탳ierelor (de exemplu, folosind `ls -lh`), ar trebui s캒 vede탵i c캒 singurul outlier este model state dict file (*tf_model.h5*), care are mai mult de 400 MB.

{/if}

> [!TIP]
> 九勇 Dac캒 crea탵i repositoriul folosind interfa탵a web, fi탳ierul *.gitattributes* va fi automat configurat pentru a considera anumite extensii de fi탳iere, precum *.bin* 탳i *.h5*, ca fiind fi탳iere mari. 칉n acest caz nu este necesar캒 nici o setare suplimentar캒 din partea ta, pentru c캒 git-lfs le va urm캒ri automat.

Acum putem continua procesul 칥n felul nostru obi탳nuit cu repositoriurile Git tradi탵ionale. Putem ad캒uga toate fi탳ierele 칥n mediul de stocare a Git folosind comanda `git add`:

```bash
git add .
```

Pute탵i verifica fi탳ierele curente care sunt 칥n stare de stocare utiliz칙nd urm캒toarea comand캒:

```bash
git status
```


{#if fw === 'pt'}
```bash
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
  modified:   .gitattributes
	new file:   config.json
	new file:   pytorch_model.bin
	new file:   sentencepiece.bpe.model
	new file:   special_tokens_map.json
	new file:   tokenizer.json
	new file:   tokenizer_config.json
```
{:else}
```bash
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
  modified:   .gitattributes
	new file:   config.json
	new file:   sentencepiece.bpe.model
	new file:   special_tokens_map.json
	new file:   tf_model.h5
	new file:   tokenizer.json
	new file:   tokenizer_config.json
```
{/if}

De asemenea, putem verifica dac캒 git-lfs monitorizeaz캒 fisierele corecte folosind comanda sa `status`:

```bash
git lfs status
```


{#if fw === 'pt'}
```bash
On branch main
Objects to be pushed to origin/main:


Objects to be committed:

	config.json (Git: bc20ff2)
	pytorch_model.bin (LFS: 35686c2)
	sentencepiece.bpe.model (LFS: 988bc5a)
	special_tokens_map.json (Git: cb23931)
	tokenizer.json (Git: 851ff3e)
	tokenizer_config.json (Git: f0f7783)

Objects not staged for commit:


```

Vom observa c캒 toate fi탳ierele au `Git` ca handler, cu excep탵ia *pytorch_model.bin* 탳i *sentencepiece.bpe.model*, care au `LFS`. Excelent!

{:else}
```bash
On branch main
Objects to be pushed to origin/main:


Objects to be committed:

	config.json (Git: bc20ff2)
	sentencepiece.bpe.model (LFS: 988bc5a)
	special_tokens_map.json (Git: cb23931)
	tf_model.h5 (LFS: 86fce29)
	tokenizer.json (Git: 851ff3e)
	tokenizer_config.json (Git: f0f7783)

Objects not staged for commit:


```

Observ캒m c캒 toate fi탳ierele au `Git` ca handler, cu excep탵ia *tf_model.h5*, care are `LFS`. Excelent!

{/if}

Acum vom continua cu ultimii pa탳i: commiting 탳i pushing la repo-urile *huggingface.co*:

```
git commit -m "Prima versiune a modelului"
```


{#if fw === 'pt'}
```bash
[main b08aab1] Prima versiune a modelului
 7 files changed, 29027 insertions(+)
  6 files changed, 36 insertions(+)
 create mode 100644 config.json
 create mode 100644 pytorch_model.bin
 create mode 100644 sentencepiece.bpe.model
 create mode 100644 special_tokens_map.json
 create mode 100644 tokenizer.json
 create mode 100644 tokenizer_config.json
```
{:else}
```bash
[main b08aab1] Prima versiune a modelului
 6 files changed, 36 insertions(+)
 create mode 100644 config.json
 create mode 100644 sentencepiece.bpe.model
 create mode 100644 special_tokens_map.json
 create mode 100644 tf_model.h5
 create mode 100644 tokenizer.json
 create mode 100644 tokenizer_config.json
```
{/if}

Pushingul poate lua c칙teva minute, 칥n func탵ie de viteza conexiunii tale la internet 탳i m캒rimea fi탳ierelor:

```bash
git push
```

```bash
Uploading LFS objects: 100% (1/1), 433 MB | 1.3 MB/s, done.
Enumerating objects: 11, done.
Counting objects: 100% (11/11), done.
Delta compression using up to 12 threads
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 288.27 KiB | 6.27 MiB/s, done.
Total 9 (delta 1), reused 0 (delta 0), pack-reused 0
To https://huggingface.co/lysandre/dummy
   891b41d..b08aab1  main -> main
```

{#if fw === 'pt'}
Dac캒 ne uit캒m la repositoriul modelului c칙nd acest lucru este finalizat, putem vedea toate fi탳ierele recent ad캒ugate:

<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/full_model.png" alt="Tabul 'Files and versions' con탵ine acum toate fi탳ierele recente ad캒ugate." width="80%"/>
</div>

Interfa탵a permite explorarea fi탳ierelor modelului 탳i a commiturilor 탳i vizualizarea diferen탵ei introduse de fiecare commit:

<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/diffs.gif" alt="Diferen탵a introdus캒 de ultimul commit." width="80%"/>
</div>
{:else}
Dac캒 ne uit캒m la repositoriul modelului c칙nd acest lucru este finalizat, putem vedea toate fi탳ierele recent ad캒ugate:

<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/full_model_tf.png" alt="Tabul 'Files and versions' con탵ine acum toate fi탳ierele recente ad캒ugate." width="80%"/>
</div>

Interfa탵a permite explorarea fi탳ierelor modelului 탳i a commiturilor 탳i vizualizarea diferen탵ei introduse de fiecare commit:

<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/diffstf.gif" alt="Diferen탵a introdus캒 de ultimul commit." width="80%"/>
</div>
{/if}
