# Introducere[[introducere]]

<CourseFloatingBanner
    chapter={6}
    classNames="absolute z-10 right-0 top-0"
/>

În [Capitolul 3](/course/chapter3), am examinat cum să facem fine-tune unui model pentru o anumită sarcină. Când facem acest lucru, utilizăm același tokenizer cu care modelul a fost antrenat - dar ce facem când dorim să antrenăm un model de la zero? În așa cazuri, utilizarea unui tokenizer care a fost antrenat pe un corpus dintr-un alt domeniu sau limbă este, de obicei, suboptimal. De exemplu, un tokenizer antrenat pe un corpus în limba engleză va funcționa rău pe un corpus de texte în limba japoneză, deoarece utilizarea spațiilor și a punctuației este foarte diferită în cele două limbi.

În acest capitol, veți învăța cum să antrenați un tokenizer complet nou pe un corpus de texte, astfel încât să poată fi utilizat pentru a antrena un model de limbaj. Acest lucru va fi realizat cu ajutorul bibliotecii [🤗 Tokenizers](https://github.com/huggingface/tokenizers), care oferă tokenizerii "rapizi" din biblioteca [🤗 Transformers](https://github.com/huggingface/transformers). Vom examina îndeaproape caracteristicile pe care această bibliotecă le oferă și vom explora cum tokenizatorii rapizi diferă de versiunile "lente".

Subiectele pe care le vom acoperi includ:

* Cum să antrenați un tokenizer nou, similar celui utilizat de un anumit checkpoint pe un corpus nou de texte
* Caracteristicile speciale ale tokenizerilor rapizi
* Diferențele dintre cei trei algoritmi principali de subword tokenization utilizate în NLP în prezent
* Cum să construiți un tokenizer de la zero cu biblioteca 🤗 Tokenizers și să îl antrenați pe anumite date

Tehnicile prezentate în acest capitol vă vor pregăti pentru secțiunea din [Capitolul 7](/course/chapter7/6), unde vom examina crearea unui model de limbaj pentru codul sursă Python. Să începem prin a explora ce înseamnă să "antrenați" un tokenizer în primul rând.
