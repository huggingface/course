```mdx
<FrameworkSwitchCourse {fw} />

# باب کے اختتام کا کوئز[[end-of-chapter-quiz]]

<CourseFloatingBanner
    chapter={3}
    classNames="absolute z-10 right-0 top-0"
/>

اس باب میں آپ نے جو کچھ سیکھا اسے آزمائیں!

### 1. `emotion` ڈیٹاسیٹ میں جذبات کے ساتھ ٹیگ کی گئی Twitter پیغامات شامل ہیں۔ [Hub](https://huggingface.co/datasets) میں اسے تلاش کریں اور ڈیٹاسیٹ کارڈ پڑھیں۔ ان میں سے کون سا اس کے بنیادی جذبات میں سے نہیں ہے؟

<Question
	choices={[
		{
			text: "Joy",
			explain: "دوبارہ کوشش کریں — یہ جذبہ اس ڈیٹاسیٹ میں موجود ہے!"
		},
		{
			text: "Love",
			explain: "دوبارہ کوشش کریں — یہ جذبہ اس ڈیٹاسیٹ میں موجود ہے!"
		},
		{
			text: "Confusion",
			explain: "درست! Confusion چھ بنیادی جذبات میں سے نہیں ہے.",
            correct: true
		},
        {
			text: "Surprise",
			explain: "Surprise! دوبارہ کوشش کریں!"
		}
	]}
/>

### 2. [Hub](https://huggingface.co/datasets) میں `ar_sarcasm` ڈیٹاسیٹ تلاش کریں۔ یہ کس ٹاسک کی حمایت کرتا ہے؟

<Question
	choices={[
		{
			text: "Sentiment classification",
			explain: "درست! آپ ٹیگز کی بدولت یہ جان سکتے ہیں.",
            correct: true
		},
		{
			text: "Machine translation",
			explain: "یہ صحیح نہیں — <a href='https://huggingface.co/datasets/ar_sarcasm'>ڈیٹاسیٹ کارڈ</a> پر دوبارہ نظر ڈالیں!"
		},
		{
			text: "Named entity recognition",
			explain: "یہ صحیح نہیں — <a href='https://huggingface.co/datasets/ar_sarcasm'>ڈیٹاسیٹ کارڈ</a> پر دوبارہ نظر ڈالیں!"
		},
        {
			text: "Question answering",
			explain: "افسوس، اس سوال کا درست جواب نہیں دیا گیا. دوبارہ کوشش کریں!"
		}
	]}
/>

### 3. BERT ماڈل ایک جملے کے جوڑے کو کس شکل میں process کرنے کی توقع رکھتا ہے؟

<Question
	choices={[
		{
			text: "Tokens_of_sentence_1 [SEP] Tokens_of_sentence_2",
			explain: "<code>[SEP]</code> خصوصی ٹوکن دونوں جملوں کو الگ کرنے کے لیے درکار ہوتا ہے، مگر یہ واحد چیز نہیں ہے!"
		},
		{
			text: "[CLS] Tokens_of_sentence_1 Tokens_of_sentence_2",
			explain: "آغاز میں <code>[CLS]</code> خصوصی ٹوکن درکار ہوتا ہے، مگر یہ واحد چیز نہیں ہے!"
		},
		{
			text: "[CLS] Tokens_of_sentence_1 [SEP] Tokens_of_sentence_2 [SEP]",
			explain: "درست ہے!",
            correct: true
		},
        {
			text: "[CLS] Tokens_of_sentence_1 [SEP] Tokens_of_sentence_2",
			explain: "آغاز میں <code>[CLS]</code> خصوصی ٹوکن اور دونوں جملوں کو الگ کرنے کے لیے <code>[SEP]</code> خصوصی ٹوکن درکار ہیں، مگر یہ سب کچھ نہیں!"
		}
	]}
/>

{#if fw === 'pt'}
### 4. `Dataset.map()` میتھڈ کے کیا فوائد ہیں؟

<Question
	choices={[
		{
			text: "فنکشن کے نتائج cache کر لیے جاتے ہیں، لہٰذا اگر ہم کوڈ دوبارہ چلائیں تو اس میں کوئی وقت نہیں لگے گا.",
			explain: "بلاشبہ یہ اس میتھڈ کا ایک عمدہ فائدہ ہے! مگر یہ واحد فائدہ نہیں ہے...",
            correct: true
		},
		{
			text: "یہ ملٹی پروسیسنگ کا استعمال کر سکتا ہے تاکہ ڈیٹاسیٹ کے ہر عنصر پر فنکشن لگانے سے تیز چل سکے.",
			explain: "یہ اس میتھڈ کی ایک عمدہ خصوصیت ہے، مگر یہ واحد خصوصیت نہیں ہے!",
            correct: true
		},
		{
			text: "یہ پورے ڈیٹاسیٹ کو میموری میں لوڈ نہیں کرتا، بلکہ جیسے ہی ایک عنصر پراسیس ہوتا ہے نتائج کو محفوظ کر لیتا ہے.",
			explain: "یہ اس میتھڈ کا ایک فائدہ ہے. تاہم، اور بھی فائدے ہیں!",
            correct: true
		},
	]}
/>

### 5. ڈائنامک padding کا کیا مطلب ہے؟

<Question
	choices={[
		{
			text: "یہ تب ہوتا ہے جب آپ ہر بیچ کے ان پٹس کو پورے ڈیٹاسیٹ کی زیادہ سے زیادہ لمبائی تک pad کر دیتے ہیں.",
			explain: "یہ بیچ بناتے وقت padding کا مطلب ہے، مگر پورے ڈیٹاسیٹ کی زیادہ سے زیادہ لمبائی تک نہیں."
		},
		{
			text: "یہ تب ہوتا ہے جب آپ بیچ بناتے وقت اپنے ان پٹس کو اُس بیچ کے اندر موجود جملوں کی زیادہ سے زیادہ لمبائی تک pad کر دیتے ہیں.",
			explain: "درست ہے! \"ڈائنامک\" حصہ اس حقیقت سے آتا ہے کہ ہر بیچ کا سائز اُس کے بننے پر طے ہوتا ہے، اور نتیجے کے طور پر آپ کے بیچز مختلف شکلیں اختیار کر سکتے ہیں.",
            correct: true
		},
		{
			text: "یہ تب ہوتا ہے جب آپ اپنے ان پٹس کو اس طرح pad کر دیتے ہیں کہ ہر جملے میں پچھلے جملے کے برابر ٹوکن ہوں.",
			explain: "یہ غلط ہے، اور مزید یہ کہ ڈیٹاسیٹ میں ترتیب دیکھنا معنی نہیں رکھتا کیونکہ ہم ٹریننگ کے دوران shuffle کرتے ہیں."
		},
	]}
/>

### 6. collate function کا مقصد کیا ہے؟

<Question
	choices={[
		{
			text: "یہ اس بات کو یقینی بناتا ہے کہ ڈیٹاسیٹ میں موجود تمام سیکوئنسز کی لمبائی ایک جیسی ہو.",
			explain: "collate function انفرادی بیچز کو سنبھالنے میں شامل ہوتی ہے، نہ کہ پورے ڈیٹاسیٹ میں. مزید برآں، ہم generic collate functions کی بات کر رہے ہیں، خاص طور پر <code>DataCollatorWithPadding</code> نہیں."
		},
		{
			text: "یہ بیچ میں موجود تمام samples کو اکٹھا کرتی ہے.",
			explain: "درست! آپ collate function کو <code>DataLoader</code> کے آرگیومنٹ کے طور پر پاس کر سکتے ہیں. ہم نے <code>DataCollatorWithPadding</code> استعمال کیا، جو بیچ میں موجود تمام items کو اس طرح pad کرتا ہے کہ ان کی لمبائی ایک جیسی ہو.",
            correct: true
		},
		{
			text: "یہ پورے ڈیٹاسیٹ کی preprocessing کرتی ہے.",
			explain: "یہ ایک preprocessing function ہوگا، collate function نہیں."
		},
        {
			text: "یہ ڈیٹاسیٹ میں موجود سیکوئنسز کو truncate کر دیتی ہے.",
			explain: "collate function انفرادی بیچز کو سنبھالنے میں شامل ہوتی ہے، نہ کہ پورے ڈیٹاسیٹ میں. اگر آپ truncating میں دلچسپی رکھتے ہیں، تو آپ <code>tokenizer</code> کے <code>truncate</code> آرگیومنٹ کا استعمال کر سکتے ہیں."
		}
	]}
/>

### 7. جب آپ کسی `AutoModelForXxx` کلاس کو ایک pretrained language model (جیسے `bert-base-uncased`) کے ساتھ instantiate کرتے ہیں جو اُس کام سے مختلف ہے جس کے لیے وہ تربیت یافتہ تھا، تو کیا ہوتا ہے؟

<Question
	choices={[
		{
			text: "کچھ نہیں، مگر آپ کو وارننگ ملتی ہے.",
			explain: "آپ کو وارننگ ضرور ملتی ہے، مگر یہ سب کچھ نہیں ہے!"
		},
		{
			text: "pretrained ماڈل کا head نکال دیا جاتا ہے اور اس کی جگہ کام کے مطابق نیا head insert کر دیا جاتا ہے.",
			explain: "درست. مثال کے طور پر، جب ہم نے <code>AutoModelForSequenceClassification</code> کو <code>bert-base-uncased</code> کے ساتھ استعمال کیا، تو ماڈل instantiate کرتے وقت وارننگز ملیں. pretrained head سیکوئنس کلاسفکیشن ٹاسک کے لیے استعمال نہیں ہوتا، لہٰذا اسے نکال دیا جاتا ہے اور اس کی جگہ نیا head random weights کے ساتھ instantiate کیا جاتا ہے.",
            correct: true
		},
		{
			text: "pretrained ماڈل کا head نکال دیا جاتا ہے.",
			explain: "کچھ اور بھی ہونا چاہیے. دوبارہ کوشش کریں!"
		},
        {
			text: "کچھ نہیں، کیونکہ ماڈل پھر بھی مختلف ٹاسک کے لیے fine-tune کیا جا سکتا ہے.",
			explain: "pretrained ماڈل کا head اس ٹاسک کو حل کرنے کے لیے تربیت یافتہ نہیں تھا، لہٰذا ہمیں head کو discard کرنا چاہیے!"
		}
	]}
/>

### 8. `TrainingArguments` کا مقصد کیا ہے؟

<Question
	choices={[
		{
			text: "یہ تمام hyperparameters کو شامل کرتا ہے جو <code>Trainer</code> کے ساتھ training اور evaluation کے لیے استعمال ہوتے ہیں.",
			explain: "درست!",
            correct: true
		},
		{
			text: "یہ ماڈل کا سائز متعین کرتا ہے.",
			explain: "ماڈل کا سائز ماڈل configuration کے ذریعے متعین کیا جاتا ہے، نہ کہ <code>TrainingArguments</code> کے ذریعے."
		},
		{
			text: "یہ صرف evaluation کے لیے استعمال ہونے والے hyperparameters کو شامل کرتا ہے.",
			explain: "مثال میں، ہم نے بتایا کہ ماڈل اور اس کے checkpoints کہاں محفوظ کیے جائیں گے. دوبارہ کوشش کریں!"
		},
        {
			text: "یہ صرف training کے لیے استعمال ہونے والے hyperparameters کو شامل کرتا ہے.",
			explain: "مثال میں، ہم نے <code>evaluation_strategy</code> بھی استعمال کیا، لہٰذا اس کا evaluation پر اثر پڑتا ہے. دوبارہ کوشش کریں!"
		}
	]}
/>

### 9. آپ کو 🤗 Accelerate لائبریری کیوں استعمال کرنی چاہیے؟

<Question
	choices={[
		{
			text: "یہ تیز ماڈلز تک رسائی فراہم کرتی ہے.",
			explain: "نہیں، 🤗 Accelerate لائبریری کسی بھی ماڈل کی فراہمی نہیں کرتی."
		},
		{
			text: "یہ ایک high-level API فراہم کرتی ہے تاکہ مجھے اپنا training loop implement نہ کرنا پڑے.",
			explain: "یہ وہی ہے جو ہم نے <code>Trainer</code> کے ساتھ کیا، نہ کہ 🤗 Accelerate کے ساتھ. دوبارہ کوشش کریں!"
		},
		{
			text: "یہ ہمارے training loops کو distributed strategies پر کام کرنے کے قابل بناتی ہے.",
			explain: "درست! 🤗 Accelerate کے ساتھ، آپ کے training loops متعدد GPUs اور TPUs پر کام کریں گے.",
            correct: true
		},
        {
			text: "یہ مزید optimization functions فراہم کرتی ہے.",
			explain: "نہیں، 🤗 Accelerate لائبریری کسی بھی optimization functions کی فراہمی نہیں کرتی."
		}
	]}
/>

{:else}
### 4. جب آپ کسی `TFAutoModelForXxx` کلاس کو ایک pretrained language model (جیسے `bert-base-uncased`) کے ساتھ instantiate کرتے ہیں جو اُس کام سے مختلف ہے جس کے لیے وہ تربیت یافتہ تھا، تو کیا ہوتا ہے؟

<Question
	choices={[
		{
			text: "کچھ نہیں، مگر آپ کو وارننگ ملتی ہے.",
			explain: "آپ کو وارننگ ضرور ملتی ہے، مگر یہ سب کچھ نہیں ہے!"
		},
		{
			text: "pretrained ماڈل کا head نکال دیا جاتا ہے اور اس کی جگہ کام کے مطابق نیا head insert کر دیا جاتا ہے.",
			explain: "درست. مثال کے طور پر، جب ہم نے <code>TFAutoModelForSequenceClassification</code> کو <code>bert-base-uncased</code> کے ساتھ استعمال کیا، تو ماڈل instantiate کرتے وقت وارننگز ملیں. pretrained head سیکوئنس کلاسفکیشن ٹاسک کے لیے استعمال نہیں ہوتا، لہٰذا اسے نکال دیا جاتا ہے اور اس کی جگہ نیا head random weights کے ساتھ instantiate کیا جاتا ہے.",
            correct: true
		},
		{
			text: "pretrained ماڈل کا head نکال دیا جاتا ہے.",
			explain: "کچھ اور بھی ہونا چاہیے. دوبارہ کوشش کریں!"
		},
        {
			text: "کچھ نہیں، کیونکہ ماڈل پھر بھی مختلف ٹاسک کے لیے fine-tune کیا جا سکتا ہے.",
			explain: "pretrained ماڈل کا head اس ٹاسک کو حل کرنے کے لیے تربیت یافتہ نہیں تھا، لہٰذا ہمیں head کو discard کرنا چاہیے!"
		}
	]}
/>

### 5. `transformers` سے TensorFlow ماڈلز پہلے ہی Keras ماڈلز ہیں۔ اس کا کیا فائدہ ہے؟

<Question
	choices={[
		{
			text: "ماڈلز بغیر کسی تبدیلی کے TPU پر کام کرتے ہیں.",
			explain: "تقریباً! کچھ چھوٹی اضافی تبدیلیاں درکار ہوتی ہیں. مثال کے طور پر، آپ کو سب کچھ ایک <code>TPUStrategy</code> scope میں چلانا ہوتا ہے، جس میں ماڈل کی initialization بھی شامل ہے."
		},
		{
			text: "آپ موجودہ طریقوں جیسے کہ <code>compile()</code>, <code>fit()</code>, اور <code>predict()</code> کا فائدہ اٹھا سکتے ہیں.",
			explain: "درست! ایک بار جب آپ کے پاس ڈیٹا ہو جائے، اس پر تربیت کرنے میں بہت کم کام لگتا ہے.",
            correct: true
		},
		{
			text: "آپ کو Keras کے ساتھ ساتھ transformers بھی سیکھنے کو ملتے ہیں.",
			explain: "درست، مگر ہم کچھ اور تلاش کر رہے ہیں :)",
			correct: true
		},
        {
			text: "آپ آسانی سے ڈیٹاسیٹ سے متعلق میٹرکس کمپیوٹ کر سکتے ہیں.",
			explain: "Keras ہماری مدد training اور ماڈل کی evaluation میں کرتا ہے، نہ کہ ڈیٹاسیٹ سے متعلق میٹرکس کمپیوٹ کرنے میں."
		}
	]}
/>

### 6. آپ اپنا custom metric کیسے تعریف کر سکتے ہیں؟

<Question
	choices={[
		{
			text: "tf.keras.metrics.Metric کو subclass کر کے.",
			explain: "بہت اچھا!",
			correct: true
		},
		{
			text: "Keras functional API کا استعمال کر کے.",
			explain: "دوبارہ کوشش کریں!"
		},
		{
			text: "ایک callable استعمال کر کے جس کا signature <code>metric_fn(y_true, y_pred)</code> ہو.",
			explain: "درست!",
			correct: true
		},
        {
			text: "گوگل کر کے.",
			explain: "یہ وہ جواب نہیں جس کی ہمیں تلاش ہے، مگر یہ آپ کی مدد کر سکتا ہے اسے تلاش کرنے میں.",
			correct: true
		}
	]}
/>

{/if}
```