<FrameworkSwitchCourse {fw} />

# è³ªå•å¿œç­”

{#if fw === 'pt'}

<DocNotebookDropdown
  classNames="absolute z-10 right-0 top-0"
  options={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter7/section7_pt.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter7/section7_pt.ipynb"},
]} />

{:else}

<DocNotebookDropdown
  classNames="absolute z-10 right-0 top-0"
  options={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter7/section7_tf.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter7/section7_tf.ipynb"},
]} />

{/if}

è³ªå•å¿œç­”ã«ã¤ã„ã¦è€ƒãˆã‚‹æ™‚ãŒæ¥ã¾ã—ãŸã€‚ã“ã®ã‚¿ã‚¹ã‚¯ã«ã¯å¤šãã®ç¨®é¡ãŒã‚ã‚Šã¾ã™ãŒã€ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§å–ã‚Šä¸Šã’ã‚‹ã®ã¯ã€Œ *æŠ½å‡ºçš„* ãªè³ªå•å¿œç­”ã€ã§ã™ã€‚ã“ã‚Œã¯ã€ç‰¹å®šã®æ–‡æ›¸ã«ã¤ã„ã¦ã®è³ªå•ã‚’æŠ•ã’ã‹ã‘ã€æ–‡æ›¸å†…ã®ç­”ãˆã®æ›¸ã‹ã‚Œã¦ã„ã‚‹ç¯„å›²ã‚’ç‰¹å®šã™ã‚‹ã“ã¨ã‚’å«ã¿ã¾ã™ã€‚

<Youtube id="ajPx5LwJD-I"/>

ç§é”ã¯ã€Wikipediaã®è¨˜äº‹ã«å¯¾ã—ã¦ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ¯ãƒ¼ã‚«ãƒ¼ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸè³ªå•ã‹ã‚‰ãªã‚‹[SQuADãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ](https://rajpurkar.github.io/SQuAD-explorer/)ã®BERTãƒ¢ãƒ‡ãƒ«ã‚’å¾®èª¿æ•´ã™ã‚‹äºˆå®šã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ä»¥ä¸‹ã®ã‚ˆã†ãªäºˆæ¸¬ã‚’å®Ÿè¡Œã§ãã‚‹ãƒ¢ãƒ‡ãƒ«ãŒã§ãã‚‹ã§ã—ã‚‡ã†ã€‚

<iframe src="https://hf.space/gradioiframe/course-demos/bert-finetuned-squad/+" frameBorder="0" height="450" title="Gradio app" class="block dark:hidden container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

ã“ã‚Œã¯å®Ÿéš›ã«ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ç¤ºã—ãŸã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦å­¦ç¿’ã—ã€ãƒãƒ–ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ¢ãƒ‡ãƒ«ã‚’ç´¹ä»‹ã—ã¦ã„ã‚‹ã‚‚ã®ã§ã™ã€‚
è²´æ–¹ã¯[ã“ã“](https://huggingface.co/huggingface-course/bert-finetuned-squad?context=%F0%9F%A4%97+Transformers+is+backed+by+the+three+most+popular+deep+learning+libraries+%E2%80%94+Jax%2C+PyTorch+and+TensorFlow+%E2%80%94+with+a+seamless+integration+between+them.+It%27s+straightforward+to+train+your+models+with+one+before+loading+them+for+inference+with+the+other.&question=Which+deep+learning+libraries+back+%F0%9F%A4%97+Transformers%3F)ã§ãƒ¢ãƒ‡ãƒ«ã‚’è¦‹ã¤ã‘ã¦ã€äºˆæ¸¬ã‚’å†ç¢ºèªã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

<Tip>

ğŸ’¡ BERTã®ã‚ˆã†ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ã®ã¿ã®ãƒ¢ãƒ‡ãƒ«ã¯ã€ã€Œãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’ç™ºæ˜ã—ãŸã®ã¯èª°ã§ã™ã‹ï¼Ÿã€ã®ã‚ˆã†ãªäº‹å®Ÿã¨ã—ã¦å—ã‘å…¥ã‚Œã‚‰ã‚Œã¦ã„ã‚‹è§£ç­”ãŒå­˜åœ¨ã™ã‚‹è³ªå•ã«å¯¾ã—ã¦ç­”ãˆã‚’æŠ½å‡ºã™ã‚‹ã®ã«ã¯å„ªã‚Œã¦ã„ã¾ã™ãŒã€ã€Œãªãœã€ç©ºã¯é’ã„ã®ã§ã™ã‹ï¼Ÿã€ã®ã‚ˆã†ãªè‡ªç”±å½¢å¼ã®è³ªå•ã‚’ä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ã¯ã†ã¾ãã„ã‹ãªã„å‚¾å‘ãŒã‚ã‚Šã¾ã™ã€‚

ã“ã®ã‚ˆã†ãªé›£ã—ã„ã‚±ãƒ¼ã‚¹ã§ã¯ã€T5ã‚„BARTã®ã‚ˆã†ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ãƒ¼ãƒ‡ã‚³ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«ãŒã€[ãƒ†ã‚­ã‚¹ãƒˆè¦ç´„](/course/ja/chapter7/5)ã«éå¸¸ã«ä¼¼ãŸå…¸å‹çš„ãªæ–¹æ³•ã§æƒ…å ±ã‚’åˆæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã®ã‚¿ã‚¤ãƒ—ã® *ç”Ÿæˆçš„* ãªè³ªå•å›ç­”ã«èˆˆå‘³ãŒã‚ã‚‹å ´åˆã¯ã€[ELI5ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ](https://huggingface.co/datasets/eli5)ã«åŸºã¥ãç§ãŸã¡ã®[ãƒ‡ãƒ¢](https://yjernite.github.io/lfqa.html)ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

</Tip>

## ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™

æŠ½å‡ºçš„è³ªå•å¿œç­”ã®å­¦è¡“çš„ãªãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã¨ã—ã¦æœ€ã‚‚åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆãŒ [SQuAD](https://rajpurkar.github.io/SQuAD-explorer/) ã§ã™ã®ã§ã€ã“ã“ã§ã‚‚ã“ã‚Œã‚’åˆ©ç”¨ã—ã¾ã™ã€‚ã¾ãŸã€ã‚ˆã‚Šé›£ã—ã„[SQuAD v2](https://huggingface.co/datasets/squad_v2)ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚‚ã‚ã‚Šã€ã“ã‚Œã¯ç­”ãˆã®ãªã„è³ªå•ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚ã‚ãªãŸã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆãŒæ–‡è„ˆã®åˆ—ã€è³ªå•ã®åˆ—ã€ç­”ãˆã®åˆ—ã‚’å«ã‚“ã§ã„ã‚‹é™ã‚Šã€ä»¥ä¸‹ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’é©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã¯ãšã§ã™ã€‚

### SQuAD ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ

ã„ã¤ã‚‚ã®ã‚ˆã†ã«ã€`load_dataset()`ã®ãŠã‹ã’ã§ã€ãŸã£ãŸ1ã‚¹ãƒ†ãƒƒãƒ—ã§ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```py
from datasets import load_dataset

raw_datasets = load_dataset("squad")
```

ãã—ã¦ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¦‹ã¦ã€SQuADãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã«ã¤ã„ã¦ã‚‚ã£ã¨çŸ¥ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```py
raw_datasets
```

```python out
DatasetDict({
    train: Dataset({
        features: ['id', 'title', 'context', 'question', 'answers'],
        num_rows: 87599
    })
    validation: Dataset({
        features: ['id', 'title', 'context', 'question', 'answers'],
        num_rows: 10570
    })
})
```

`context`, `question`, `answers` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§å¿…è¦ãªã‚‚ã®ã¯ã™ã¹ã¦æƒã£ãŸã‚ˆã†ãªã®ã§ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚»ãƒƒãƒˆã®æœ€åˆã®è¦ç´ ã«å¯¾ã—ã¦ã“ã‚Œã‚‰ã‚’å‡ºåŠ›ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```py
print("Context: ", raw_datasets["train"][0]["context"])
print("Question: ", raw_datasets["train"][0]["question"])
print("Answer: ", raw_datasets["train"][0]["answers"])
```

```python out
Context: 'Architecturally, the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend "Venite Ad Me Omnes". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive (and in a direct line that connects through 3 statues and the Gold Dome), is a simple, modern stone statue of Mary.'
Question: 'To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France?'
Answer: {'text': ['Saint Bernadette Soubirous'], 'answer_start': [515]}
```

`context` ã¨ `question` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯éå¸¸ã«ç°¡å˜ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚`answers` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å°‘ã—æ‰‹ãŒè¾¼ã‚“ã§ãŠã‚Šã€ãƒªã‚¹ãƒˆã§ã‚ã‚‹2ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤è¾æ›¸å‹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ `squad` æŒ‡æ¨™ãŒè©•ä¾¡æ™‚ã«æœŸå¾…ã™ã‚‹å½¢å¼ã§ã™ã€‚ã‚‚ã—ã€ã‚ãªãŸè‡ªèº«ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã®ã§ã‚ã‚Œã°ã€å¿…ãšã—ã‚‚åŒã˜å½¢å¼ã®ç­”ãˆã‚’ç½®ãã“ã¨ã‚’å¿ƒé…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãŸã€ `answer_start` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå†…ã®å„è§£ç­”ã®é–‹å§‹æ–‡å­—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒæ ¼ç´ã•ã‚Œã¾ã™ã€‚

ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã®é–“ã€å¯èƒ½ãªç­”ãˆã¯1ã¤ã ã‘ã§ã™ã€‚ã“ã®ã“ã¨ã¯ `Dataset.filter()` ãƒ¡ã‚½ãƒƒãƒ‰ã§ãƒ€ãƒ–ãƒ«ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```py
raw_datasets["train"].filter(lambda x: len(x["answers"]["text"]) != 1)
```

```python out
Dataset({
    features: ['id', 'title', 'context', 'question', 'answers'],
    num_rows: 0
})
```

ãŸã ã—ã€è©•ä¾¡ã«ã¤ã„ã¦ã¯ã€å„ã‚µãƒ³ãƒ—ãƒ«ã«ã¤ã„ã¦ã€åŒã˜ç­”ãˆã‚‚ã‚ã‚Œã°ç•°ãªã‚‹ç­”ãˆã‚‚ã‚ã‚Šã€ã„ãã¤ã‹ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

```py
print(raw_datasets["validation"][0]["answers"])
print(raw_datasets["validation"][2]["answers"])
```

```python out
{'text': ['Denver Broncos', 'Denver Broncos', 'Denver Broncos'], 'answer_start': [177, 177, 177]}
{'text': ['Santa Clara, California', "Levi's Stadium", "Levi's Stadium in the San Francisco Bay Area at Santa Clara, California."], 'answer_start': [403, 355, 355]}
```

è©•ä¾¡ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ğŸ¤— Datasetsã®æŒ‡æ¨™ã«ã‚ˆã£ã¦ã¾ã¨ã‚ã‚‰ã‚Œã‚‹ã®ã§ã€ã“ã“ã§ã¯æ·±å…¥ã‚Šã—ã¾ã›ã‚“ãŒã€ç°¡å˜ã«è¨€ã†ã¨ã€ã„ãã¤ã‹ã®è³ªå•ã«ã¯ã„ãã¤ã‹ã®å›ç­”ãŒã‚ã‚Šã€ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯äºˆæ¸¬ã•ã‚ŒãŸå›ç­”ã¨ã™ã¹ã¦ã®è¨±å®¹ã§ãã‚‹å›ç­”ã‚’æ¯”è¼ƒã—ã€ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢ã‚’å–ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚ä¾‹ãˆã°ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹2ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’è¦‹ã¦ã¿ã‚‹ã¨

```py
print(raw_datasets["validation"][2]["context"])
print(raw_datasets["validation"][2]["question"])
```

```python out
'Super Bowl 50 was an American football game to determine the champion of the National Football League (NFL) for the 2015 season. The American Football Conference (AFC) champion Denver Broncos defeated the National Football Conference (NFC) champion Carolina Panthers 24â€“10 to earn their third Super Bowl title. The game was played on February 7, 2016, at Levi\'s Stadium in the San Francisco Bay Area at Santa Clara, California. As this was the 50th Super Bowl, the league emphasized the "golden anniversary" with various gold-themed initiatives, as well as temporarily suspending the tradition of naming each Super Bowl game with Roman numerals (under which the game would have been known as "Super Bowl L"), so that the logo could prominently feature the Arabic numerals 50.'
'Where did Super Bowl 50 take place?'
```

ç­”ãˆã¯ã€3ã¤ã®å¯èƒ½æ€§ã®ã†ã¡ã®1ã¤ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚

### å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†

<Youtube id="qgaM0weJHpA"/>

ã¾ãšã€å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã®å‰å‡¦ç†ã‹ã‚‰å§‹ã‚ã¾ã—ã‚‡ã†ã€‚é›£ã—ã„ã®ã¯è³ªå•ã®ç­”ãˆã®ãƒ©ãƒ™ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã§ã€ã“ã‚Œã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå†…ã®ç­”ãˆã«å¯¾å¿œã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®é–‹å§‹ä½ç½®ã¨çµ‚äº†ä½ç½®ã¨ãªã‚Šã¾ã™ã€‚

ã—ã‹ã—ã€å…ˆã‚’æ€¥ãŒãªã„ã‚ˆã†ã«ã—ã¾ã—ã‚‡ã†ã€‚ã¾ãšã€ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼ã‚’ä½¿ã£ã¦ã€å…¥åŠ›ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ¢ãƒ‡ãƒ«ãŒç†è§£ã§ãã‚‹ã‚ˆã†ãªIDã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```py
from transformers import AutoTokenizer

model_checkpoint = "bert-base-cased"
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)
```

å…ˆã«è¿°ã¹ãŸã‚ˆã†ã«ã€ç§ãŸã¡ã¯ BERT ãƒ¢ãƒ‡ãƒ«ã‚’å¾®èª¿æ•´ã—ã¾ã™ãŒã€é«˜é€Ÿãªãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹é™ã‚Šã€ä»–ã®ã©ã®ã‚ˆã†ãªãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—ã§ã‚‚ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚[ã“ã®å¤§ããªè¡¨](https://huggingface.co/transformers/#supported-frameworks)ã§é«˜é€Ÿç‰ˆã‚’æŒã¤ã™ã¹ã¦ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä½¿ç”¨ã—ã¦ã„ã‚‹ `tokenizer` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæœ¬å½“ã« ğŸ¤— Tokenizers ã§ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ã«ã¯ã€ãã® `is_fast` å±æ€§ã‚’è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```py
tokenizer.is_fast
```

```python out
True
```

è³ªå•ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸€ç·’ã«ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼ã«æ¸¡ã›ã°ã€ç‰¹æ®Šãªãƒˆãƒ¼ã‚¯ãƒ³ã‚’é©åˆ‡ã«æŒ¿å…¥ã—ã¦ã€æ¬¡ã®ã‚ˆã†ãªæ–‡ç« ã‚’å½¢æˆã—ã¦ãã‚Œã¾ã™ã€‚

```
[CLS] question [SEP] context [SEP]
```

2é‡ãƒã‚§ãƒƒã‚¯ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```py
context = raw_datasets["train"][0]["context"]
question = raw_datasets["train"][0]["question"]

inputs = tokenizer(question, context)
tokenizer.decode(inputs["input_ids"])
```

```python out
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Architecturally, '
'the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin '
'Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms '
'upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred '
'Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a '
'replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette '
'Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 statues '
'and the Gold Dome ), is a simple, modern stone statue of Mary. [SEP]'
```

ãƒ©ãƒ™ãƒ«ã¯å›ç­”ã®é–‹å§‹ã¨çµ‚äº†ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ãªã‚Šã€ãƒ¢ãƒ‡ãƒ«ã¯å…¥åŠ›ã®ãƒˆãƒ¼ã‚¯ãƒ³ã”ã¨ã«1ã¤ã®é–‹å§‹ã¨çµ‚äº†ã®ãƒ­ã‚¸ãƒƒãƒˆã‚’äºˆæ¸¬ã™ã‚‹ã‚ˆã†èª²ã•ã‚Œã€ç†è«–ä¸Šã®ãƒ©ãƒ™ãƒ«ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/qa_labels.svg" alt="One-hot encoded labels for question answering."/>
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/qa_labels-dark.svg" alt="One-hot encoded labels for question answering."/>
</div>

ã“ã®å ´åˆã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ãã‚Œã»ã©é•·ãã‚ã‚Šã¾ã›ã‚“ãŒã€ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®ä¸­ã«ã¯éå¸¸ã«é•·ã„æ–‡è„ˆã‚’æŒã¤ä¾‹ã‚‚ã‚ã‚Šã€è¨­å®šã—ãŸæœ€å¤§é•·ï¼ˆã“ã®å ´åˆã¯384ï¼‰ã‚’è¶…ãˆã¦ã—ã¾ã„ã¾ã™ã€‚[ç¬¬6ç« ](/course/ja/chapter6/4)ã§ `è³ªå•å¿œç­”`ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å†…éƒ¨ã‚’èª¿ã¹ãŸã¨ãã«è¦‹ãŸã‚ˆã†ã«ã€é•·ã„ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å¯¾ã—ã¦ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®1ã¤ã®ã‚µãƒ³ãƒ—ãƒ«ã‹ã‚‰è¤‡æ•°ã®å­¦ç¿’ç‰¹å¾´ã‚’ä½œæˆã—ã€ãã‚Œã‚‰ã®é–“ã«ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¨­ã‘ã¦å¯¾å‡¦ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

ä»Šå›ã®ä¾‹ã§ã¯ã€é•·ã•ã‚’100ã«åˆ¶é™ã—ã€50ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ã©ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚æ³¨æ„ç‚¹ã¨ã—ã¦ã€ä½¿ç”¨ã™ã‚‹ã®ã¯

- æœ€å¤§é•·ã‚’è¨­å®šã™ã‚‹ `max_length` (ã“ã“ã§ã¯100)
- `truncation="only_second"` ã¯ã€è³ªå•ã¨ãã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒé•·ã™ãã‚‹å ´åˆã«ã€(2ç•ªç›®ã®ä½ç½®ã«ã‚ã‚‹)ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ‡ã‚Šè©°ã‚ã‚‹
- `stride` ã¯2ã¤ã®é€£ç¶šã—ãŸæ–­ç‰‡é–“ã§é‡è¤‡ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°ã‚’è¨­å®šã—ã¾ã™ (ã“ã“ã§ã¯50)
- `return_overflowing_tokens=True` ã§ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼ã«ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ç”¨ãƒˆãƒ¼ã‚¯ãƒ³ãŒå¿…è¦ãªã“ã¨ã‚’çŸ¥ã‚‰ã›ã¾ã™ã€‚

```py
inputs = tokenizer(
    question,
    context,
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
)

for ids in inputs["input_ids"]:
    print(tokenizer.decode(ids))
```

```python out
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Architecturally, the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basi [SEP]'
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin [SEP]'
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP] Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 [SEP]'
'[CLS] To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France? [SEP]. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive ( and in a direct line that connects through 3 statues and the Gold Dome ), is a simple, modern stone statue of Mary. [SEP]'
```

è¦‹ã¦ã‚ã‹ã‚‹ã‚ˆã†ã«ã€ã“ã®ä¾‹ã¯4ã¤ã®å…¥åŠ›ã«åˆ†å‰²ã•ã‚Œã€ãã‚Œãã‚ŒãŒè³ªå•ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¸€éƒ¨ã‚’å«ã‚“ã§ã„ã¾ã™ã€‚è³ªå•ã«å¯¾ã™ã‚‹ç­”ãˆï¼ˆ"Bernadette Soubirous"ï¼‰ã¯3ç•ªç›®ã¨æœ€å¾Œã®å…¥åŠ›ã«ã®ã¿ç¾ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã®ã‚ˆã†ã«é•·ã„æ–‡è„ˆã‚’æ‰±ã†ã“ã¨ã§ã€ç­”ãˆãŒæ–‡è„ˆã«å«ã¾ã‚Œãªã„å­¦ç¿’ã‚µãƒ³ãƒ—ãƒ«ã‚’ã„ãã¤ã‹ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã‚‰ã®ä¾‹ã§ã¯ã€ãƒ©ãƒ™ãƒ«ã¯ `start_position = end_position = 0` ã¨ãªã‚Šã¾ã™ï¼ˆã¤ã¾ã‚Šã€`[CLS]` ãƒˆãƒ¼ã‚¯ãƒ³ã‚’äºˆæ¸¬ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ï¼‰ã€‚ã¾ãŸã€ä¸å¹¸ã«ã‚‚ç­”ãˆãŒåˆ‡ã‚Šæ¨ã¦ã‚‰ã‚Œã€å§‹ã¾ã‚Šï¼ˆã¾ãŸã¯çµ‚ã‚ã‚Šï¼‰ã—ã‹ãªã„å ´åˆã«ã‚‚ã€ã“ã‚Œã‚‰ã®ãƒ©ãƒ™ãƒ«ã‚’è¨­å®šã—ã¾ã™ã€‚ç­”ãˆãŒã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å®Œå…¨ã«å«ã¾ã‚Œã¦ã„ã‚‹ä¾‹ã§ã¯ã€ãƒ©ãƒ™ãƒ«ã¯ç­”ãˆãŒå§‹ã¾ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ç­”ãˆãŒçµ‚ã‚ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ãªã‚Šã¾ã™ã€‚

ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‹ã‚‰ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå†…ã®ç­”ãˆã®é–‹å§‹æ–‡å­—ãŒå¾—ã‚‰ã‚Œã€ç­”ãˆã®é•·ã•ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå†…ã®çµ‚äº†æ–‡å­—ãŒè¦‹ã¤ã‹ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«ãƒãƒƒãƒ—ã™ã‚‹ã«ã¯ã€[ç¬¬6ç« ](/course/ja/chapter6/4) ã§å­¦ç¿’ã—ãŸã‚ªãƒ•ã‚»ãƒƒãƒˆ ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚`return_offsets_mapping=True` ã‚’æ¸¡ã™ã“ã¨ã§ã€ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼ã«ã“ã‚Œã‚‰ã‚’è¿”ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```py
inputs = tokenizer(
    question,
    context,
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)
inputs.keys()
```

```python out
dict_keys(['input_ids', 'token_type_ids', 'attention_mask', 'offset_mapping', 'overflow_to_sample_mapping'])
```

è¦‹ã¦ã®ã¨ãŠã‚Šã€é€šå¸¸ã®å…¥åŠ› IDã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚¿ã‚¤ãƒ— IDã€ã‚¢ãƒ†ãƒ³ã‚·ãƒ§ãƒ³ãƒã‚¹ã‚¯ã«åŠ ãˆã€å¿…è¦ãªã‚ªãƒ•ã‚»ãƒƒãƒˆãƒãƒƒãƒ”ãƒ³ã‚°ã€ã•ã‚‰ã« `overflow_to_sample_mapping` ã¨ã„ã†ã‚­ãƒ¼ãŒè¿”ã•ã‚Œã¾ã™ã€‚ã“ã®å€¤ã¯ã€è¤‡æ•°ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’åŒæ™‚ã«ãƒˆãƒ¼ã‚¯ãƒ³åŒ–ã™ã‚‹ã¨ãã«å½¹ã«ç«‹ã¡ã¾ã™ (ã“ã®ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼ãŒRustã«æ”¯ãˆã‚‰ã‚Œã¦ã„ã‚‹ã¨ã„ã†äº‹å®Ÿã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã«ã€ãã†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™)ã€‚1 ã¤ã®ã‚µãƒ³ãƒ—ãƒ«ã¯è¤‡æ•°ã®ç‰¹å¾´ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã€å„ç‰¹å¾´ã‚’ãã®å…ƒã¨ãªã‚‹ã‚µãƒ³ãƒ—ãƒ«ã«ãƒãƒƒãƒ—ã—ã¾ã™ã€‚ã“ã“ã§ã¯ 1 ã¤ã®ä¾‹ã‚’ãƒˆãƒ¼ã‚¯ãƒ³åŒ–ã—ãŸã ã‘ãªã®ã§ã€`0` ã®ãƒªã‚¹ãƒˆãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚

```py
inputs["overflow_to_sample_mapping"]
```

```python out
[0, 0, 0, 0]
```

ã—ã‹ã—ã€ã‚‚ã£ã¨å¤šãã®ä¾‹ã‚’ãƒˆãƒ¼ã‚¯ãƒ³åŒ–ã™ã‚Œã°ã€ã“ã‚Œã¯ã‚‚ã£ã¨ä¾¿åˆ©ã«ãªã‚Šã¾ã™ã€‚

```py
inputs = tokenizer(
    raw_datasets["train"][2:6]["question"],
    raw_datasets["train"][2:6]["context"],
    max_length=100,
    truncation="only_second",
    stride=50,
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)

print(f"The 4 examples gave {len(inputs['input_ids'])} features.")
print(f"Here is where each comes from: {inputs['overflow_to_sample_mapping']}.")
```

```python out
'The 4 examples gave 19 features.'
'Here is where each comes from: [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3].'
```

è¦‹ã¦ã®é€šã‚Šã€æœ€åˆã®3ä¾‹ï¼ˆãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚»ãƒƒãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹2ã€3ã€4ï¼‰ã¯ãã‚Œãã‚Œ4ã¤ã®ç‰¹å¾´ã‚’ä¸ãˆã€æœ€å¾Œã®ä¾‹ï¼ˆãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚»ãƒƒãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹5ï¼‰ã¯7ã¤ã®ç‰¹å¾´ã‚’ä¸ãˆã¦ã„ã¾ã™ã€‚

ã“ã®æƒ…å ±ã¯ã€å¾—ã‚‰ã‚ŒãŸå„ç‰¹å¾´ã‚’å¯¾å¿œã™ã‚‹ãƒ©ãƒ™ãƒ«ã«å¯¾å¿œä»˜ã‘ã‚‹ãŸã‚ã«æœ‰ç”¨ã§ã™ã€‚å‰è¿°ã—ãŸã‚ˆã†ã«ã€ãã‚Œã‚‰ã®ãƒ©ãƒ™ãƒ«ã¯

- ç­”ãˆãŒã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒå¯¾å¿œã™ã‚‹ç¯„å›²å†…ã«ãªã„å ´åˆã€ `(0, 0)` ã¨ãªã‚Šã¾ã™
- `(start_position, end_position)` ã‚‚ã—ç­”ãˆãŒã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®å¯¾å¿œã™ã‚‹ç¯„å›²å†…ã«ã‚ã‚Œã°ã€ `start_position` ã¯ç­”ãˆã®å§‹ã¾ã‚Šã®ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆå…¥åŠ›IDã®ä¸­ï¼‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€ `end_position` ã¯ç­”ãˆã®çµ‚ã‚ã‚Šã®ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆå…¥åŠ›IDã®ä¸­ï¼‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™

ã“ã‚Œã‚‰ã®ã©ã¡ã‚‰ã§ã‚ã‚‹ã‹ã€ã¾ãŸé–¢é€£ã™ã‚‹å ´åˆã¯ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½ç½®ã‚’æ±ºå®šã™ã‚‹ãŸã‚ã«ã€ã¾ãšå…¥åŠ›IDã®ä¸­ã§æ–‡è„ˆã‚’é–‹å§‹ã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨çµ‚äº†ã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¦‹ã¤ã‘ã¾ã™ã€‚ã“ã‚Œã‚’è¡Œã†ã«ã¯ãƒˆãƒ¼ã‚¯ãƒ³ã‚¿ã‚¤ãƒ— ID ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ãŒã€ãã‚Œã¯ã™ã¹ã¦ã®ãƒ¢ãƒ‡ãƒ«ã«å­˜åœ¨ã™ã‚‹ã¨ã¯é™ã‚‰ãªã„ã®ã§ (ä¾‹ãˆã° DistilBERT ã¯ãã‚Œã‚’è¦æ±‚ã—ã¾ã›ã‚“)ã€ä»£ã‚ã‚Šã«ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼ãŒè¿”ã™ `BatchEncoding` ã® `sequence_ids()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚

ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒå¾—ã‚‰ã‚ŒãŸã‚‰ã€å¯¾å¿œã™ã‚‹ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿ã¹ã¾ã™ã€‚ã‚ªãƒ•ã‚»ãƒƒãƒˆã¨ã¯ã€å…ƒã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå†…ã®æ–‡å­—ã®ç¯„å›²ã‚’è¡¨ã™2ã¤ã®æ•´æ•°ã®çµ„ã®ã“ã¨ã§ã™ã€‚ã“ã®ã‚ˆã†ã«ã—ã¦ã€ã“ã®ç‰¹å¾´ã«ãŠã‘ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ–­ç‰‡ãŒã€ç­”ãˆãŒçµ‚ã‚ã£ãŸå¾Œã«å§‹ã¾ã£ã¦ã„ã‚‹ã®ã‹ã€ç­”ãˆãŒå§‹ã¾ã‚‹å‰ã«çµ‚ã‚ã£ã¦ã„ã‚‹ã®ã‹ï¼ˆãã®å ´åˆã®ãƒ©ãƒ™ãƒ«ã¯ `(0, 0)` ï¼‰ ã‚’æ¤œå‡ºã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã™ã€‚ãã†ã§ãªã„å ´åˆã¯ã€ç­”ãˆã®æœ€åˆã¨æœ€å¾Œã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¦‹ã¤ã‘ã‚‹ãŸã‚ã«ãƒ«ãƒ¼ãƒ—ã—ã¾ã™ã€‚

```py
answers = raw_datasets["train"][2:6]["answers"]
start_positions = []
end_positions = []

for i, offset in enumerate(inputs["offset_mapping"]):
    sample_idx = inputs["overflow_to_sample_mapping"][i]
    answer = answers[sample_idx]
    start_char = answer["answer_start"][0]
    end_char = answer["answer_start"][0] + len(answer["text"][0])
    sequence_ids = inputs.sequence_ids(i)

    # Find the start and end of the context
    idx = 0
    while sequence_ids[idx] != 1:
        idx += 1
    context_start = idx
    while sequence_ids[idx] == 1:
        idx += 1
    context_end = idx - 1

    # If the answer is not fully inside the context, label is (0, 0)
    if offset[context_start][0] > start_char or offset[context_end][1] < end_char:
        start_positions.append(0)
        end_positions.append(0)
    else:
        # Otherwise it's the start and end token positions
        idx = context_start
        while idx <= context_end and offset[idx][0] <= start_char:
            idx += 1
        start_positions.append(idx - 1)

        idx = context_end
        while idx >= context_start and offset[idx][1] >= end_char:
            idx -= 1
        end_positions.append(idx + 1)

start_positions, end_positions
```

```python out
([83, 51, 19, 0, 0, 64, 27, 0, 34, 0, 0, 0, 67, 34, 0, 0, 0, 0, 0],
 [85, 53, 21, 0, 0, 70, 33, 0, 40, 0, 0, 0, 68, 35, 0, 0, 0, 0, 0])
```

ç§é”ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒãŒæ­£ã—ã„ã“ã¨ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€ã„ãã¤ã‹ã®çµæœã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚æœ€åˆã®ç‰¹å¾´é‡ã§ã¯ã€ãƒ©ãƒ™ãƒ«ã¨ã—ã¦ `(83, 85)` ãŒè¦‹ã¤ã‹ã£ãŸã®ã§ã€ç†è«–çš„ãªç­”ãˆã¨83ã‹ã‚‰85ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾å¿œã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã‚‚å«ã‚€ï¼‰ã¾ã§ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã—ãŸç¯„å›²ã‚’æ¯”è¼ƒã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```py
idx = 0
sample_idx = inputs["overflow_to_sample_mapping"][idx]
answer = answers[sample_idx]["text"][0]

start = start_positions[idx]
end = end_positions[idx]
labeled_answer = tokenizer.decode(inputs["input_ids"][idx][start : end + 1])

print(f"Theoretical answer: {answer}, labels give: {labeled_answer}")
```

```python out
'Theoretical answer: the Main Building, labels give: the Main Building'
```

ã¨ã„ã†ã“ã¨ã§ã€ä¸€è‡´ã—ã¾ã—ãŸ ã“ã“ã§ã€ãƒ©ãƒ™ãƒ«ã‚’ `(0, 0)` ã«è¨­å®šã—ã¾ã—ãŸã€‚ã¤ã¾ã‚Šã€ç­”ãˆã¯ãã®ç‰¹å¾´ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ–­ç‰‡ã«ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚

```py
idx = 4
sample_idx = inputs["overflow_to_sample_mapping"][idx]
answer = answers[sample_idx]["text"][0]

decoded_example = tokenizer.decode(inputs["input_ids"][idx])
print(f"Theoretical answer: {answer}, decoded example: {decoded_example}")
```

```python out
'Theoretical answer: a Marian place of prayer and reflection, decoded example: [CLS] What is the Grotto at Notre Dame? [SEP] Architecturally, the school has a Catholic character. Atop the Main Building\'s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend " Venite Ad Me Omnes ". Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grot [SEP]'
```

ç¢ºã‹ã«ã€æ–‡è„ˆã®ä¸­ã«ç­”ãˆãŒå‡ºã¦ãã¾ã›ã‚“ã€‚

<Tip>

âœï¸ **ã‚ãªãŸã®ç•ªã§ã™ï¼** XLNetã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€å·¦å´ã«ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ãŒé©ç”¨ã•ã‚Œã€è³ªå•ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆ‡ã‚Šæ›¿ã‚ã‚Šã¾ã™ã€‚å…ˆã»ã©ã®ã‚³ãƒ¼ãƒ‰ã‚’å…¨ã¦XLNetã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«é©å¿œã•ã›ã¦ãã ã•ã„ï¼ˆãã—ã¦`padding=True`ã‚’è¿½åŠ ã™ã‚‹ï¼‰ã€‚ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’é©ç”¨ã—ãŸå ´åˆã€`[CLS]` ãƒˆãƒ¼ã‚¯ãƒ³ãŒ 0 ã®ä½ç½®ã«æ¥ãªã„å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

</Tip>

è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã®å‰å‡¦ç†ã‚’æ®µéšçš„ã«è¦‹ã¦ãã¾ã—ãŸãŒã€è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆå…¨ä½“ã«å¯¾ã—ã¦é©ç”¨ã™ã‚‹é–¢æ•°ã«ã¾ã¨ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã»ã¨ã‚“ã©ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯é•·ã„ã®ã§ï¼ˆãã—ã¦å¯¾å¿œã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã¯ã„ãã¤ã‹ã®ç‰¹å¾´ã«åˆ†å‰²ã•ã‚Œã¾ã™ï¼‰ã€ã“ã“ã§å‹•çš„ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’é©ç”¨ã—ã¦ã‚‚ã‚ã¾ã‚Šæ„å‘³ãŒãªã„ã®ã§ã€ã™ã¹ã¦ã®ç‰¹å¾´ã‚’è¨­å®šã—ãŸæœ€å¤§é•·ã«ãªã‚‹ã‚ˆã†ã«ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã—ã¾ã™ã€‚

```py
max_length = 384
stride = 128


def preprocess_training_examples(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=max_length,
        truncation="only_second",
        stride=stride,
        return_overflowing_tokens=True,
        return_offsets_mapping=True,
        padding="max_length",
    )

    offset_mapping = inputs.pop("offset_mapping")
    sample_map = inputs.pop("overflow_to_sample_mapping")
    answers = examples["answers"]
    start_positions = []
    end_positions = []

    for i, offset in enumerate(offset_mapping):
        sample_idx = sample_map[i]
        answer = answers[sample_idx]
        start_char = answer["answer_start"][0]
        end_char = answer["answer_start"][0] + len(answer["text"][0])
        sequence_ids = inputs.sequence_ids(i)

        # Find the start and end of the context
        idx = 0
        while sequence_ids[idx] != 1:
            idx += 1
        context_start = idx
        while sequence_ids[idx] == 1:
            idx += 1
        context_end = idx - 1

        # If the answer is not fully inside the context, label is (0, 0)
        if offset[context_start][0] > start_char or offset[context_end][1] < end_char:
            start_positions.append(0)
            end_positions.append(0)
        else:
            # Otherwise it's the start and end token positions
            idx = context_start
            while idx <= context_end and offset[idx][0] <= start_char:
                idx += 1
            start_positions.append(idx - 1)

            idx = context_end
            while idx >= context_start and offset[idx][1] >= end_char:
                idx -= 1
            end_positions.append(idx + 1)

    inputs["start_positions"] = start_positions
    inputs["end_positions"] = end_positions
    return inputs
```

ã‚¹ãƒ©ã‚¤ãƒ‡ã‚£ãƒ³ã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®é•·ã•ã¨æœ€å¤§é•·ã‚’æ±ºå®šã™ã‚‹ãŸã‚ã«2ã¤ã®å®šæ•°ã‚’å®šç¾©ã—ãŸã“ã¨ã¨ã€ãƒˆãƒ¼ã‚¯ãƒ³åŒ–ã®å‰ã«å°ã•ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’è¿½åŠ ã—ãŸã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚SQuADãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®ã„ãã¤ã‹ã®è³ªå•ã«ã¯æœ€åˆã¨æœ€å¾Œã«ä½•ã‚‚è¿½åŠ ã—ãªã„ä½™è¨ˆãªã‚¹ãƒšãƒ¼ã‚¹ï¼ˆRoBERTaãªã©ã®ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã¨ãƒˆãƒ¼ã‚¯ãƒ³åŒ–ã™ã‚‹ã¨ãã«ã‚¹ãƒšãƒ¼ã‚¹ã‚’å–ã£ã¦ã—ã¾ã„ã¾ã™ï¼‰ãŒã‚ã‚‹ã®ã§ã€ãã‚Œã‚‰ã®ä½™è¨ˆãªã‚¹ãƒšãƒ¼ã‚¹ã‚’é™¤å»ã—ã¦ã„ã¾ã™ã€‚

ã“ã®é–¢æ•°ã‚’è¨“ç·´ã‚»ãƒƒãƒˆå…¨ä½“ã«é©ç”¨ã™ã‚‹ãŸã‚ã«ã€ `Dataset.map()` ãƒ¡ã‚½ãƒƒãƒ‰ã« `batched=True` ãƒ•ãƒ©ã‚°ã‚’ä»˜ã‘ã¦ä½¿ã„ã¾ã™ã€‚ã“ã‚Œã¯ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®é•·ã•ã‚’å¤‰æ›´ã™ã‚‹ãŸã‚ã«å¿…è¦ã§ã™ï¼ˆ1ã¤ã®ä¾‹ã§è¤‡æ•°ã®å­¦ç¿’ç‰¹å¾´ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ãŸã‚ï¼‰ã€‚

```py
train_dataset = raw_datasets["train"].map(
    preprocess_training_examples,
    batched=True,
    remove_columns=raw_datasets["train"].column_names,
)
len(raw_datasets["train"]), len(train_dataset)
```

```python out
(87599, 88729)
```
ã“ã®ã‚ˆã†ã«ã€å‰å‡¦ç†ã«ã‚ˆã£ã¦ç´„1,000å€‹ã®ç‰¹å¾´ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ã“ã‚Œã§è¨“ç·´ã‚»ãƒƒãƒˆã®æº–å‚™ã¯æ•´ã„ã¾ã—ãŸã€‚æ¬¡ã¯æ¤œè¨¼ã‚»ãƒƒãƒˆã®å‰å‡¦ç†ã§ã™ã€‚

### æ¤œè¨¼ã‚»ãƒƒãƒˆã®å‡¦ç†

æ¤œè¨¼ãƒ‡ãƒ¼ã‚¿ã®å‰å‡¦ç†ã¯ã€ãƒ©ãƒ™ãƒ«ã‚’ç”Ÿæˆã™ã‚‹å¿…è¦ãŒãªã„ãŸã‚ã€è‹¥å¹²ç°¡å˜ã«ãªã‚Šã¾ã™ã€‚ï¼ˆæ¤œè¨¼æå¤±ã‚’è¨ˆç®—ã—ãŸã„å ´åˆã¯åˆ¥ã§ã™ãŒã€ã“ã®æ•°å€¤ã¯ãƒ¢ãƒ‡ãƒ«ãŒã©ã‚Œã ã‘å„ªã‚Œã¦ã„ã‚‹ã‹ã‚’ç†è§£ã™ã‚‹ã®ã«ã‚ã¾ã‚Šå½¹ç«‹ã¡ã¾ã›ã‚“ï¼‰ã€‚æœ¬å½“ã®å–œã³ã¯ã€ãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬ã‚’å…ƒã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ç¯„å›²ã¨ã—ã¦è§£é‡ˆã™ã‚‹äº‹ã«ã‚ã‚Šã¾ã™ã€‚ã“ã®ãŸã‚ã«ã¯ã€ã‚ªãƒ•ã‚»ãƒƒãƒˆãƒãƒƒãƒ”ãƒ³ã‚°ã¨ã€ä½œæˆã•ã‚ŒãŸå„ç‰¹å¾´ã‚’å…ƒã®ä¾‹æ–‡ã¨ãƒãƒƒãƒãƒ³ã‚°ã•ã›ã‚‹æ–¹æ³•ã®ä¸¡æ–¹ã‚’ä¿å­˜ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã ã‘ã§ã™ã€‚å…ƒã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã«IDã‚«ãƒ©ãƒ ãŒã‚ã‚‹ã®ã§ã€ãã®IDã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

ã“ã“ã§è¿½åŠ ã™ã‚‹ã®ã¯ã€ã‚ªãƒ•ã‚»ãƒƒãƒˆãƒãƒƒãƒ”ãƒ³ã‚°ã®ã»ã‚“ã®å°‘ã—ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã ã‘ã§ã™ã€‚è³ªå•ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒå«ã¾ã‚Œã¾ã™ãŒã€å¾Œå‡¦ç†ã®æ®µéšã§ã¯ã€å…¥åŠ›IDã®ã©ã®éƒ¨åˆ†ãŒã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«å¯¾å¿œã—ã€ã©ã®éƒ¨åˆ†ãŒè³ªå•ã§ã‚ã‚‹ã‹ã‚’çŸ¥ã‚‹æ–¹æ³•ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆç§ãŸã¡ãŒä½¿ã£ãŸ `sequence_ids()` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ã®å‡ºåŠ›ã«ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã™ï¼‰ã€‚ãã“ã§ã€è³ªå•ã«å¯¾å¿œã™ã‚‹ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ `None` ã«è¨­å®šã™ã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚

```py
def preprocess_validation_examples(examples):
    questions = [q.strip() for q in examples["question"]]
    inputs = tokenizer(
        questions,
        examples["context"],
        max_length=max_length,
        truncation="only_second",
        stride=stride,
        return_overflowing_tokens=True,
        return_offsets_mapping=True,
        padding="max_length",
    )

    sample_map = inputs.pop("overflow_to_sample_mapping")
    example_ids = []

    for i in range(len(inputs["input_ids"])):
        sample_idx = sample_map[i]
        example_ids.append(examples["id"][sample_idx])

        sequence_ids = inputs.sequence_ids(i)
        offset = inputs["offset_mapping"][i]
        inputs["offset_mapping"][i] = [
            o if sequence_ids[k] == 1 else None for k, o in enumerate(offset)
        ]

    inputs["example_id"] = example_ids
    return inputs
```

ã“ã®é–¢æ•°ã¯ã€å…ˆã»ã©ã®ã‚ˆã†ã«æ¤œè¨¼ç”¨ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆå…¨ä½“ã«é©ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```py
validation_dataset = raw_datasets["validation"].map(
    preprocess_validation_examples,
    batched=True,
    remove_columns=raw_datasets["validation"].column_names,
)
len(raw_datasets["validation"]), len(validation_dataset)
```

```python out
(10570, 10822)
```

ã“ã®å ´åˆã€æ•°ç™¾ã‚µãƒ³ãƒ—ãƒ«ã—ã‹è¿½åŠ ã—ã¦ã„ãªã„ã®ã§ã€æ¤œè¨¼ç”¨ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯å°‘ã—çŸ­ã„ã‚ˆã†ã§ã™ã€‚
ã•ã¦ã€å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ã®å‰å‡¦ç†ãŒçµ‚ã‚ã£ãŸã®ã§ã€ã„ã‚ˆã„ã‚ˆå­¦ç¿’ã«å…¥ã‚Šã¾ã™ã€‚

{#if fw === 'pt'}

## Trainer API ã§ãƒ¢ãƒ‡ãƒ«ã®å¾®èª¿æ•´ã‚’è¡Œã†

ã“ã®ä¾‹ã®å­¦ç¿’ã‚³ãƒ¼ãƒ‰ã¯ã€å‰ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚³ãƒ¼ãƒ‰ã¨ã‚ˆãä¼¼ã¦ã„ã¾ã™ã€‚æœ€ã‚‚é›£ã—ã„ã®ã¯ `compute_metrics()` é–¢æ•°ã‚’æ›¸ãã“ã¨ã§ã™ã€‚ã™ã¹ã¦ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’è¨­å®šã—ãŸæœ€å¤§é•·ã«ãªã‚‹ã‚ˆã†ã«ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã—ã¦ã„ã‚‹ã®ã§ã€ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’å®šç¾©ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã—ãŸãŒã£ã¦ã€ã“ã®æŒ‡æ¨™ã®è¨ˆç®—ã ã‘ãŒæœ¬å½“ã«å¿ƒé…ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã§ã™ã€‚é›£ã—ã„ã®ã¯ã€å¾Œå‡¦ç†ã§ãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬ã‚’å…ƒã®ä¾‹æ–‡ã®ãƒ†ã‚­ã‚¹ãƒˆã®ç¯„å›²ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ä¸€æ—¦ã“ã‚Œã‚’è¡Œãˆã°ã€ğŸ¤— Datasetsãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æŒ‡æ¨™ãŒç§é”ã®ãŸã‚ã«ã»ã¨ã‚“ã©ã®ä½œæ¥­ã‚’ã—ã¦ãã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚

{:else}

## Kerasã‚’ä½¿ã£ã¦ãƒ¢ãƒ‡ãƒ«ã®å¾®èª¿æ•´ã‚’è¡Œã†

ã“ã®ä¾‹ã®å­¦ç¿’ã‚³ãƒ¼ãƒ‰ã¯ã€å‰ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚³ãƒ¼ãƒ‰ã¨ã‚ˆãä¼¼ã¦ã„ã¾ã™ãŒã€æŒ‡æ¨™ã®è¨ˆç®—ã«ç‹¬è‡ªã®é›£ã—ã•ãŒã‚ã‚Šã¾ã™ã€‚å…¨ã¦ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’è¨­å®šã—ãŸæœ€å¤§é•·ã«ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã—ãŸã®ã§ã€å®šç¾©ã™ã¹ããƒ‡ãƒ¼ã‚¿ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯ãªãã€ã“ã®æŒ‡æ¨™ã®è¨ˆç®—ã ã‘ãŒæœ¬å½“ã«å¿ƒé…ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ãªã®ã§ã™ã€‚é›£ã—ã„äº‹ã¯ã€å¾Œå‡¦ç†ã¨ã—ã¦ã€ãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬ã‚’å…ƒã®ä¾‹ã®ãƒ†ã‚­ã‚¹ãƒˆã®ç¯„å›²ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ä¸€åº¦ãã‚Œã‚’è¡Œãˆã°ã€ğŸ¤— Datasetsãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ¡ãƒˆãƒªãƒƒã‚¯ãŒç§ãŸã¡ã®ãŸã‚ã«ä»•äº‹ã®å¤§éƒ¨åˆ†ã‚’è¡Œã£ã¦ãã‚Œã¾ã™ã€‚

{/if}

### å¾Œå‡¦ç†

{#if fw === 'pt'}

<Youtube id="BNy08iIWVJM"/>

{:else}

<Youtube id="VN67ZpN33Ss"/>

{/if}

ã“ã®ãƒ¢ãƒ‡ãƒ«ã¯ã€[`question-answering` pipeline](/course/ja/chapter6/3b) ã®æ¢ç´¢ã§è¦‹ãŸã‚ˆã†ã«ã€å…¥åŠ›IDã«ãŠã‘ã‚‹ç­”ãˆã®é–‹å§‹ä½ç½®ã¨çµ‚äº†ä½ç½®ã®ãƒ­ã‚¸ãƒƒãƒˆã‚’å‡ºåŠ›ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚å¾Œå‡¦ç†ã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€ãã®éš›ã«è¡Œã£ãŸã“ã¨ã¨åŒã˜ã‚ˆã†ãªã‚‚ã®ã«ãªã‚Šã¾ã™ã®ã§ã€ä»¥ä¸‹ã§ã‚„ã£ãŸäº‹ã‚’æ€ã„å‡ºã—ã¦ãã ã•ã„ã€‚

- ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå¤–ã®ãƒˆãƒ¼ã‚¯ãƒ³ã«å¯¾å¿œã™ã‚‹é–‹å§‹ã¨çµ‚äº†ã®ãƒ­ã‚¸ãƒƒãƒˆã‚’ãƒã‚¹ã‚¯ã—ã¾ã—ãŸã€‚
- æ¬¡ã«ã€ã‚½ãƒ•ãƒˆãƒãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦é–‹å§‹ãƒ­ã‚¸ãƒƒãƒˆã¨çµ‚äº†ãƒ­ã‚¸ãƒƒãƒˆã‚’ç¢ºç‡ã«å¤‰æ›ã—ã¾ã—ãŸã€‚
- å„ãƒšã‚¢ `(start_token, end_token)` ã«ã¯ã€å¯¾å¿œã™ã‚‹äºŒã¤ã®ç¢ºç‡ã®ç©ã‚’å–ã‚‹ã“ã¨ã§ã‚¹ã‚³ã‚¢ã‚’ä»˜ä¸ã—ã¾ã—ãŸã€‚
- ç§é”ã¯æœ‰åŠ¹ãªç­”ãˆï¼ˆä¾‹ãˆã°ã€`start_token`ãŒ`end_token`ã‚ˆã‚Šå‰ã«ã‚ã‚‹ï¼‰ã‚’ã‚‚ãŸã‚‰ã™æœ€å¤§ã®ã‚¹ã‚³ã‚¢ã‚’æŒã¤ãƒšã‚¢ã‚’æ¢ã—ã¾ã—ãŸã€‚

ã“ã“ã§ã¯ã€å®Ÿéš›ã®ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—ã™ã‚‹å¿…è¦ãŒãªã„ãŸã‚ã€ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’å°‘ã—å¤‰æ›´ã—ã¾ã™ï¼ˆäºˆæ¸¬ã•ã‚ŒãŸç­”ãˆã ã‘ãŒæ¬²ã—ã„ã®ã§ã™ï¼‰ã€‚ã¤ã¾ã‚Šã€ã‚½ãƒ•ãƒˆãƒãƒƒã‚¯ã‚¹ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€ã‚ˆã‚Šé«˜é€Ÿã«å‡¦ç†ã™ã‚‹ãŸã‚ã«ã€å¯èƒ½æ€§ã®ã‚ã‚‹å…¨ã¦ã® `(start_token, end_token)` ãƒšã‚¢ã‚’ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã›ãšã€æœ€ã‚‚é«˜ã„ `n_best` ãƒ­ã‚¸ãƒƒãƒˆã«å¯¾å¿œã™ã‚‹ã‚‚ã®ã ã‘ã‚’ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã—ã¾ã™ï¼ˆ`n_best=20` ã¨ã—ã¾ã™ï¼‰ã€‚ã‚½ãƒ•ãƒˆãƒãƒƒã‚¯ã‚¹ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã®ã§ã€ã“ã‚Œã‚‰ã®ã‚¹ã‚³ã‚¢ã¯logitã‚¹ã‚³ã‚¢ã¨ãªã‚Šã€é–‹å§‹ã¨çµ‚äº†ã®ãƒ­ã‚¸ãƒƒãƒˆã®å’Œã‚’å–ã‚‹ã“ã¨ã§å¾—ã‚‰ã‚Œã¾ã™ã€‚\\(\log(ab) = \log(a) + \log(b)\\))ã®å…¬å¼ãŒã‚ã‚‹ã®ã§ç©ã®ä»£ã‚ã‚Šã«å’Œã¨ãªã‚Šã¾ã™)ã€‚

ã“ã‚Œã‚‰ã®ã“ã¨ã‚’å®Ÿè¨¼ã™ã‚‹ãŸã‚ã«ã¯ã€ä½•ã‚‰ã‹ã®äºˆæ¸¬ãŒå¿…è¦ã§ã™ã€‚ã¾ã ãƒ¢ãƒ‡ãƒ«ã‚’å­¦ç¿’ã—ã¦ã„ãªã„ã®ã§ã€QAãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã€æ¤œè¨¼ã‚»ãƒƒãƒˆã®ä¸€éƒ¨ã§äºˆæ¸¬ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚ã“ã®å‡¦ç†é–¢æ•°ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å®šæ•° `tokenizer` ã«ä¾å­˜ã—ã¦ã„ã‚‹ã®ã§ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¸€æ™‚çš„ã«ä½¿ç”¨ã—ãŸã„ãƒ¢ãƒ‡ãƒ«ã®ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼ã«å¤‰æ›´ã™ã‚‹ã ã‘ã§ã‚ˆã„ã®ã§ã™ã€‚

```python
small_eval_set = raw_datasets["validation"].select(range(100))
trained_checkpoint = "distilbert-base-cased-distilled-squad"

tokenizer = AutoTokenizer.from_pretrained(trained_checkpoint)
eval_set = small_eval_set.map(
    preprocess_validation_examples,
    batched=True,
    remove_columns=raw_datasets["validation"].column_names,
)
```

å‰å‡¦ç†ãŒçµ‚ã‚ã£ãŸã®ã§ã€ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼ã‚’å…ƒã€…é¸ã‚“ã§ã„ãŸã‚‚ã®ã«æˆ»ã—ã¾ã™ã€‚

```python
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)
```

æ¬¡ã«ã€`eval_set`ã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ãŒæœŸå¾…ã—ãªã„åˆ—ã‚’å–ã‚Šé™¤ãã€ãã®å°ã•ãªæ¤œè¨¼ã‚»ãƒƒãƒˆã‚’ã™ã¹ã¦å«ã‚€ãƒãƒƒãƒã‚’æ§‹ç¯‰ã—ã€ãã‚Œã‚’ãƒ¢ãƒ‡ãƒ«ã«æ¸¡ã—ã¾ã™ã€‚GPUãŒåˆ©ç”¨å¯èƒ½ã§ã‚ã‚Œã°ã€ã‚ˆã‚Šé«˜é€Ÿã«å‡¦ç†ã™ã‚‹ãŸã‚ã«ãã‚Œã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

{#if fw === 'pt'}

```python
import torch
from transformers import AutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns(["example_id", "offset_mapping"])
eval_set_for_model.set_format("torch")

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
batch = {k: eval_set_for_model[k].to(device) for k in eval_set_for_model.column_names}
trained_model = AutoModelForQuestionAnswering.from_pretrained(trained_checkpoint).to(
    device
)

with torch.no_grad():
    outputs = trained_model(**batch)
```

`Trainer`ã¯äºˆæ¸¬å€¤ã‚’NumPyã®é…åˆ—ã¨ã—ã¦ä¸ãˆã‚‹ã®ã§ã€é–‹å§‹ã¨çµ‚äº†ã®ãƒ­ã‚¸ãƒƒãƒˆã‚’å–å¾—ã—ã€ãã®å½¢å¼ã«å¤‰æ›ã—ã¾ã™ã€‚

```python
start_logits = outputs.start_logits.cpu().numpy()
end_logits = outputs.end_logits.cpu().numpy()
```

{:else}

```python
import tensorflow as tf
from transformers import TFAutoModelForQuestionAnswering

eval_set_for_model = eval_set.remove_columns(["example_id", "offset_mapping"])
eval_set_for_model.set_format("numpy")

batch = {k: eval_set_for_model[k] for k in eval_set_for_model.column_names}
trained_model = TFAutoModelForQuestionAnswering.from_pretrained(trained_checkpoint)

outputs = trained_model(**batch)
```

å®Ÿé¨“ã‚’å®¹æ˜“ã«ã™ã‚‹ãŸã‚ã«ã€ã“ã‚Œã‚‰ã®å‡ºåŠ›ã‚’NumPyã®é…åˆ—ã«å¤‰æ›ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```python
start_logits = outputs.start_logits.numpy()
end_logits = outputs.end_logits.numpy()
```

{/if}

ã•ã¦ã€`small_eval_set` ã«å«ã¾ã‚Œã‚‹å„ä¾‹ã«å¯¾ã—ã¦ã€äºˆæ¸¬ã•ã‚Œã‚‹ç­”ãˆã‚’è¦‹ã¤ã‘ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¸€ã¤ã®ä¾‹ã¯ã€`eval_set`ã®ä¸­ã§ã„ãã¤ã‹ã®ç‰¹å¾´ã«åˆ†å‰²ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ `small_eval_set` ã®ä¸­ã®å„ä¾‹ã‚’ `eval_set` ã®ä¸­ã®å¯¾å¿œã™ã‚‹ç‰¹å¾´ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ã“ã¨ã§ã™ã€‚

```python
import collections

example_to_features = collections.defaultdict(list)
for idx, feature in enumerate(eval_set):
    example_to_features[feature["example_id"]].append(idx)
```

ã“ã‚ŒãŒã‚ã‚Œã°ã€ã™ã¹ã¦ã®ä¾‹ã¨ã€ãã‚Œãã‚Œã®ä¾‹ã«ã¤ã„ã¦ã€é–¢é€£ã™ã‚‹ã™ã¹ã¦ã®ç‰¹å¾´ã‚’ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ã§ã€å®Ÿéš›ã«ä»•äº‹ã«å–ã‚Šæ›ã‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å‰ã«è¿°ã¹ãŸã‚ˆã†ã«ã€ã€Œn_bestã€ãªé–‹å§‹ãƒ­ã‚¸ãƒƒãƒˆã¨çµ‚äº†ãƒ­ã‚¸ãƒƒãƒˆã®ãƒ­ã‚¸ãƒƒãƒˆã‚¹ã‚³ã‚¢ã‚’è¦‹ã¾ã™ãŒã€ä»¥ä¸‹ã‚’é™¤ãã¾ã™ã€‚

- ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¸­ã«ãªã„ç­”ãˆ
- è² ã®é•·ã•ã‚’æŒã¤ç­”ãˆ
- é•·ã™ãã‚‹ç­”ãˆ (ç§é”ã¯ `max_answer_length=30` ã§å¯èƒ½æ€§ã‚’åˆ¶é™ã—ã¦ã„ã¾ã™)

1ã¤ã®ä¾‹ã«å¯¾ã—ã¦æ¡ç‚¹ã•ã‚ŒãŸã™ã¹ã¦ã®å¯èƒ½ãªç­”ãˆãŒã‚ã£ãŸã‚‰ã€æœ€é«˜ã®ãƒ­ã‚¸ãƒƒãƒˆã‚¹ã‚³ã‚¢ã‹ã‚‰1ã¤ã‚’é¸ã³ã¾ã™ã€‚

```python
import numpy as np

n_best = 20
max_answer_length = 30
predicted_answers = []

for example in small_eval_set:
    example_id = example["id"]
    context = example["context"]
    answers = []

    for feature_index in example_to_features[example_id]:
        start_logit = start_logits[feature_index]
        end_logit = end_logits[feature_index]
        offsets = eval_set["offset_mapping"][feature_index]

        start_indexes = np.argsort(start_logit)[-1 : -n_best - 1 : -1].tolist()
        end_indexes = np.argsort(end_logit)[-1 : -n_best - 1 : -1].tolist()
        for start_index in start_indexes:
            for end_index in end_indexes:
                # Skip answers that are not fully in the context
                if offsets[start_index] is None or offsets[end_index] is None:
                    continue
                # Skip answers with a length that is either < 0 or > max_answer_length.
                if (
                    end_index < start_index
                    or end_index - start_index + 1 > max_answer_length
                ):
                    continue

                answers.append(
                    {
                        "text": context[offsets[start_index][0] : offsets[end_index][1]],
                        "logit_score": start_logit[start_index] + end_logit[end_index],
                    }
                )

    best_answer = max(answers, key=lambda x: x["logit_score"])
    predicted_answers.append({"id": example_id, "prediction_text": best_answer["text"]})
```

äºˆæ¸¬ã•ã‚ŒãŸç­”ãˆã®æœ€çµ‚çš„ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ã€ç§ãŸã¡ãŒä½¿ç”¨ã™ã‚‹æŒ‡æ¨™ã«ã‚ˆã£ã¦æœŸå¾…ã•ã‚Œã‚‹ã‚‚ã®ã§ã™ã€‚ã„ã¤ã‚‚ã®ã‚ˆã†ã«ã€ğŸ¤— Evaluateãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åŠ©ã‘ã‚’å€Ÿã‚Šã¦èª­ã¿è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚

```python
import evaluate

metric = evaluate.load("squad")
```

ã“ã®æŒ‡æ¨™ã¯ã€ä¸Šã§è¦‹ãŸå½¢å¼ã®äºˆæ¸¬ã•ã‚ŒãŸç­”ãˆï¼ˆã‚µãƒ³ãƒ—ãƒ«ã®IDã¨äºˆæ¸¬ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã®1ã¤ã®ã‚­ãƒ¼ã‚’æŒã¤è¾æ›¸ã®ãƒªã‚¹ãƒˆï¼‰ã¨ã€ä¸‹ã®å½¢å¼ã®ç†è«–çš„ãªç­”ãˆï¼ˆã‚µãƒ³ãƒ—ãƒ«ã®IDã¨å¯èƒ½ãªç­”ãˆã®1ã¤ã®ã‚­ãƒ¼ã‚’æŒã¤è¾æ›¸ã®ãƒªã‚¹ãƒˆï¼‰ã‚’æœŸå¾…ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

```python
theoretical_answers = [
    {"id": ex["id"], "answers": ex["answers"]} for ex in small_eval_set
]
```

ã“ã“ã§ã€ä¸¡æ–¹ã®ãƒªã‚¹ãƒˆã®æœ€åˆã®è¦ç´ ã‚’è¦‹ã¦ã€è³¢æ˜ãªçµæœãŒå¾—ã‚‰ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```python
print(predicted_answers[0])
print(theoretical_answers[0])
```

```python out
{'id': '56be4db0acb8001400a502ec', 'prediction_text': 'Denver Broncos'}
{'id': '56be4db0acb8001400a502ec', 'answers': {'text': ['Denver Broncos', 'Denver Broncos', 'Denver Broncos'], 'answer_start': [177, 177, 177]}}
```

æ‚ªããªã„ã§ã™ã­ï¼ã§ã¯ã€ã“ã®æŒ‡æ¨™ãŒç¤ºã™ã‚¹ã‚³ã‚¢ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```python
metric.compute(predictions=predicted_answers, references=theoretical_answers)
```

```python out
{'exact_match': 83.0, 'f1': 88.25}
```

[ã“ã®è«–æ–‡](https://arxiv.org/abs/1910.01108v2)ã«ã‚ˆã‚‹ã¨ã€SQuADã§å¾®èª¿æ•´ã—ãŸDistilBERTã¯ã€å…¨ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã§79.1ç‚¹ã¨86.9ç‚¹ã‚’ç²å¾—ã—ã¦ã„ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã¨ã€ã“ã‚Œã¯ã‚€ã—ã‚è‰¯ã„ã“ã¨ã ã¨è¨€ãˆã¾ã™ã€‚

{#if fw === 'pt'}

ã“ã“ã§ã€å…ˆã»ã©è¡Œã£ãŸã“ã¨ã‚’ã™ã¹ã¦ `compute_metrics()` é–¢æ•°ã«ã¾ã¨ã‚ã¦ã€ `Trainer` ã§ä½¿ç”¨ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ã‚‡ã†ã€‚é€šå¸¸ã€ `compute_metrics()` é–¢æ•°ã¯ logits ã¨ labels ã‚’å«ã‚€ã‚¿ãƒ—ãƒ« `eval_preds` ã‚’å—ã‘å–ã‚‹ã ã‘ã§ã™ã€‚

ä»Šå›ã¯ã‚‚ã†å°‘ã—å¤šãã®æƒ…å ±ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚ã‚ªãƒ•ã‚»ãƒƒãƒˆç”¨ã®ç‰¹å¾´ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã¨ã€å…ƒã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’èª¿ã¹ãªã‘ã‚Œã°ãªã‚‰ãªã„ãŸã‚ã§ã™ã€‚
ãã®ãŸã‚ã€ã“ã®é–¢æ•°ã‚’ä½¿ã£ã¦å­¦ç¿’ä¸­ã«é€šå¸¸ã®è©•ä¾¡çµæœã‚’å¾—ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã“ã®é–¢æ•°ã¯å­¦ç¿’çµ‚äº†æ™‚ã«çµæœã‚’ç¢ºèªã™ã‚‹ãŸã‚ã ã‘ã«ä½¿ã„ã¾ã™ã€‚

compute_metrics()` é–¢æ•°ã¯ã€å‰ã¨åŒã˜ã‚¹ãƒ†ãƒƒãƒ—ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¾ã™ã€‚æœ‰åŠ¹ãªç­”ãˆãŒå¾—ã‚‰ã‚Œãªã‹ã£ãŸå ´åˆï¼ˆãã®å ´åˆã¯äºˆæ¸¬ã‚’ç©ºæ–‡å­—åˆ—ã¨ã—ã¾ã™ï¼‰ã«å‚™ãˆã¦ã€å°ã•ãªãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ ã—ã¦ã„ã‚‹ã ã‘ã§ã™ã€‚

{:else}

ã§ã¯ã€ä»Šã‚„ã£ãŸã“ã¨ã‚’ã™ã¹ã¦ `compute_metrics()` é–¢æ•°ã«ã¾ã¨ã‚ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã“ã®é–¢æ•°ã¯ãƒ¢ãƒ‡ãƒ«ã®å­¦ç¿’å¾Œã«ä½¿ç”¨ã—ã¾ã™ã€‚ã‚ªãƒ•ã‚»ãƒƒãƒˆç”¨ã®ç‰¹å¾´ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã¨ã€å…ƒã®æ–‡è„ˆã®ä¾‹æ–‡ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’èª¿ã¹ãªã‘ã‚Œã°ãªã‚‰ãªã„ã®ã§ã€å‡ºåŠ›ã®ãƒ­ã‚¸ãƒƒãƒˆã ã‘ã§ãªãã€ã‚‚ã†å°‘ã—å¤šãã®ãƒ‡ãƒ¼ã‚¿ã‚’æ¸¡ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

{/if}

```python
from tqdm.auto import tqdm


def compute_metrics(start_logits, end_logits, features, examples):
    example_to_features = collections.defaultdict(list)
    for idx, feature in enumerate(features):
        example_to_features[feature["example_id"]].append(idx)

    predicted_answers = []
    for example in tqdm(examples):
        example_id = example["id"]
        context = example["context"]
        answers = []

        # Loop through all features associated with that example
        for feature_index in example_to_features[example_id]:
            start_logit = start_logits[feature_index]
            end_logit = end_logits[feature_index]
            offsets = features[feature_index]["offset_mapping"]

            start_indexes = np.argsort(start_logit)[-1 : -n_best - 1 : -1].tolist()
            end_indexes = np.argsort(end_logit)[-1 : -n_best - 1 : -1].tolist()
            for start_index in start_indexes:
                for end_index in end_indexes:
                    # Skip answers that are not fully in the context
                    if offsets[start_index] is None or offsets[end_index] is None:
                        continue
                    # Skip answers with a length that is either < 0 or > max_answer_length
                    if (
                        end_index < start_index
                        or end_index - start_index + 1 > max_answer_length
                    ):
                        continue

                    answer = {
                        "text": context[offsets[start_index][0] : offsets[end_index][1]],
                        "logit_score": start_logit[start_index] + end_logit[end_index],
                    }
                    answers.append(answer)

        # Select the answer with the best score
        if len(answers) > 0:
            best_answer = max(answers, key=lambda x: x["logit_score"])
            predicted_answers.append(
                {"id": example_id, "prediction_text": best_answer["text"]}
            )
        else:
            predicted_answers.append({"id": example_id, "prediction_text": ""})

    theoretical_answers = [{"id": ex["id"], "answers": ex["answers"]} for ex in examples]
    return metric.compute(predictions=predicted_answers, references=theoretical_answers)
```

ç§é”ã®äºˆæ¸¬ã‚’ä½¿ã£ã¦å‹•ä½œç¢ºèªãŒã§ãã¾ã™ã€‚

```python
compute_metrics(start_logits, end_logits, eval_set, small_eval_set)
```

```python out
{'exact_match': 83.0, 'f1': 88.25}
```

ã„ã„æ„Ÿã˜ã§ã™ï¼ã§ã¯ã€ã“ã‚Œã‚’ä½¿ã£ã¦ãƒ¢ãƒ‡ãƒ«ã‚’å¾®èª¿æ•´ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

### ãƒ¢ãƒ‡ãƒ«ã®å¾®èª¿æ•´

{#if fw === 'pt'}

ã“ã‚Œã§ãƒ¢ãƒ‡ãƒ«ã‚’å­¦ç¿’ã™ã‚‹æº–å‚™ãŒã§ãã¾ã—ãŸã€‚å…ˆç¨‹ã¨åŒã˜ã‚ˆã†ã« `AutoModelForQuestionAnswering` ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã€ã¾ãšãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆã—ã¾ã—ã‚‡ã†ã€‚

```python
model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)
```

{:else}

ã“ã‚Œã§ãƒ¢ãƒ‡ãƒ«ã‚’å­¦ç¿’ã™ã‚‹æº–å‚™ãŒã§ãã¾ã—ãŸã€‚ã¾ãšã€å‰ã¨åŒã˜ã‚ˆã†ã« `TFAutoModelForQuestionAnswering` ã‚¯ãƒ©ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆã—ã¾ã—ã‚‡ã†ã€‚

```python
model = TFAutoModelForQuestionAnswering.from_pretrained(model_checkpoint)
```

{/if}

ã„ã¤ã‚‚ã®ã‚ˆã†ã«ã€ã„ãã¤ã‹ã®é‡ã¿ãŒä½¿ã‚ã‚Œã¦ã„ãªã„ï¼ˆäº‹å‰å­¦ç¿’æ™‚ã®ãƒ˜ãƒƒãƒ‰ã®ã‚‚ã®ï¼‰ã€ä»–ã®ã„ãã¤ã‹ã®é‡ã¿ãŒãƒ©ãƒ³ãƒ€ãƒ ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ï¼ˆè³ªå•å¿œç­”ç”¨ãƒ˜ãƒƒãƒ‰ã®ã‚‚ã®ï¼‰ã¨ã„ã†è­¦å‘ŠãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ã‚‚ã†æ…£ã‚ŒãŸã¨æ€ã„ã¾ã™ãŒã€ã“ã‚Œã¯ã“ã®ãƒ¢ãƒ‡ãƒ«ãŒã¾ã ä½¿ãˆã‚‹çŠ¶æ…‹ã§ã¯ãªãã€å¾®èª¿æ•´ãŒå¿…è¦ã§ã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚

ã“ã®ãƒ¢ãƒ‡ãƒ«ã‚’Hubã«ãƒ—ãƒƒã‚·ãƒ¥ã™ã‚‹ãŸã‚ã«ã¯ã€Hugging Faceã«ãƒ­ã‚°ã‚¤ãƒ³ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚‚ã—ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’notebookã§å®Ÿè¡Œã—ã¦ã„ã‚‹ãªã‚‰ã€æ¬¡ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ã§ãƒ­ã‚°ã‚¤ãƒ³ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```python
from huggingface_hub import notebook_login

notebook_login()
```

ãƒãƒ¼ãƒˆãƒ–ãƒƒã‚¯ã§ä½œæ¥­ã—ã¦ã„ãªã„å ´åˆã¯ã€ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§æ¬¡ã®è¡Œã‚’å…¥åŠ›ã™ã‚‹ã ã‘ã§ã™ã€‚

```bash
huggingface-cli login
```

{#if fw === 'pt'}

ã“ã‚ŒãŒå®Œäº†ã—ãŸã‚‰ã€`TrainingArguments` ã‚’å®šç¾©ã—ã¾ã™ã€‚æŒ‡æ¨™ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã‚’å®šç¾©ã—ãŸã¨ãã«è¨€ã£ãŸã‚ˆã†ã«ã€ `compute_metrics()` é–¢æ•°ã®åˆ¶é™ã®ãŸã‚ã«ã€é€šå¸¸ã®è©•ä¾¡ãƒ«ãƒ¼ãƒ—ã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«ã€ç‹¬è‡ªã® `Trainer` ã®ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã‚’æ›¸ãã“ã¨ã‚‚ã§ãã¾ã™ãŒ (ã“ã®æ–¹æ³•ã¯ [è³ªå•å¿œç­”ä¾‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ](https://github.com/huggingface/transformers/blob/master/examples/pytorch/question-answering/trainer_qa.py) ã«ã‚ã‚Šã¾ã™)ã€ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¯ã¡ã‚‡ã£ã¨é•·ã™ãã¾ã™ã­ã€‚ãã®ä»£ã‚ã‚Šã€ã“ã“ã§ã¯å­¦ç¿’ã®æœ€å¾Œã«ãƒ¢ãƒ‡ãƒ«ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ã ã‘ã‚’è¡Œã„ã€é€šå¸¸ã®è©•ä¾¡ã®æ–¹æ³•ã¯å¾Œè¿°ã®ã€Œã‚«ã‚¹ã‚¿ãƒ å­¦ç¿’ãƒ«ãƒ¼ãƒ—ã€ã§ç´¹ä»‹ã—ã¾ã™ã€‚

ã“ã‚Œã¯ `Trainer` API ã®é™ç•Œã§ã‚ã‚Šã€ğŸ¤— Accelerate ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒè¼ãã¨ã“ã‚ã§ã™ã€‚ç‰¹å®šã®ç”¨ä¾‹ã«åˆã‚ã›ã¦ã‚¯ãƒ©ã‚¹ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹ã®ã¯å¤§å¤‰ã§ã™ãŒã€å®Œå…¨ã«å…¬é–‹ã•ã‚ŒãŸå­¦ç¿’ãƒ«ãƒ¼ãƒ—ã‚’èª¿æ•´ã™ã‚‹ã®ã¯ç°¡å˜ã§ã™ã€‚

ãã‚Œã§ã¯ã€`TrainingArguments` ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```python
from transformers import TrainingArguments

args = TrainingArguments(
    "bert-finetuned-squad",
    evaluation_strategy="no",
    save_strategy="epoch",
    learning_rate=2e-5,
    num_train_epochs=3,
    weight_decay=0.01,
    fp16=True,
    push_to_hub=True,
)
```

ã“ã‚Œã‚‰ã®ã»ã¨ã‚“ã©ã¯ä»¥å‰ã«ã‚‚è¦‹ãŸã“ã¨ãŒã‚ã‚‹ã¨æ€ã„ã¾ã™ã€‚

ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆå­¦ç¿’ç‡ã€å­¦ç¿’ã‚¨ãƒãƒƒã‚¯æ•°ã€ã‚¦ã‚§ã‚¤ãƒˆæ¸›è¡°ãªã©ï¼‰ã‚’è¨­å®šã—ã€ã‚¨ãƒãƒƒã‚¯çµ‚äº†ã”ã¨ã«ãƒ¢ãƒ‡ãƒ«ã‚’ä¿å­˜ã—ã€è©•ä¾¡ã‚’çœç•¥ã—ã€çµæœã‚’ãƒ¢ãƒ‡ãƒ«ãƒãƒ–ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã¾ãŸã€`fp16=True`ã§æ··åˆç²¾åº¦å­¦ç¿’ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã€‚æœ€è¿‘ã®GPUã§ã¯ã€æ··åˆç²¾åº¦å­¦ç¿’ãŒã†ã¾ãã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—ã™ã‚‹ã‹ã‚‰ã§ã™ã€‚

{:else}

ã“ã‚Œã§ã€TFãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```python
from transformers import DefaultDataCollator

data_collator = DefaultDataCollator(return_tensors="tf")
```

ãã—ã¦ã€ä»Šåº¦ã¯ã„ã¤ã‚‚é€šã‚Šãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚

```python
tf_train_dataset = train_dataset.to_tf_dataset(
    columns=[
        "input_ids",
        "start_positions",
        "end_positions",
        "attention_mask",
        "token_type_ids",
    ],
    collate_fn=data_collator,
    shuffle=True,
    batch_size=16,
)
tf_eval_dataset = validation_dataset.to_tf_dataset(
    columns=["input_ids", "attention_mask", "token_type_ids"],
    collate_fn=data_collator,
    shuffle=False,
    batch_size=16,
)
```

æ¬¡ã«ã€å­¦ç¿’ç”¨ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¨­å®šã—ã€ãƒ¢ãƒ‡ãƒ«ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¾ã™ã€‚

```python
from transformers import create_optimizer
from transformers.keras_callbacks import PushToHubCallback
import tensorflow as tf

# The number of training steps is the number of samples in the dataset, divided by the batch size then multiplied
# by the total number of epochs. Note that the tf_train_dataset here is a batched tf.data.Dataset,
# not the original Hugging Face Dataset, so its len() is already num_samples // batch_size.
num_train_epochs = 3
num_train_steps = len(tf_train_dataset) * num_train_epochs
optimizer, schedule = create_optimizer(
    init_lr=2e-5,
    num_warmup_steps=0,
    num_train_steps=num_train_steps,
    weight_decay_rate=0.01,
)
model.compile(optimizer=optimizer)

# Train in mixed-precision float16
tf.keras.mixed_precision.set_global_policy("mixed_float16")
```

æœ€å¾Œã«ã€`model.fit()`ã§å­¦ç¿’ã™ã‚‹æº–å‚™ãŒã§ãã¾ã—ãŸã€‚`PushToHubCallback`ã‚’ä½¿ç”¨ã—ã¦ã€å„ã‚¨ãƒãƒƒã‚¯å¾Œã«ãƒ¢ãƒ‡ãƒ«ã‚’ãƒãƒ–ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚

{/if}

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ä½¿ç”¨ã•ã‚Œã‚‹ãƒªãƒã‚¸ãƒˆãƒªã¯ã‚ãªãŸã®åå‰ç©ºé–“ã«ã‚ã‚Šã€è¨­å®šã—ãŸå‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®åå‰ã«ãªã‚Šã¾ã™ã€‚
ã“ã®ä¾‹ã§ã¯ã€ `"sgugger/bert-finetuned-squad"` ã«ãªã‚Šã¾ã™ã€‚

`hub_model_id` ã‚’æ¸¡ã™ã“ã¨ã§ã€ã“ã‚Œã‚’ä¸Šæ›¸ãã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€ãƒ¢ãƒ‡ãƒ«ã‚’ `huggingface_course` ã¨ã„ã†çµ„ç¹”ã«ãƒ—ãƒƒã‚·ãƒ¥ã™ã‚‹ã«ã¯ã€ `hub_model_id="huggingface_course/bert-finetuned-squad"`(ã“ã®ç« ã®å§‹ã‚ã§ãƒªãƒ³ã‚¯ã—ãŸãƒ¢ãƒ‡ãƒ«ã§ã™) ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

{#if fw === 'pt'}

<Tip>

ğŸ’¡ ä½¿ç”¨ã™ã‚‹å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ã€ãƒ—ãƒƒã‚·ãƒ¥ã—ãŸã„ãƒªãƒã‚¸ãƒˆãƒªã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚¯ãƒ­ãƒ¼ãƒ³ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ (ã—ãŸãŒã£ã¦ã€`Trainer` ã®å®šç¾©æ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€æ–°ã—ã„åå‰ã‚’è¨­å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™)ã€‚

</Tip>

æœ€å¾Œã«ã€ã™ã¹ã¦ã‚’ `Trainer` ã‚¯ãƒ©ã‚¹ã«æ¸¡ã—ã¦ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’é–‹å§‹ã™ã‚‹ã ã‘ã§ã™ã€‚

```python
from transformers import Trainer

trainer = Trainer(
    model=model,
    args=args,
    train_dataset=train_dataset,
    eval_dataset=validation_dataset,
    tokenizer=tokenizer,
)
trainer.train()
```

{:else}

```python
from transformers.keras_callbacks import PushToHubCallback

callback = PushToHubCallback(output_dir="bert-finetuned-squad", tokenizer=tokenizer)

# We're going to do validation afterwards, so no validation mid-training
model.fit(tf_train_dataset, callbacks=[callback], epochs=num_train_epochs)
```

{/if}

å­¦ç¿’ãŒè¡Œã‚ã‚Œã¦ã„ã‚‹é–“ã€ãƒ¢ãƒ‡ãƒ«ãŒä¿å­˜ã•ã‚Œã‚‹ãŸã³ã«ï¼ˆã“ã“ã§ã¯ã‚¨ãƒãƒƒã‚¯ã”ã¨ã«ï¼‰ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ãƒãƒ–ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã†ã™ã‚‹ã“ã¨ã§ã€å¿…è¦ã«å¿œã˜ã¦åˆ¥ã®ãƒã‚·ãƒ³ã§ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’å†é–‹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°å…¨ä½“ã«ã¯ã—ã°ã‚‰ãæ™‚é–“ãŒã‹ã‹ã‚‹ã®ã§ï¼ˆTitan RTXã§1æ™‚é–“å¼·ï¼‰ã€ãã®é–“ã‚³ãƒ¼ãƒ’ãƒ¼ã‚’é£²ã‚“ã ã‚Šã€ã‚³ãƒ¼ã‚¹ã®é›£ã—ã„éƒ¨åˆ†ã‚’èª­ã¿ç›´ã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¾ãŸã€æœ€åˆã®ã‚¨ãƒãƒƒã‚¯ãŒçµ‚äº†ã™ã‚‹ã¨ã™ãã«ã€ã„ãã¤ã‹ã®é‡ã¿ãŒãƒãƒ–ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã€ãã®ãƒšãƒ¼ã‚¸ã§ã‚ãªãŸã®ãƒ¢ãƒ‡ãƒ«ã§éŠã³å§‹ã‚ã‚‹ã“ã¨ãŒã§ãã‚‹ã“ã¨ã«ç•™æ„ã—ã¦ãã ã•ã„ã€‚

{#if fw === 'pt'}

å­¦ç¿’ãŒå®Œäº†ã—ãŸã‚‰ã€æœ€å¾Œã«ãƒ¢ãƒ‡ãƒ«ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ˆãã—ã¦ã€ç„¡é§„ã«è¨ˆç®—æ™‚é–“ã‚’è²»ã‚„ã•ãªã„ã‚ˆã†ã«ç¥ˆã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ï¼‰ã€‚`Trainer` ã® `predict()` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¿ãƒ—ãƒ«ã‚’è¿”ã—ã€ãã®æœ€åˆã®è¦ç´ ã¯ãƒ¢ãƒ‡ãƒ«ã®äºˆæ¸¬å€¤ï¼ˆã“ã“ã§ã¯é–‹å§‹ãƒ­ã‚¸ãƒƒãƒˆã¨çµ‚äº†ãƒ­ã‚¸ãƒƒãƒˆã®ãƒšã‚¢ï¼‰ã¨ãªã‚Šã¾ã™ã€‚ã“ã‚Œã‚’ `compute_metrics()` é–¢æ•°ã«é€ã‚Šã¾ã™ã€‚

```python
predictions, _, _ = trainer.predict(validation_dataset)
start_logits, end_logits = predictions
compute_metrics(start_logits, end_logits, validation_dataset, raw_datasets["validation"])
```

{:else}

å­¦ç¿’ãŒå®Œäº†ã—ãŸã‚‰ã€æœ€å¾Œã«ãƒ¢ãƒ‡ãƒ«ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ˆãã—ã¦ã€ç„¡é§„ã«è¨ˆç®—æ™‚é–“ã‚’è²»ã‚„ã—ã¦ã„ãªã„ã“ã¨ã‚’ç¥ˆã‚Šã¾ã™ï¼‰ã€‚äºˆæ¸¬å€¤ã®å–å¾—ã¯ `model` ã® `predict()` ãƒ¡ã‚½ãƒƒãƒ‰ã§è¡Œã„ã¾ã™ã€‚ã¾ãŸã€å…ˆã»ã© `compute_metrics()` é–¢æ•°ã‚’å®šç¾©ã—ã¦è‹¦åŠ´ã—ãŸã®ã§ã€1è¡Œã§çµæœã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```python
predictions = model.predict(tf_eval_dataset)
compute_metrics(
    predictions["start_logits"],
    predictions["end_logits"],
    validation_dataset,
    raw_datasets["validation"],
)
```

{/if}

```python out
{'exact_match': 81.18259224219489, 'f1': 88.67381321905516}
```

ç´ æ™´ã‚‰ã—ã„ï¼
æ¯”è¼ƒã¨ã—ã¦ã€ã“ã®ãƒ¢ãƒ‡ãƒ«ã®BERTã®è¨˜äº‹ã§å ±å‘Šã•ã‚Œã¦ã„ã‚‹ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã®ã‚¹ã‚³ã‚¢ã¯80.8ã¨88.5ãªã®ã§ã€ã¡ã‚‡ã†ã©ã‚ã‚‹ã¹ãã¨ã“ã‚ã«ã„ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

{#if fw === 'pt'}

æœ€å¾Œã«ã€`push_to_hub()`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚

```py
trainer.push_to_hub(commit_message="Training complete")
```

ã“ã‚Œã¯ã€ä»Šè¡Œã£ãŸã‚³ãƒŸãƒƒãƒˆã® URL ã‚’è¿”ã—ã¾ã™ã€‚ã‚‚ã—ãã‚Œã‚’æ¤œæŸ»ã—ãŸã„ã®ã§ã‚ã‚Œã°ã€ãã® URL ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚

```python out
'https://huggingface.co/sgugger/bert-finetuned-squad/commit/9dcee1fbc25946a6ed4bb32efb1bd71d5fa90b68'
```

ã¾ãŸã€`Trainer`ã¯è©•ä¾¡çµæœã‚’ã¾ã¨ã‚ãŸãƒ¢ãƒ‡ãƒ«ã‚«ãƒ¼ãƒ‰ã‚’èµ·æ¡ˆã—ã€ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚

{/if}

ã“ã®æ®µéšã§ã€ãƒ¢ãƒ‡ãƒ«ãƒãƒ–ä¸Šã®æ¨è«–ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã‚’ä½¿ã£ã¦ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ†ã‚¹ãƒˆã—ã€å‹äººã€å®¶æ—ã€ãŠæ°—ã«å…¥ã‚Šã®ãƒšãƒƒãƒˆã¨å…±æœ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚ãªãŸã¯ã€è³ªå•å¿œç­”ã‚¿ã‚¹ã‚¯ã§ãƒ¢ãƒ‡ãƒ«ã®å¾®èª¿æ•´ã«æˆåŠŸã—ã¾ã—ãŸã€‚ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼

<Tip>

âœï¸ **ã‚ãªãŸã®ç•ªã§ã™ï¼** ã“ã®ã‚¿ã‚¹ã‚¯ã§ã‚ˆã‚Šè‰¯ã„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒå¾—ã‚‰ã‚Œã‚‹ã‹ã©ã†ã‹ã€åˆ¥ã®ãƒ¢ãƒ‡ãƒ«ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’è©¦ã—ã¦ã¿ã¦ãã ã•ã„ï¼

</Tip>

{#if fw === 'pt'}

ã‚‚ã†å°‘ã—æ·±ããƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¥µã‚ãŸã„æ–¹ã¯ã€ä»Šåº¦ã¯ğŸ¤—Accelerateã‚’ä½¿ã£ã¦åŒã˜ã“ã¨ã‚’ã™ã‚‹æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

## ã‚«ã‚¹ã‚¿ãƒ ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—

ãã‚Œã§ã¯ã€å¿…è¦ãªéƒ¨åˆ†ã‚’ç°¡å˜ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹ã‚ˆã†ã«ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã®å…¨ä½“åƒã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚[ç¬¬3ç« ](/course/ja/chapter3/4)ã®å­¦ç¿’ãƒ«ãƒ¼ãƒ—ã¨ã»ã¼åŒã˜ã§ã™ãŒã€è©•ä¾¡ãƒ«ãƒ¼ãƒ—ã¯ä¾‹å¤–ã§ã™ã€‚ã‚‚ã† `Trainer` ã‚¯ãƒ©ã‚¹ã®åˆ¶ç´„ã‚’å—ã‘ãªã„ã®ã§ã€å®šæœŸçš„ã«ãƒ¢ãƒ‡ãƒ«ã‚’è©•ä¾¡ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

### ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã®ãŸã‚ã®ã™ã¹ã¦ã‚’æº–å‚™ã™ã‚‹

ã¾ãšã€datasetsã‹ã‚‰ `DataLoader` ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚ãã‚Œã‚‰ã®datasetsã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ `"torch"` ã«è¨­å®šã—ã€æ¤œè¨¼ç”¨ã‚»ãƒƒãƒˆã®ä¸­ã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ã§ä½¿ç”¨ã—ãªã„ã‚«ãƒ©ãƒ ã‚’å‰Šé™¤ã—ã¾ã™ã€‚æ¬¡ã«ã€Transformers ãŒæä¾›ã™ã‚‹ `default_data_collator` ã‚’ `collate_fn` ã¨ã—ã¦ä½¿ç”¨ã—ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚»ãƒƒãƒˆã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã™ãŒã€æ¤œè¨¼ã‚»ãƒƒãƒˆã¯ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¾ã›ã‚“ã€‚

```py
from torch.utils.data import DataLoader
from transformers import default_data_collator

train_dataset.set_format("torch")
validation_set = validation_dataset.remove_columns(["example_id", "offset_mapping"])
validation_set.set_format("torch")

train_dataloader = DataLoader(
    train_dataset,
    shuffle=True,
    collate_fn=default_data_collator,
    batch_size=8,
)
eval_dataloader = DataLoader(
    validation_set, collate_fn=default_data_collator, batch_size=8
)
```

æ¬¡ã«ã€ãƒ¢ãƒ‡ãƒ«ã®å†å®šç¾©ã‚’è¡Œã„ã¾ã™ã€‚ã“ã‚Œã¯ã€ä»¥å‰ã®å¾®èª¿æ•´ã‚’ç¶™ç¶šã™ã‚‹ã®ã§ã¯ãªãã€BERTã§äº‹å‰å­¦ç¿’ã—ãŸãƒ¢ãƒ‡ãƒ«ã‹ã‚‰å†ã³é–‹å§‹ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã§ã™ã€‚

```py
model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)
```

ãã‚Œã‹ã‚‰ã€ã‚ªãƒ—ãƒ†ã‚£ãƒã‚¤ã‚¶ãƒ¼ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚ã„ã¤ã‚‚ã®ã‚ˆã†ã«ã€å¤å…¸çš„ãª `AdamW` ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã¯ Adam ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ãŒã€é‡ã¿ã®æ¸›è¡°ã®é©ç”¨æ–¹æ³•ã‚’ä¿®æ­£ã—ãŸã‚‚ã®ã§ã™ã€‚

```py
from torch.optim import AdamW

optimizer = AdamW(model.parameters(), lr=2e-5)
```

ã“ã‚Œã‚‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæƒã£ãŸã‚‰ã€ãã‚Œã‚‰ã‚’ `accelerator.prepare()` ãƒ¡ã‚½ãƒƒãƒ‰ã«é€ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã‚‚ã—ã€Colabãƒãƒ¼ãƒˆãƒ–ãƒƒã‚¯ã§TPUã‚’ä½¿ã£ãŸãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’ã—ãŸã„ã®ã§ã‚ã‚Œã°ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’å…¨ã¦ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°é–¢æ•°ã«ç§»å‹•ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°é–¢æ•°ã¯`Accelerator`ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ã‚»ãƒ«ã‚’å®Ÿè¡Œã™ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`Accelerator`ã« `fp16=True` ã‚’æ¸¡ã™ã“ã¨ã§ã€å¼·åˆ¶çš„ã«æ··åˆç²¾åº¦ã®ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™ (ã¾ãŸã¯ã€ã‚³ãƒ¼ãƒ‰ã‚’ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨ã—ã¦å®Ÿè¡Œã™ã‚‹å ´åˆã¯ã€ğŸ¤— Accelerate `config` ã‚’é©åˆ‡ã«åŸ‹ã‚ã¦ãã ã•ã„)ã€‚

```py
from accelerate import Accelerator

accelerator = Accelerator(fp16=True)
model, optimizer, train_dataloader, eval_dataloader = accelerator.prepare(
    model, optimizer, train_dataloader, eval_dataloader
)
```

å‰ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§å­¦ã‚“ã ã‚ˆã†ã«ã€`train_dataloader` ã®é•·ã•ã¯ `accelerator.prepare()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’çµŒãŸå¾Œã§ã®ã¿ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚¹ãƒ†ãƒƒãƒ—æ•°ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã“ã§ã¯ã€ã“ã‚Œã¾ã§ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨åŒã˜ç·šå½¢ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```py
from transformers import get_scheduler

num_train_epochs = 3
num_update_steps_per_epoch = len(train_dataloader)
num_training_steps = num_train_epochs * num_update_steps_per_epoch

lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps,
)
```

ãƒ¢ãƒ‡ãƒ«ã‚’ãƒãƒ–ã«ãƒ—ãƒƒã‚·ãƒ¥ã™ã‚‹ã«ã¯ã€ä½œæ¥­ãƒ•ã‚©ãƒ«ãƒ€ã« `Repository` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã¾ãšã€ãƒã‚®ãƒ³ã‚° ãƒ•ã‚§ã‚¤ã‚¹ ãƒãƒ–ã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ï¼ˆã¾ã ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ãªã„å ´åˆï¼‰ã€‚ãƒ¢ãƒ‡ãƒ«ã«ä»˜ä¸ã—ãŸã„ãƒ¢ãƒ‡ãƒ« ID ã‹ã‚‰ãƒªãƒã‚¸ãƒˆãƒªåã‚’æ±ºå®šã—ã¾ã™ï¼ˆ`repo_name` ã‚’è‡ªç”±ã«ç½®ãæ›ãˆã¦ãã ã•ã„ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã€ã“ã‚Œã¯é–¢æ•° `get_full_repo_name()` ãŒè¡Œã£ã¦ã„ã‚‹äº‹ã§ã™)ã€‚

```py
from huggingface_hub import Repository, get_full_repo_name

model_name = "bert-finetuned-squad-accelerate"
repo_name = get_full_repo_name(model_name)
repo_name
```

```python out
'sgugger/bert-finetuned-squad-accelerate'
```

ãã—ã¦ã€ãã®ãƒªãƒã‚¸ãƒˆãƒªã‚’ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã«ã‚¯ãƒ­ãƒ¼ãƒ³ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã™ã§ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ã€ã“ã®ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼ã¯ä½œæ¥­ä¸­ã®ãƒªãƒã‚¸ãƒˆãƒªã®ã‚¯ãƒ­ãƒ¼ãƒ³ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```py
output_dir = "bert-finetuned-squad-accelerate"
repo = Repository(output_dir, clone_from=repo_name)
```

ã“ã‚Œã§ `repo.push_to_hub()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€`output_dir` ã«ä¿å­˜ã—ãŸã‚‚ã®ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å„ã‚¨ãƒãƒƒã‚¯çµ‚äº†æ™‚ã«ä¸­é–“ãƒ¢ãƒ‡ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

## ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—

ã“ã‚Œã§ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã®å…¨ä½“ã‚’è¨˜è¿°ã™ã‚‹æº–å‚™ãŒæ•´ã„ã¾ã—ãŸã€‚ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã®é€²æ—ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’å®šç¾©ã—ãŸå¾Œã€ãƒ«ãƒ¼ãƒ—ã¯3ã¤ã®éƒ¨åˆ†ã«åˆ†ã‹ã‚Œã¾ã™ã€‚

- è¨“ç·´è‡ªä½“ã¯ã€`train_dataloader`ã«å¯¾ã™ã‚‹å¤å…¸çš„ãªç¹°ã‚Šè¿”ã—ã§ã€ãƒ¢ãƒ‡ãƒ«ã‚’å‰æ–¹ã«é€šéã•ã›ã€å¾Œæ–¹ã«é€šéã•ã›ã€ã‚ªãƒ—ãƒ†ã‚£ãƒã‚¤ã‚¶ãƒ¼ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¡Œã„ã¾ã™ã€‚

- è©•ä¾¡ã§ã¯ã€`start_logits` ã¨ `end_logits` ã®å€¤ã‚’ã™ã¹ã¦åé›†ã—ã€NumPy ã®é…åˆ—ã«å¤‰æ›ã—ã¾ã™ã€‚è©•ä¾¡ãƒ«ãƒ¼ãƒ—ãŒçµ‚äº†ã—ãŸã‚‰ã€ã™ã¹ã¦ã®çµæœã‚’é€£çµã—ã¾ã™ã€‚å„å‡¦ç†ã§åŒã˜æ•°ã®ã‚µãƒ³ãƒ—ãƒ«ãŒå¾—ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã€`Accelerator`ãŒæœ€å¾Œã«ã„ãã¤ã‹ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’è¿½åŠ ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€åˆ‡ã‚Šæ¨ã¦ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚

- ä¿å­˜ã¨ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã§ã¯ã€ã¾ãšãƒ¢ãƒ‡ãƒ«ã¨ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼ã‚’ä¿å­˜ã—ã€æ¬¡ã« `repo.push_to_hub()` ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚å‰å›ã¨åŒæ§˜ã«ã€å¼•æ•° `blocking=False` ã‚’ä½¿ã£ã¦ğŸ¤— Hubãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«éåŒæœŸå‡¦ç†ã§ãƒ—ãƒƒã‚·ãƒ¥ã™ã‚‹ã‚ˆã†ã«æŒ‡ç¤ºã—ã¾ã™ã€‚ã“ã†ã™ã‚‹ã“ã¨ã§ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã¯é€šå¸¸é€šã‚Šè¡Œã‚ã‚Œã€ã“ã®ï¼ˆé•·ã„æ™‚é–“ã®ã‹ã‹ã‚‹ï¼‰å‘½ä»¤ã¯ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã®å®Œå…¨ãªã‚³ãƒ¼ãƒ‰ã§ã™ã€‚

```py
from tqdm.auto import tqdm
import torch

progress_bar = tqdm(range(num_training_steps))

for epoch in range(num_train_epochs):
    # Training
    model.train()
    for step, batch in enumerate(train_dataloader):
        outputs = model(**batch)
        loss = outputs.loss
        accelerator.backward(loss)

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)

    # Evaluation
    model.eval()
    start_logits = []
    end_logits = []
    accelerator.print("Evaluation!")
    for batch in tqdm(eval_dataloader):
        with torch.no_grad():
            outputs = model(**batch)

        start_logits.append(accelerator.gather(outputs.start_logits).cpu().numpy())
        end_logits.append(accelerator.gather(outputs.end_logits).cpu().numpy())

    start_logits = np.concatenate(start_logits)
    end_logits = np.concatenate(end_logits)
    start_logits = start_logits[: len(validation_dataset)]
    end_logits = end_logits[: len(validation_dataset)]

    metrics = compute_metrics(
        start_logits, end_logits, validation_dataset, raw_datasets["validation"]
    )
    print(f"epoch {epoch}:", metrics)

    # Save and upload
    accelerator.wait_for_everyone()
    unwrapped_model = accelerator.unwrap_model(model)
    unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)
    if accelerator.is_main_process:
        tokenizer.save_pretrained(output_dir)
        repo.push_to_hub(
            commit_message=f"Training in progress epoch {epoch}", blocking=False
        )
```

ğŸ¤—Accelerateã§ä¿å­˜ã•ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ã‚’åˆã‚ã¦è¡¨ç¤ºã™ã‚‹å ´åˆã¯ã€ãã‚Œã«ä»˜éšã™ã‚‹3è¡Œã®ã‚³ãƒ¼ãƒ‰ã‚’èª¿ã¹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```py
accelerator.wait_for_everyone()
unwrapped_model = accelerator.unwrap_model(model)
unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)
```

æœ€åˆã®è¡Œã¯è‡ªæ˜ã§ã™ã€‚ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚»ã‚¹ã«ã€å…¨å“¡ãŒãã®æ®µéšã«ãªã‚‹ã¾ã§å¾…ã£ã¦ã‹ã‚‰ç¶šè¡Œã™ã‚‹ã‚ˆã†ã«æŒ‡ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ä¿å­˜ã™ã‚‹å‰ã«ã€ã™ã¹ã¦ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒåŒã˜ãƒ¢ãƒ‡ãƒ«ã‚’å¯¾è±¡ã«ã—ã¦ã„ã‚‹äº‹ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã§ã™ã€‚æ¬¡ã«ã€å®šç¾©ã—ãŸãƒ™ãƒ¼ã‚¹ãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹`unwrapped_model`ã‚’å–å¾—ã—ã¾ã™ã€‚ `accelerator.prepareï¼ˆï¼‰`ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€åˆ†æ•£ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã§æ©Ÿèƒ½ã™ã‚‹ã‚ˆã†ã«ãƒ¢ãƒ‡ãƒ«ã‚’å¤‰æ›´ã™ã‚‹ãŸã‚ã€ `save_pretrainedï¼ˆï¼‰`ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãªããªã‚Šã¾ã™ã€‚ `accelerator.unwrap_modelï¼ˆï¼‰`ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’å…ƒã«æˆ»ã—ã¾ã™ã€‚æœ€å¾Œã«ã€ `save_pretrainedï¼ˆï¼‰`ã‚’å‘¼ã³å‡ºã—ã¾ã™ãŒã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã« `torch.saveï¼ˆï¼‰`ã®ä»£ã‚ã‚Šã« `accelerator.saveï¼ˆï¼‰`ã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«æŒ‡ç¤ºã—ã¾ã™ã€‚

ã“ã‚ŒãŒå®Œäº†ã™ã‚‹ã¨ã€`Trainer`ã§ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã•ã‚ŒãŸã‚‚ã®ã¨éå¸¸ã«ã‚ˆãä¼¼ãŸçµæœã‚’ç”Ÿæˆã™ã‚‹ãƒ¢ãƒ‡ãƒ«ãŒã§ãã‚ãŒã‚Šã¾ã™ã€‚ ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã—ãŸãƒ¢ãƒ‡ãƒ«ã¯ã€[*huggingface-course/bert-finetuned-squad-accelerate*]ï¼ˆhttps://huggingface.co/huggingface-course/bert-finetuned-squad-accelerateï¼‰ã§ç¢ºèªã§ãã¾ã™ã€‚ ã¾ãŸã€ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã®å¾®èª¿æ•´ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹å ´åˆã¯ã€ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã‚’ç·¨é›†ã—ã¦ç›´æ¥å®Ÿè£…ã§ãã¾ã™ï¼

{/if}

## å¾®èª¿æ•´ã—ãŸãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹

ãƒ¢ãƒ‡ãƒ«ãƒãƒ–ã§å¾®èª¿æ•´ã—ãŸãƒ¢ãƒ‡ãƒ«ã‚’æ¨è«–ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆã§ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã¯æ—¢ã«ç´¹ä»‹ã—ã¾ã—ãŸã€‚`pipeline`ã§åˆ©ç”¨ã™ã‚‹å ´åˆã¯ã€ãƒ¢ãƒ‡ãƒ«è­˜åˆ¥å­ã‚’æŒ‡å®šã—ã¾ã™ã€‚

```py
from transformers import pipeline

# Replace this with your own checkpoint
model_checkpoint = "huggingface-course/bert-finetuned-squad"
question_answerer = pipeline("question-answering", model=model_checkpoint)

context = """
ğŸ¤— Transformers is backed by the three most popular deep learning libraries â€” Jax, PyTorch and TensorFlow â€” with a seamless integration
between them. It's straightforward to train your models with one before loading them for inference with the other.
"""
question = "Which deep learning libraries back ğŸ¤— Transformers?"
question_answerer(question=question, context=context)
```

```python out
{'score': 0.9979003071784973,
 'start': 78,
 'end': 105,
 'answer': 'Jax, PyTorch and TensorFlow'}
```

ç´ æ™´ã‚‰ã—ã„ã§ã™ï¼ ç§ãŸã¡ã®ãƒ¢ãƒ‡ãƒ«ã¯ã€ã“ã®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚‚ã®ã¨åŒã˜ã‚ˆã†ã«å‹•ä½œã—ã¦ã„ã¾ã™ï¼