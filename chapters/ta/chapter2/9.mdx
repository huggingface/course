<FrameworkSwitchCourse {fw} />

<!-- DISABLE-FRONTMATTER-SECTIONS -->

# அத்தியாயத்தின் இறுதிக் வினாடி வினா[[end-of-chapter-quiz]]

<CourseFloatingBanner
    chapter={2}
    classNames="absolute z-10 right-0 top-0"
/>

### 1. மொழி மாடலிங் பைப்லைனின் வரிசை என்ன?

<Question
	choices={[
		{
			text: "முதலில், மாடல், இது உரையை கையாளுகிறது மற்றும் மூல கணிப்புகளை வழங்குகிறது. டோக்கனைசர் இந்த கணிப்புகளைப் புரிந்துகொண்டு தேவைப்படும்போது அவற்றை மீண்டும் உரையாக மாற்றுகிறது.",
			explain: "மாடலால் உரையைப் புரிந்துகொள்ள முடியாது! டோக்கனைசர் முதலில் உரையை டோக்கனைஸ் செய்து, அதை ஐடிகளாக மாற்ற வேண்டும், அப்போதுதான் அது மாடலால் புரிந்துகொள்ளக்கூடியதாக இருக்கும்."
		},
		{
			text: "முதலில், டோக்கனைசர், இது உரையை கையாளுகிறது மற்றும் ஐடிகளை வழங்குகிறது. மாடல் இந்த ஐடிகளைக் கையாண்டு ஒரு கணிப்பை வெளியிடுகிறது, இது சில உரையாக இருக்கலாம்.",
			explain: "மாடலின் கணிப்பு உடனடியாக உரையாக இருக்க முடியாது. கணிப்பை மீண்டும் உரையாக மாற்ற டோக்கனைசரைப் பயன்படுத்த வேண்டும்!"
		},
		{
			text: "டோக்கனைசர் உரையை கையாளுகிறது மற்றும் ஐடிகளை வழங்குகிறது. மாடல் இந்த ஐடிகளைக் கையாண்டு ஒரு கணிப்பை வெளியிடுகிறது. இந்த கணிப்புகளை மீண்டும் சில உரையாக மாற்ற டோக்கனைசரை மீண்டும் பயன்படுத்தலாம்.",
			explain: "டோக்கனைசரை டோக்கனைசிங் மற்றும் டி-டோக்கனைசிங் ஆகிய இரண்டிற்கும் பயன்படுத்தலாம்.",
            correct: true
		}
	]}
/>

### 2. அடிப்படை டிரான்ஸ்ஃபார்மர் மாடல் வெளியிடும் டென்சருக்கு எத்தனை பரிமாணங்கள் உள்ளன, அவை யாவை?

<Question
	choices={[
		{
			text: "2: வரிசை நீளம் மற்றும் பேட்ச் அளவு",
			explain: "தவறு! மாடல் வெளியிடும் டென்சருக்கு மூன்றாவது பரிமாணம் உள்ளது: மறைக்கப்பட்ட அளவு (hidden size)."
		},
		{
			text: "2: வரிசை நீளம் மற்றும் மறைக்கப்பட்ட அளவு",
			explain: "தவறு! அனைத்து டிரான்ஸ்ஃபார்மர் மாடல்களும் பேட்ச்களைக் கையாளுகின்றன, ஒரு வரிசையுடன் கூட; அது 1 என்ற பேட்ச் அளவாக இருக்கும்!"
		},
		{
			text: "3: வரிசை நீளம், பேட்ச் அளவு, மற்றும் மறைக்கப்பட்ட அளவு",
			explain: "அருமையாகச் செய்தீர்கள்!",
            correct: true
		}
	]}
/>

### 3. பின்வருவனவற்றில் எது துணை வார்த்தை டோக்கனைசேஷனுக்கு ஒரு எடுத்துக்காட்டு?

<Question
	choices={[
		{
			text: "WordPiece",
			explain: "ஆம், அது துணை வார்த்தை டோக்கனைசேஷனுக்கு ஒரு எடுத்துக்காட்டு!",
            correct: true
		},
		{
			text: "எழுத்து அடிப்படையிலான டோக்கனைசேஷன்",
			explain: "எழுத்து அடிப்படையிலான டோக்கனைசேஷன் ஒரு வகை துணை வார்த்தை டோக்கனைசேஷன் அல்ல."
		},
		{
			text: "வெற்றிடம் மற்றும் நிறுத்தற்குறிகளில் பிரித்தல்",
			explain: "அது ஒரு வார்த்தை அடிப்படையிலான டோக்கனைசேஷன் திட்டம்!"
		},
		{
			text: "BPE",
			explain: "ஆம், அது துணை வார்த்தை டோக்கனைசேஷனுக்கு ஒரு எடுத்துக்காட்டு!",
            correct: true
        },
		{
			text: "Unigram",
			explain: "ஆம், அது துணை வார்த்தை டோக்கனைசேஷனுக்கு ஒரு எடுத்துக்காட்டு!",
            correct: true
        },
		{
			text: "மேற்கூறிய எதுவும் இல்லை",
			explain: "தவறு!"
        }
	]}
/>

### 4. ஒரு மாடல் ஹெட் (model head) என்றால் என்ன?

<Question
	choices={[
		{
			text: "அடிப்படை டிரான்ஸ்ஃபார்மர் நெட்வொர்க்கின் ஒரு கூறு, இது டென்சர்களை அவற்றின் சரியான அடுக்குகளுக்குத் திருப்பி விடுகிறது",
			explain: "அப்படி ஒரு கூறு இல்லை."
		},
		{
			text: "சுய-கவன பொறிமுறை (self-attention mechanism) என்றும் அழைக்கப்படுகிறது, இது வரிசையின் மற்ற டோக்கன்களுக்கு ஏற்ப ஒரு டோக்கனின் பிரதிநிதித்துவத்தை மாற்றியமைக்கிறது",
			explain: "சுய-கவன அடுக்கில் கவன \"ஹெட்கள்\" உள்ளன, ஆனால் இவை தழுவல் ஹெட்கள் (adaptation heads) அல்ல."
		},
		{
			text: "ஒரு கூடுதல் கூறு, பொதுவாக ஒன்று அல்லது சில அடுக்குகளால் ஆனது, டிரான்ஸ்ஃபார்மர் கணிப்புகளை ஒரு பணி-குறிப்பிட்ட வெளியீடாக மாற்ற",
			explain: "அது சரி. தழுவல் ஹெட்கள், வெறுமனே ஹெட்கள் என்றும் அழைக்கப்படுகின்றன, மொழி மாடலிங் ஹெட்கள், கேள்வி பதில் ஹெட்கள், வரிசை வகைப்பாடு ஹெட்கள் என பல்வேறு வடிவங்களில் வருகின்றன...",
			correct: true
		} 
	]}
/>

### 5. ஒரு ஆட்டோமாடல் (AutoModel) என்றால் என்ன?

<Question
	choices={[
		{
			text: "உங்கள் தரவுகளில் தானாகவே பயிற்சி பெறும் ஒரு மாடல்",
			explain: "நீங்கள் இதை எங்கள் <a href='https://huggingface.co/autotrain'>ஆட்டோட்ரெய்ன்</a> தயாரிப்புடன் குழப்பிக் கொள்கிறீர்களா?"
		},
		{
			text: "செக்பாயிண்டின் அடிப்படையில் சரியான கட்டமைப்பை வழங்கும் ஒரு பொருள்",
			explain: "சரியாக: <code>AutoModel</code> சரியான கட்டமைப்பை வழங்க, எந்த செக்பாயிண்டிலிருந்து தொடங்க வேண்டும் என்பதை மட்டுமே அறிய வேண்டும்.",
			correct: true
		},
		{
			text: "சரியான வெயிட்ஸ்களை ஏற்றுவதற்கு அதன் உள்ளீடுகளுக்குப் பயன்படுத்தப்படும் மொழியைத் தானாகக் கண்டறியும் ஒரு மாடல்",
			explain: "இல்லை, ஒரு ஆட்டோமாடல் அதைச் செய்யாது."
		} 
	]}
/>

### 6. வெவ்வேறு நீளங்களைக் கொண்ட வரிசைகளை ஒன்றாக பேட்ச் செய்யும்போது கவனத்தில் கொள்ள வேண்டிய நுட்பங்கள் யாவை?

<Question
	choices={[
		{
			text: "வெட்டுதல் (Truncating)",
			explain: "ஆம், வரிசைகளை ஒரு செவ்வக வடிவத்தில் பொருந்துமாறு சமன் செய்வதற்கான சரியான வழி வெட்டுதல் ஆகும். ஆனால், இது ஒன்று மட்டும்தானா?",
			correct: true
		},
		{
			text: "டென்சர்களைத் திருப்புதல் (Returning tensors)",
			explain: "மற்ற நுட்பங்கள் செவ்வக டென்சர்களைத் திருப்ப உங்களை அனுமதித்தாலும், வரிசைகளை ஒன்றாக பேட்ச் செய்யும்போது டென்சர்களைத் திருப்புவது உதவாது."
		},
		{
			text: "பேடிங் (Padding)",
			explain: "ஆம், வரிசைகளை ஒரு செவ்வக வடிவத்தில் பொருந்துமாறு சமன் செய்வதற்கான சரியான வழி பேடிங் ஆகும். ஆனால், இது ஒன்று மட்டும்தானா?",
			correct: true
		}, 
		{
			text: "கவன மறைப்பு (Attention masking)",
			explain: "நிச்சயமாக! வெவ்வேறு நீளங்களைக் கொண்ட வரிசைகளைக் கையாளும்போது கவன மறைப்புகள் முதன்மையான முக்கியத்துவம் வாய்ந்தவை. இருப்பினும், கவனத்தில் கொள்ள வேண்டிய ஒரே நுட்பம் இதுவல்ல.",
			correct: true
		} 
	]}
/>

### 7. ஒரு வரிசை வகைப்பாடு மாடல் வெளியிடும் லாஜிட்களில் சாஃப்ட்மேக்ஸ் செயல்பாட்டைப் பயன்படுத்துவதன் நோக்கம் என்ன?

<Question
	choices={[
		{
			text: "இது லாஜிட்களை மென்மையாக்குகிறது, அதனால் அவை மிகவும் நம்பகமானவை.",
			explain: "இல்லை, சாஃப்ட்மேக்ஸ் செயல்பாடு முடிவுகளின் நம்பகத்தன்மையை பாதிக்காது."
		},
		{
			text: "இது ஒரு கீழ் மற்றும் மேல் எல்லையைப் பயன்படுத்துகிறது, அதனால் அவை புரிந்துகொள்ளக்கூடியவை.",
			explain: "இதன் விளைவாக வரும் மதிப்புகள் 0 மற்றும் 1 க்கு இடையில் கட்டுப்படுத்தப்பட்டுள்ளன. ஆனால், நாம் ஒரு சாஃப்ட்மேக்ஸ் செயல்பாட்டைப் பயன்படுத்துவதற்கான ஒரே காரணம் இதுவல்ல.",
            correct: true
		},
		{
			text: "வெளியீட்டின் மொத்த கூட்டுத்தொகை 1 ஆகிறது, இது ஒரு சாத்தியமான நிகழ்தகவு விளக்கத்திற்கு வழிவகுக்கிறது.",
			explain: "சரி! ஆனால், நாம் ஒரு சாஃப்ட்மேக்ஸ் செயல்பாட்டைப் பயன்படுத்துவதற்கான ஒரே காரணம் இதுவல்ல.",
            correct: true
		}
	]}
/>

### 8. டோக்கனைசர் ஏபிஐயின் பெரும்பாலான பகுதி எந்த முறையை மையமாகக் கொண்டுள்ளது?

<Question
	choices={[
		{
			text: "<code>encode</code>, ஏனெனில் அது உரையை ஐடிகளாகவும், ஐடிகளை கணிப்புகளாகவும் குறியாக்கம் செய்ய முடியும்",
			explain: "தவறு! <code>encode</code> முறை டோக்கனைசர்களில் இருந்தாலும், அது மாடல்களில் இல்லை."
		},
		{
			text: "டோக்கனைசர் பொருளை நேரடியாக அழைப்பது.",
			explain: "சரியாக! டோக்கனைசரின் <code>__call__</code> முறை மிகவும் சக்திவாய்ந்த முறையாகும், இது கிட்டத்தட்ட எதையும் கையாள முடியும். இது ஒரு மாடலிலிருந்து கணிப்புகளைப் பெறுவதற்கும் பயன்படுத்தப்படும் முறையாகும்.",
			correct: true
		},
		{
			text: "<code>pad</code>",
			explain: "தவறு! பேடிங் மிகவும் பயனுள்ளது, ஆனால் இது டோக்கனைசர் ஏபிஐயின் ஒரு பகுதி மட்டுமே."
		},
		{
			text: "<code>tokenize</code>",
			explain: "<code>tokenize</code> முறை மிகவும் பயனுள்ள முறைகளில் ஒன்றாகும், ஆனால் இது டோக்கனைசர் ஏபிஐயின் மையப்பகுதி அல்ல."
		}
	]}
/>

### 9. இந்த குறியீடு மாதிரியில் `result` மாறி என்னத்தைக் கொண்டுள்ளது?

```py
from transformers import AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained("bert-base-cased")
result = tokenizer.tokenize("Hello!")
```

<Question
	choices={[
		{
			text: "ஒரு சரங்களின் பட்டியல், ஒவ்வொரு சரமும் ஒரு டோக்கன்",
			explain: "நிச்சயமாக! இதை ஐடிகளாக மாற்றி, ஒரு மாடலுக்கு அனுப்புங்கள்!",
            correct: true
		},
		{
			text: "ஐடிகளின் பட்டியல்",
			explain: "தவறு; அதற்காகத்தான் <code>__call__</code> அல்லது <code>convert_tokens_to_ids</code> முறை உள்ளது!"
		},
		{
			text: "அனைத்து டோக்கன்களையும் கொண்ட ஒரு சரம்",
			explain: "இது உகந்ததல்ல, ஏனெனில் சரத்தை பல டோக்கன்களாகப் பிரிப்பதே குறிக்கோள்."
		}
	]}
/>

### 10. பின்வரும் குறியீட்டில் ஏதேனும் தவறு உள்ளதா?

```py
from transformers import AutoTokenizer, AutoModel

tokenizer = AutoTokenizer.from_pretrained("bert-base-cased")
model = AutoModel.from_pretrained("gpt2")

encoded = tokenizer("Hey!", return_tensors="pt")
result = model(**encoded)
```

<Question
	choices={[
		{
			text: "இல்லை, இது சரியாகத் தெரிகிறது.",
			explain: "துரதிர்ஷ்டவசமாக, ஒரு மாடலை வேறு செக்பாயிண்டில் பயிற்சி பெற்ற ஒரு டோக்கனைசருடன் இணைப்பது அரிதாகவே ஒரு நல்ல யோசனையாகும். இந்த டோக்கனைசரின் வெளியீட்டைப் புரிந்துகொள்ள மாடல் பயிற்சி பெறவில்லை, எனவே மாடல் வெளியீடு (அது இயங்க முடிந்தாலும்!) எந்த அர்த்தத்தையும் தராது."
		},
		{
			text: "டோக்கனைசர் மற்றும் மாடல் எப்போதும் ஒரே செக்பாயிண்டிலிருந்து இருக்க வேண்டும்.",
			explain: "சரி!",
            correct: true
		},
		{
			text: "ஒவ்வொரு உள்ளீடும் ஒரு பேட்ச் என்பதால், டோக்கனைசருடன் பேடிங் மற்றும் வெட்டுதல் செய்வது நல்ல நடைமுறை.",
			explain: "ஒவ்வொரு மாடல் உள்ளீடும் ஒரு பேட்சாக இருக்க வேண்டும் என்பது உண்மைதான். இருப்பினும், இந்த வரிசையை வெட்டுவது அல்லது பேடிங் செய்வது அவசியமாக அர்த்தமுள்ளதாக இருக்காது, ஏனெனில் அதில் ஒன்று மட்டுமே உள்ளது, மேலும் அவை வாக்கியங்களின் பட்டியலை ஒன்றாக பேட்ச் செய்வதற்கான நுட்பங்கள்."
		}
	]}
/>
