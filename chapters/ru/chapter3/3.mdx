<FrameworkSwitchCourse {fw} />

# Fine-tuning –º–æ–¥–µ–ª–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Trainer API

<DocNotebookDropdown
  classNames="absolute z-10 right-0 top-0"
  options={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter3/section3.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter3/section3.ipynb"},
]} />

<Youtube id="nvBXf7s7vTI"/>

–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ ü§ó Transformers –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –∫–ª–∞—Å—Å `Trainer`, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–æ–≥–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ fine-tuning –ª—é–±–æ–π –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –Ω–∞ –≤–∞—à–µ–º –¥–∞—Ç–∞—Å–µ—Ç–µ. –ü–æ—Å–ª–µ –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö, —Å–¥–µ–ª–∞–Ω–Ω—ã—Ö –≤ –ø—Ä–æ—à–ª–æ–º —Ä–∞–∑–¥–µ–ª–µ, –≤–∞–º –æ—Å—Ç–∞–Ω–µ—Ç—Å—è —Å–¥–µ–ª–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —à–∞–≥–æ–≤ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è `Trainer`. –°–∞–º–∞—è —Å–ª–æ–∂–Ω–∞—è —á–∞—Å—Ç—å ‚Äì –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –æ–∫—Ä—É–∂–µ–Ω–∏–µ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ `Trainer.train()`, —Ç.–∫. –æ–Ω–∞ –º–µ–¥–ª–µ–Ω–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–µ. –ï—Å–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –≤–∏–¥–µ–æ–∫–∞—Ä—Ç—ã, –≤—ã –º–æ–∂–µ—Ç–µ –±–µ—Å–ø–ª–∞—Ç–Ω–æ –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å–µ—Ä–≤–∏—Å–æ–º [Google Colab](https://colab.research.google.com/), –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –¥–æ—Å—Ç—É–ø –∫ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è–º —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º GPU –∏ TPU.

–§—Ä–∞–≥–º–µ–Ω—Ç—ã –∫–æ–¥–∞ –Ω–∏–∂–µ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—é—Ç, —á—Ç–æ –≤—ã –≤—ã–ø–æ–ª–Ω–∏–ª–∏ –∫–æ–¥ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Ä–∞–∑–¥–µ–ª–∞. –ù–∏–∂–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–æ –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ —Ç–æ–≥–æ, —á—Ç–æ –≤–∞–º –Ω—É–∂–Ω–æ: 

```py
from datasets import load_dataset
from transformers import AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset("glue", "mrpc")
checkpoint = "bert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


def tokenize_function(example):
    return tokenizer(example["sentence1"], example["sentence2"], truncation=True)


tokenized_datasets = raw_datasets.map(tokenize_function, batched=True)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)
```

### –û–±—É—á–µ–Ω–∏–µ

–ü–µ—Ä–≤—ã–π —à–∞–≥ –ø–µ—Ä–µ–¥ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º `Trainer`, –∑–∞–¥–∞–Ω–∏–µ –∫–ª–∞—Å—Å–∞ `TrainingArguments`, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –≤—Å–µ –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è `Trainer` (–¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –æ–±—É—á–µ–Ω–∏—è –∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏). –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –≤—ã –¥–æ–ª–∂–Ω—ã –∑–∞–¥–∞—Ç—å ‚Äî —ç—Ç–æ –∫–∞—Ç–∞–ª–æ–≥, –≤ –∫–æ—Ç–æ—Ä–æ–º –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –æ–±—É—á–µ–Ω–Ω–∞—è –º–æ–¥–µ–ª—å, –∞ —Ç–∞–∫–∂–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏. –î–ª—è –≤—Å–µ–≥–æ –æ—Å—Ç–∞–ª—å–Ω–æ–≥–æ –≤—ã –º–æ–∂–µ—Ç–µ –æ—Å—Ç–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –ø–æ–¥–æ–π—Ç–∏ –¥–ª—è –±–∞–∑–æ–≤–æ–≥–æ fine-tuning.


```py
from transformers import TrainingArguments

training_args = TrainingArguments("test-trainer")
```

<Tip>

üí° –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–≥—Ä—É–∂–∞—Ç—å –º–æ–¥–µ–ª—å –Ω–∞ Hub –≤–æ –≤—Ä–µ–º—è –æ–±—É—á–µ–Ω–∏—è, –ø–µ—Ä–µ–¥–∞–π—Ç–µ –∞—Ä–≥—É–º–µ–Ω—Ç `push_to_hub=True` –≤ `TrainingArguments`. –ú—ã –±–æ–ª—å—à–µ —É–∑–Ω–∞–µ–º –æ–± —ç—Ç–æ–º –≤ –≥–ª–∞–≤–µ [Chapter 4](/course/chapter4/3). 

</Tip>

–í—Ç–æ—Ä–æ–π —à–∞–≥ ‚Äì –∑–∞–¥–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏. –¢–∞–∫ –∂–µ, –∫–∞–∫ –∏ –≤ [–ø—Ä–µ–¥—ã–¥—É—â–µ–π –≥–ª–∞–≤–µ](/course/chapter2), –º—ã –±—É–¥–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–ª–∞—Å—Å `AutoModelForSequenceClassification` —Å –¥–≤—É–º—è –ª–µ–π–±–ª–∞–º–∏: 

```py
from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)
```

–ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –±—É–¥–µ—Ç —Ä–∞—Å–ø–µ—á–∞—Ç–∞–Ω–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ (–≤ [–≥–ª–∞–≤–µ 2](/course/chapter2) –º—ã —Å —Ç–∞–∫–∏–º –Ω–µ —Å—Ç–∞–ª–∫–∏–≤–∞–ª–∏—Å—å). –≠—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ—Ç–æ–º—É, —á—Ç–æ BERT –Ω–µ –±—ã–ª –ø—Ä–µ–¥–æ–±—É—á–µ–Ω –¥–ª—è –∑–∞–¥–∞—á–∏ –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø–∞—Ä –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π, –µ–≥–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–ª–æ–π –Ω–µ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω, –≤–º–µ—Å—Ç–æ –Ω–µ–≥–æ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω —Å–ª–æ–π, –ø–æ–∑–≤–æ–ª—è—é—â–∏–π —Ä–∞–±–æ—Ç–∞—Ç—å —Å —Ç–∞–∫–æ–π –∑–∞–¥–∞—á–µ–π. –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è —Å–æ–æ–±—â–∞—é—Ç, —á—Ç–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–µ—Å–∞ –Ω–µ –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã (–∫–∞–∫ —Ä–∞–∑ —Ç–µ—Ö —Å–ª–æ–µ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è) –∏ –¥–ª—è –Ω–æ–≤—ã—Ö –±—É–¥—É—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —Å–ª—É—á–∞–π–Ω—ã–µ –≤–µ—Å–∞. –í –∑–∞–∫–ª—é—á–µ–Ω–∏–∏ –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç—Å—è –æ–±—É—á–∏—Ç—å –º–æ–¥–µ–ª—å, —á—Ç–æ –º—ã –∏ —Å–¥–µ–ª–∞–µ–º –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å. 

–ü–æ—Å–ª–µ —Ç–æ–≥–æ, –∫–∞–∫ –º—ã –∑–∞–≥—Ä—É–∑–∏–ª–∏ –º–æ–¥–µ–ª—å, –º—ã –º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å `Trainer` –∏ –ø–µ—Ä–µ–¥–∞—Ç—å —Ç—É–¥–∞ –Ω—É–∂–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã: `model`, `training_args`, –æ–±—É—á–∞—é—â—É—é –∏ –≤–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω—É—é –≤—ã–±–æ—Ä–∫–∏, `data_collator` –∏ `tokenizer`

```py
from transformers import Trainer

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
)
```

–ó–∞–º–µ—Ç—å—Ç–µ, –∫–æ–≥–¥–∞ –≤—ã –ø–µ—Ä–µ–¥–∞–ª–∏ `tokenizer` –∫–∞–∫ –≤ –ø—Ä–∏–º–µ—Ä–µ –≤—ã—à–µ, –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è `data_collator` –≤ `Trainer` –±—É–¥–µ—Ç `DataCollatorWithPadding` —Ç–∞–∫–∏–º, –∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –≤—ã—à–µ, —Ç–∞–∫ —á—Ç–æ —ç—Ç—É —Å—Ç—Ä–æ–∫—É (`data_collator=data_collator`) –º–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤ —ç—Ç–æ–º –≤—ã–∑–æ–≤–µ.  

<!-- Note that when you pass the `tokenizer` as we did here, the default `data_collator` used by the `Trainer` will be a `DataCollatorWithPadding` as defined previously, so you can skip the line `data_collator=data_collator` in this call. It was still important to show you this part of the processing in section 2! -->

–î–ª—è fine-tuning –º–æ–¥–µ–ª–∏ –Ω–∞ –Ω–∞—à–µ–º –¥–∞—Ç–∞—Å–µ—Ç–µ –º—ã –ø—Ä–æ—Å—Ç–æ –¥–æ–ª–∂–Ω—ã –≤—ã–∑–≤–∞—Ç—å –º–µ—Ç–æ–¥ `train()` —É `Trainer`: 

```py
trainer.train()
```

–≠—Ç–æ –∑–∞–ø—É—Å—Ç–∏—Ç –ø—Ä–æ—Ü–µ—Å—Å –¥–æ–æ–±—É—á–µ–Ω–∏—è (–∫–æ—Ç–æ—Ä—ã–π –¥–æ–ª–∂–µ–Ω –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç –Ω–∞ GPU) –∏ –±—É–¥–µ—Ç —Ä–∞—Å–ø–µ—á–∞—Ç—ã–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ª–æ—Å—Å–∞ –∫–∞–∂–¥—ã–µ 500 –∏—Ç–µ—Ä–∞—Ü–∏–π. –û–¥–Ω–∞–∫–æ —ç—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ —Å–∫–∞–∂—É—Ç –Ω–∞–º, –Ω–∞—Å–∫–æ–ª—å–∫–æ —Ö–æ—Ä–æ—à–æ –∏–ª–∏ –ø–ª–æ—Ö–æ –º–æ–¥–µ–ª—å —Ä–∞–±–æ—Ç–∞–µ—Ç. –ò –≤–æ—Ç –ø–æ—á–µ–º—É: 

1. –ú—ã –Ω–µ —Å–æ–æ–±—â–∏–ª–∏ `Trainer`, —á—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø—Ä–æ–≤–æ–¥–∏—Ç—å –≤–∞–ª–∏–¥–∞—Ü–∏—é: –¥–ª—è —ç—Ç–æ–≥–æ –Ω—É–∂–Ω–æ –ø—Ä–∏—Å–≤–æ–∏—Ç—å –∞—Ä–≥—É–º–µ–Ω—Ç—É `evaluation_strategy` –∑–Ω–∞—á–µ–Ω–∏–µ `"steps"` (–≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–µ `eval_steps`) –∏–ª–∏ `"epoch"` (–≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞—Ç—å –ø–æ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ –∫–∞–∂–¥–æ–π —ç–ø–æ—Ö–∏). 
2. –ú—ã –Ω–µ —É–∫–∞–∑–∞–ª–∏ `Trainer` –∞—Ä–≥—É–º–µ–Ω—Ç `compute_metrics()` ‚Äì —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –º–µ—Ç—Ä–∏–∫–∏ –Ω–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω–æ–π —á–∞—Å—Ç–∏ (–≤ —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –±—É–¥–µ—Ç —Ç–æ–ª—å–∫–æ —Ä–∞—Å–ø–µ—á–∞—Ç—ã–≤–∞—Ç—å—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –ª–æ—Å—Å–∞, —á—Ç–æ –Ω–µ –æ—á–µ–Ω—å –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ). 


### Evaluation

Let's see how we can build a useful `compute_metrics()` function and use it the next time we train. The function must take an `EvalPrediction` object (which is a named tuple with a `predictions` field and a `label_ids` field) and will return a dictionary mapping strings to floats (the strings being the names of the metrics returned, and the floats their values). To get some predictions from our model, we can use the `Trainer.predict()` command:

```py
predictions = trainer.predict(tokenized_datasets["validation"])
print(predictions.predictions.shape, predictions.label_ids.shape)
```

```python out
(408, 2) (408,)
```

The output of the `predict()` method is another named tuple with three fields: `predictions`, `label_ids`, and `metrics`. The `metrics` field will just contain the loss on the dataset passed, as well as some time metrics (how long it took to predict, in total and on average). Once we complete our `compute_metrics()` function and pass it to the `Trainer`, that field will also contain the metrics returned by `compute_metrics()`.

As you can see, `predictions` is a two-dimensional array with shape 408 x 2 (408 being the number of elements in the dataset we used). Those are the logits for each element of the dataset we passed to `predict()` (as you saw in the [previous chapter](/course/chapter2), all Transformer models return logits). To transform them into predictions that we can compare to our labels, we need to take the index with the maximum value on the second axis:

```py
import numpy as np

preds = np.argmax(predictions.predictions, axis=-1)
```

We can now compare those `preds` to the labels. To build our `compute_metric()` function, we will rely on the metrics from the ü§ó Datasets library. We can load the metrics associated with the MRPC dataset as easily as we loaded the dataset, this time with the `load_metric()` function. The object returned has a `compute()` method we can use to do the metric calculation:

```py
from datasets import load_metric

metric = load_metric("glue", "mrpc")
metric.compute(predictions=preds, references=predictions.label_ids)
```

```python out
{'accuracy': 0.8578431372549019, 'f1': 0.8996539792387542}
```

The exact results you get may vary, as the random initialization of the model head might change the metrics it achieved. Here, we can see our model has an accuracy of 85.78% on the validation set and an F1 score of 89.97. Those are the two metrics used to evaluate results on the MRPC dataset for the GLUE benchmark. The table in the [BERT paper](https://arxiv.org/pdf/1810.04805.pdf) reported an F1 score of 88.9 for the base model. That was the `uncased` model while we are currently using the `cased` model, which explains the better result.

Wrapping everything together, we get our `compute_metrics()` function:

```py
def compute_metrics(eval_preds):
    metric = load_metric("glue", "mrpc")
    logits, labels = eval_preds
    predictions = np.argmax(logits, axis=-1)
    return metric.compute(predictions=predictions, references=labels)
```

And to see it used in action to report metrics at the end of each epoch, here is how we define a new `Trainer` with this `compute_metrics()` function:

```py
training_args = TrainingArguments("test-trainer", evaluation_strategy="epoch")
model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
)
```

Note that we create a new `TrainingArguments` with its `evaluation_strategy` set to `"epoch"` and a new model ‚Äî otherwise, we would just be continuing the training of the model we have already trained. To launch a new training run, we execute:

```
trainer.train()
```

This time, it will report the validation loss and metrics at the end of each epoch on top of the training loss. Again, the exact accuracy/F1 score you reach might be a bit different from what we found, because of the random head initialization of the model, but it should be in the same ballpark.

The `Trainer` will work out of the box on multiple GPUs or TPUs and provides lots of options, like mixed-precision training (use `fp16 = True` in your training arguments). We will go over everything it supports in Chapter 10.

This concludes the introduction to fine-tuning using the `Trainer` API. An example of doing this for most common NLP tasks will be given in Chapter 7, but for now let's look at how to do the same thing in pure PyTorch.

<Tip>

‚úèÔ∏è **Try it out!** Fine-tune a model on the GLUE SST-2 dataset, using the data processing you did in section 2.

</Tip>

