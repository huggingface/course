<FrameworkSwitchCourse {fw} />

# í•™ìŠµ íŒŒì´í”„ë¼ì¸ ë””ë²„ê¹…

<CourseFloatingBanner chapter={8}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter8/section4_tf.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter8/section4_tf.ipynb"},
]} />

[ë‹¨ì› 7](/course/chapter7)ì˜ ì¡°ì–¸ì— ì¶©ì‹¤íˆ ë”°ë¼ ì£¼ì–´ì§„ ì‘ì—…ì—ì„œ ëª¨ë¸ì„ í›ˆë ¨í•˜ê±°ë‚˜ íŒŒì¸íŠœë‹í•˜ëŠ” ë©‹ì§„ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‘ì„±í–ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ `model.fit()` ëª…ë ¹ì„ ì‹¤í–‰í•˜ë©´ ë”ì°í•œ ì¼ì´ ë°œìƒí•©ë‹ˆë‹¤. ì˜¤ë¥˜ê°€ ë°œìƒí–ˆë„¤ìš” ğŸ˜±! ë˜ëŠ” ë” ì¢‹ì§€ ëª»í•œ ì¼ì€ ëª¨ë“  ê²ƒì´ ì •ìƒì¸ ê²ƒì²˜ëŸ¼ ë³´ì´ê³  í›ˆë ¨ì€ ì˜¤ë¥˜ ì—†ì´ ì‹¤í–‰ë˜ì—ˆì§€ë§Œ ê²°ê³¼ ëª¨ë¸ì´ ì—‰ë§ì¸ ê²½ìš°ì…ë‹ˆë‹¤. ì´ ì¥ì—ì„œëŠ” ì´ëŸ¬í•œ ì¢…ë¥˜ì˜ ì´ìŠˆë¥¼ ë””ë²„ê·¸í•˜ê¸° ìœ„í•´ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” ì‘ì—…ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.

## í•™ìŠµ íŒŒì´í”„ë¼ì¸ ë””ë²„ê¹…

<Youtube id="N9kO52itd0Q"/>

`model.fit()`ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì„ ë•Œ ë¬¸ì œëŠ” ì—¬ëŸ¬ ê³³ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•™ìŠµì€ ì¼ë°˜ì ìœ¼ë¡œ ì‹œì‘ë¶€í„° í•´ë‹¹ ì—ëŸ¬ ì§€ì ê¹Œì§€ ë§ì€ ì‘ì—…ì´ ì§„í–‰ë˜ê¸° ë•Œë¬¸ì¸ë°, ë¬¸ì œëŠ” ë°ì´í„°ì„¸íŠ¸ê°€ ë­”ê°€ ì˜ëª» ë˜ì—ˆê±°ë‚˜, ë°ì´í„°ì„¸íŠ¸ì˜ ë°°ì¹˜ ë°ì´í„°ë¥¼ í•¨ê»˜ ì¼ê´„ ì²˜ë¦¬í•˜ë ¤ê³  í•  ë•Œ ë°œìƒí•˜ëŠ” ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë˜ëŠ” ëª¨ë¸ ì½”ë“œ, ì†ì‹¤ í•¨ìˆ˜ ë˜ëŠ” ì˜µí‹°ë§ˆì´ì €ì— ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëª¨ë“  ê²ƒì´ í›ˆë ¨ì— ì í•©í•˜ë”ë¼ë„ ë©”íŠ¸ë¦­ì— ë¬¸ì œê°€ ìˆëŠ” ê²½ìš° í‰ê°€ ì¤‘ì— ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`model.fit()`ì—ì„œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ë¥¼ ë””ë²„ê·¸í•˜ëŠ” ê°€ì¥ ì¢‹ì€ ë°©ë²•ì€ ì´ ì „ì²´ íŒŒì´í”„ë¼ì¸ì„ ì§ì ‘ ì‚´í´ë³´ê³  ë¬¸ì œê°€ ë°œìƒí•œ ë¶€ë¶„ì„ í™•ì¸í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ê°€ë” ì—ëŸ¬ëŠ” í•´ê²°í•˜ê¸° ì‰¬ìš¸ ë•Œë„ ìˆìŠµë‹ˆë‹¤.

ì˜ˆì‹œë¥¼ ìœ„í•´ì„œ [MNLI ë°ì´í„°ì„¸íŠ¸](https://huggingface.co/datasets/glue)ì—ì„œ DistilBERT ëª¨ë¸ì„ íŒŒì¸íŠœë‹(ì„ ì‹œë„í•˜ëŠ”) ì•„ë˜ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.:

```py
from datasets import load_dataset
import evaluate
from transformers import (
    AutoTokenizer,
    TFAutoModelForSequenceClassification,
)

raw_datasets = load_dataset("glue", "mnli")

model_checkpoint = "distilbert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)


def preprocess_function(examples):
    return tokenizer(examples["premise"], examples["hypothesis"], truncation=True)


tokenized_datasets = raw_datasets.map(preprocess_function, batched=True)

train_dataset = tokenized_datasets["train"].to_tf_dataset(
    columns=["input_ids", "labels"], batch_size=16, shuffle=True
)

validation_dataset = tokenized_datasets["validation_matched"].to_tf_dataset(
    columns=["input_ids", "labels"], batch_size=16, shuffle=True
)

model = TFAutoModelForSequenceClassification.from_pretrained(model_checkpoint)

model.compile(loss="sparse_categorical_crossentropy", optimizer="adam")

model.fit(train_dataset)
```

ì´ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë ¤ê³  í•˜ë©´ ë°ì´í„° ì„¸íŠ¸ë¥¼ ë³€í™˜í•  ë•Œ 'VisibleDeprecationWarning'ì´ í‘œì‹œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ì•Œë ¤ì§„ UX ë¬¸ì œì´ë¯€ë¡œ ë¬´ì‹œí•˜ì‹œë©´ ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, 2021ë…„ 11ì›” ì´í›„ì— ì´ ì½”ìŠ¤ë¥¼ ì½ê³  ìˆëŠ”ë° ì—¬ì „íˆ ì§„í–‰ ì¤‘ì´ë¼ë©´ ìˆ˜ì • í•  ë•Œê¹Œì§€ @carrigmatë¡œ ë¶„ë…¸ì˜ íŠ¸ìœ—ì„ ë³´ë‚´ì£¼ì„¸ìš”.

ìœ„ ë¬¸ì œë³´ë‹¨ ëˆ„ê°€ë´ë„ ëª…ë°±í•œ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤ëŠ” ê²ƒì¸ë°, ì •ë§ ë”ì°í•˜ê²Œ ê¹ë‹ˆë‹¤:

```python out
ValueError: No gradients provided for any variable: ['tf_distil_bert_for_sequence_classification/distilbert/embeddings/word_embeddings/weight:0', '...']
```

ì´ê²Œ ë¬´ìŠ¨ ëœ»ì¼ê¹Œìš”? ë°ì´í„°ë¡œ í•™ìŠµí•˜ë ¤ê³  í•˜ëŠ”ë° ê·¸ë¼ë””ì–¸íŠ¸ê°€ ì—†ë‹¤ë‹ˆ? ê½¤ë‚˜ ë‹¹í™©ìŠ¤ëŸ¬ìš´ ì¼ì…ë‹ˆë‹¤; ì´ëŸ´ ê²½ìš° ì–´ë–»ê²Œ ë””ë²„ê¹…ì„ í•  ìˆ˜ ìˆì„ê¹Œìš”? ì—ëŸ¬ê°€ ë°œìƒí–ˆì„ ë•Œ ë¬¸ì œê°€ ì–´ë””ì— ìˆëŠ”ì§€ ë°”ë¡œ ì•Œ ìˆ˜ ì—†ëŠ” ê²½ìš° ê°€ì¥ ì¢‹ì€ í•´ê²°ì±…ì€ ê° ë‹¨ê³„ì—ì„œ ëª¨ë“  ê²ƒì´ ì˜¬ë°”ë¥´ê²Œ ë³´ì´ëŠ”ì§€ í™•ì¸í•˜ë©´ì„œ ìˆœì„œëŒ€ë¡œ ì‚´í´ë³´ëŠ” ê²ƒì´ íš¨ê³¼ì ì¸ ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤. ë¬¼ë¡  ì‹œì‘í•˜ëŠ” ê³³ì€ í•­ìƒ...

### ë°ì´í„° í™•ì¸

êµ³ì´ ì–¸ê¸‰í•˜ìë©´, ë°ì´í„°ê°€ ì†ìƒëœ ê²½ìš° KerasëŠ” ìŠ¤ìŠ¤ë¡œ ìˆ˜ì •í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ê°€ì¥ ë¨¼ì € í•´ì•¼ í•  ì¼ì€ í•™ìŠµ ì„¸íŠ¸ ë‚´ë¶€ê°€ ì–´ë–¤ì§€ ì‚´í”¼ëŠ” ê²ƒì…ë‹ˆë‹¤.

`raw_datasets` ë° `tokenized_datasets` ë‚´ë¶€ë¥¼ ì‚´í´ë³´ë©´ ì¢‹ê² ì§€ë§Œ ì™ ë§Œí•˜ë©´ ëª¨ë¸ì— ë“¤ì–´ê°€ê¸° ì „ ì§€ì ì˜ ë°ì´í„°ë¥¼ í™•ì¸í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. ì¦‰, `to_tf_dataset()` í•¨ìˆ˜ë¡œ ìƒì„±í•œ `tf.data.Dataset`ì—ì„œ ì¶œë ¥ì„ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤! ê·¸ëŸ¼ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œìš”? `tf.data.Dataset` ê°ì²´ëŠ” í•œ ë²ˆì— ì „ì²´ ë°°ì¹˜ë¥¼ ì œê³µí•˜ê³  ì¸ë±ì‹±ì„ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ `train_dataset[0]`ì˜ ë°©ì‹ìœ¼ë¡œ ìš”ì²­í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê·¸ë ‡ì§€ë§Œ ìš°ë¦¬ëŠ” ì‚´ë©°ì‹œ ë°°ì¹˜ë¥¼ ìš”ì²­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.:

```py
for batch in train_dataset:
    break
```

`break`ëŠ” í•œ ë²ˆì˜ ë°˜ë³µ í›„ì— ë£¨í”„ë¥¼ ì¢…ë£Œí•˜ë¯€ë¡œ `train_dataset`ì—ì„œ ë‚˜ì˜¤ëŠ” ì²« ë²ˆì§¸ ë°°ì¹˜ë¥¼ ê°€ì ¸ì™€ `batch`ë¡œ ì €ì¥í•©ë‹ˆë‹¤. ì´ì œ ë‚´ë¶€ë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.:

```python out
{'attention_mask': <tf.Tensor: shape=(16, 76), dtype=int64, numpy=
 array([[1, 1, 1, ..., 0, 0, 0],
        [1, 1, 1, ..., 0, 0, 0],
        [1, 1, 1, ..., 0, 0, 0],
        ...,
        [1, 1, 1, ..., 1, 1, 1],
        [1, 1, 1, ..., 0, 0, 0],
        [1, 1, 1, ..., 0, 0, 0]])>,
 'label': <tf.Tensor: shape=(16,), dtype=int64, numpy=array([0, 2, 1, 2, 1, 1, 2, 0, 0, 0, 1, 0, 1, 2, 2, 1])>,
 'input_ids': <tf.Tensor: shape=(16, 76), dtype=int64, numpy=
 array([[ 101, 2174, 1010, ...,    0,    0,    0],
        [ 101, 3174, 2420, ...,    0,    0,    0],
        [ 101, 2044, 2048, ...,    0,    0,    0],
        ...,
        [ 101, 3398, 3398, ..., 2051, 2894,  102],
        [ 101, 1996, 4124, ...,    0,    0,    0],
        [ 101, 1999, 2070, ...,    0,    0,    0]])>}
```

ë§ëŠ” ê²ƒ ê°™ì§€ ì•Šë‚˜ìš”? ëª¨ë¸ì— 'labels', 'attention_mask', 'input_ids'ë¥¼ ì „ë‹¬í•˜ê³  ìˆëŠ”ë°, ì´ëŠ” ì¶œë ¥ê°’ê³¼ ì†ì‹¤ê°’ì„ ê³„ì‚°í•˜ëŠ” ë° í•„ìš”í•œ ëª¨ë“  ê²ƒì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ¼ ì™œ ê·¸ë˜ë””ì–¸íŠ¸ê°€ ì—†ëŠ” ê±¸ê¹Œìš”? ìì„¸íˆ ë³´ë©´ ë‹¨ì¼ Dictionary êµ¬ì¡°ë¡œ ì…ë ¥ê°’ì„ ì „ë‹¬í•˜ì§€ë§Œ í•™ìŠµ ë°°ì¹˜ëŠ” ì¼ë°˜ì ìœ¼ë¡œ í…ì„œ ë˜ëŠ” Dictionary, ê·¸ë¦¬ê³  ë ˆì´ë¸” í…ì„œì…ë‹ˆë‹¤. Dictionary ì…ë ¥ì—ì„œ ë ˆì´ë¸”ì€ í‚¤ë¡œ ë˜ì–´ìˆìŠµë‹ˆë‹¤.

ì´ê²ƒì´ ë¬¸ì œì¼ê¹Œìš”? í•­ìƒ ê·¸ëŸ° ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤! ê·¸ë ‡ì§€ë§Œ TensorFlowë¡œ Transformer ëª¨ë¸ì„ í›ˆë ¨í•  ë•Œ ì ‘í•˜ê²Œ ë˜ëŠ” ê°€ì¥ ì¼ë°˜ì ì¸ ë¬¸ì œ ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ìš°ë¦¬ ëª¨ë¸ì€ ëª¨ë‘ ë‚´ë¶€ì ìœ¼ë¡œ ì†ì‹¤ê°’ì„ ê³„ì‚°í•  ìˆ˜ ìˆì§€ë§Œ ê·¸ë ‡ê²Œ í•˜ë ¤ë©´ ë ˆì´ë¸”ì´ ì…ë ¥ Dictionaryì— ì „ë‹¬ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ì´ê²ƒì€ `compile()`ì— ì†ì‹¤ íŒŒë¼ë¯¸í„° ê°’ì„ ì§€ì •í•˜ì§€ ì•Šì„ ë•Œ ì‚¬ìš©ë˜ëŠ” ì†ì‹¤ê°’ ì…ë‹ˆë‹¤. ë°˜ë©´ì— KerasëŠ” ì¼ë°˜ì ìœ¼ë¡œ ë ˆì´ë¸”ì´ ì…ë ¥ Dictionaryì™€ ë³„ë„ë¡œ ì „ë‹¬ë  ê²ƒìœ¼ë¡œ ì˜ˆìƒí•˜ë©° ê·¸ë ‡ê²Œ í•˜ì§€ ì•Šìœ¼ë©´ ì¼ë°˜ì ìœ¼ë¡œ ì†ì‹¤ê°’ ê³„ì‚°ì´ ì‹¤íŒ¨í•©ë‹ˆë‹¤.

ë¬¸ì œëŠ” ì´ì œ ëª…í™•í•´ì¡ŒìŠµë‹ˆë‹¤. ìš°ë¦¬ëŠ” 'loss' íŒŒë¼ë¯¸í„°ê°’ì„ ì„¤ì • í–ˆì—ˆìŠµë‹ˆë‹¤. ì¦‰, Kerasì—ê²Œ ì†ì‹¤ê°’ì„ ê³„ì‚°í•˜ë„ë¡ ìš”ì²­í–ˆì§€ë§Œ, Kerasê°€ ì˜ˆìƒí•˜ëŠ” ìœ„ì¹˜ê°€ ëª¨ë¸ì—ë‹¤ê°€ ë ˆì´ë¸”ì„ ì§ì ‘ ì „ë‹¬í–ˆìŠµë‹ˆë‹¤! ë”°ë¼ì„œ ë‘˜ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤. ëª¨ë¸ì˜ ë‚´ë¶€ ì†ì‹¤ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê³  ë ˆì´ë¸”ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ê±°ë‚˜, Keras ì†ì‹¤í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê³  ë ˆì´ë¸”ì„ Kerasê°€ ì˜ˆìƒí•˜ëŠ” ìœ„ì¹˜ë¡œ ì´ë™í•´ì•¼ í•©ë‹ˆë‹¤. ì‹¬í”Œí•˜ê²Œ ì²« ë²ˆì§¸ ì ‘ê·¼ ë°©ì‹ì„ ì·¨í•˜ê² ìŠµë‹ˆë‹¤. `compile()`ì— ëŒ€í•œ í˜¸ì¶œì„ ë‹¤ìŒê³¼ ê°™ì´ ë³€ê²½í•©ë‹ˆë‹¤.:

```py
model.compile(optimizer="adam")
```

ì´ì œ ëª¨ë¸ì˜ ë‚´ë¶€ ì†ì‹¤ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê²Œ ë  ê²ƒì´ê³  ë¬¸ì œê°€ í•´ê²° ë  ê²ë‹ˆë‹¤!
Now we'll use the model's internal loss, and this problem should be resolved!

<Tip>

âœï¸ **ì—¬ëŸ¬ë¶„ ì°¨ë¡€ì…ë‹ˆë‹¤!** ë‹¤ë¥¸ ë¬¸ì œë¥¼ í•´ê²° í›„ ì¶”ê°€ ë„ì „ìœ¼ë¡œ, ì´ ë‹¨ê³„ë¡œ ëŒì•„ì™€ ëª¨ë¸ì´ ë‚´ë¶€ ì†ì‹¤ ëŒ€ì‹  ì›ë˜ Keras ì†ì‹¤í•¨ìˆ˜ë¡œ ì‘ë™í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë ˆì´ë¸”ì´ ì˜¬ë°”ë¥´ê²Œ ì¶œë ¥ë˜ë„ë¡ í•˜ë ¤ë©´ `to_tf_dataset()`ì˜ `label_cols` ì¸ìˆ˜ì— `"labels"`ë¥¼ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ê·¸ë˜ë””ì–¸íŠ¸ê°€ ê³„ì‚°ë©ë‹ˆë‹¤. í•˜ì§€ë§Œ ìš°ë¦¬ê°€ ì§€ì •í•œ ì†ì‹¤í•¨ìˆ˜ì—ëŠ” í•œ ê°€ì§€ ë¬¸ì œê°€ ë” ìˆìŠµë‹ˆë‹¤. í•™ìŠµì€ ë¬¸ì œê°€ ìˆìŒì—ë„ ë¶ˆêµ¬í•˜ê³  ê³„ì† ì‹¤í–‰ë˜ì§€ë§Œ í•™ìŠµì´ ë§¤ìš° ëŠë¦¬ê³  ë†’ì€ train ì†ì‹¤ê°’ì—ì„œ ì •ì²´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì™œ ê·¸ëŸ°ì§€ ì•Œì•„ ë³¼ê¹Œìš”?
 
ë§Œì•½ ì–´ë µë‹¤ë©´ ROT13 ì¸ì½”ë“œ ë°©ì‹ì˜ íŒíŠ¸ë¥¼ ë³´ì„¸ìš” Transformersì—ì„œ SequenceClassification ëª¨ë¸ì˜ ì¶œë ¥ì„ ë³´ë©´ ì²« ë²ˆì§¸ ì¶œë ¥ì€ 'logits'ì…ë‹ˆë‹¤. logitsë€ ë¬´ì—‡ì¼ê¹Œìš”?(ì‚´ë©´ì„œ ROT13 ì¸ì½”ë”©ì€ ì²˜ìŒ ë´¤ë„¤ìš”, ê¶ê¸ˆí•˜ë©´ ì˜ì–´ ì›ë³¸ìœ¼ë¡œ ë³´ì„¸ìš”.)

ë‘ë²ˆì§¸ íŒíŠ¸: ì˜µí‹°ë§ˆì´ì €, í™œì„±í•¨ìˆ˜ ë˜ëŠ” ì†ì‹¤í•¨ìˆ˜ë¥¼ ë¬¸ìì—´ë¡œ ì§€ì •í•˜ë©´ KerasëŠ” í•´ë‹¹ í•¨ìˆ˜ì˜ ëª¨ë“  ì¸ìˆ˜ ê°’ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤. SparseCategoricalCrossentropyì—ëŠ” ì–´ë–¤ ì¸ìˆ˜ê°€ ìˆìœ¼ë©° ê¸°ë³¸ê°’ì€ ë¬´ì—‡ì¼ê¹Œìš”?

</Tip>

ì´ì œ í›ˆë ¨ì„ í•´ë³´ì£ . ê·¸ë¼ë””ì–¸íŠ¸ë¥¼ ê°€ì ¸ì™€ì•¼ í•˜ë¯€ë¡œ ë¶€ë””(ê°‘ìê¸° ë¶ˆê¸¸í•œ ìŒì•…ì´ ì¬ìƒë¨) `model.fit()`ì„ í˜¸ì¶œí•˜ë©´ ëª¨ë“  ê²ƒì´ ì˜ ì‘ë™í•  ê²ƒì…ë‹ˆë‹¤!

```python out
  246/24543 [..............................] - ETA: 15:52 - loss: nan
```

ì´ëŸ°.

`nan`ì€ ì© ë‚´í‚¤ì§€ ì•ŠëŠ” ì†ì‹¤ê°’ ì…ë‹ˆë‹¤. ë°ì´í„°ë¥¼ í™•ì¸í–ˆì—ˆì§€ë§Œ ê´œì°®ì•„ ë³´ì˜€ëŠ”ë° ë§ì´ì£ . ì´ê²Œ ë¬¸ì œê°€ ì•„ë‹ˆë¼ë©´ ë‹¤ìŒì€ ì–´ë–¤ ê²ƒì„ í™•ì¸í•´ì•¼í• ê¹Œìš”? ë‹¤ìŒ ë‹¨ê³„ëŠ” ë¶„ëª…íˆ...

### ëª¨ë¸ í™•ì¸

`model.fit()`ì€ Kerasì—ì„œ ì •ë§ í›Œë¥­í•œ í•¨ìˆ˜ì´ì§€ë§Œ ë§ì€ ì¼ì„ ìˆ˜í–‰í•˜ë¯€ë¡œ ë¬¸ì œê°€ ë°œìƒí•œ ìœ„ì¹˜ë¥¼ ì •í™•íˆ ì°¾ê¸°ê°€ ë” ì–´ë ¤ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëª¨ë¸ì„ ë””ë²„ê¹…í•˜ëŠ” ê²½ìš° ì§„ì§œ ë„ì›€ì´ ë ë§Œí•œ ì „ëµìœ¼ë¡œ ëª¨ë¸ì— ë‹¨ì¼ ë°°ì¹˜ë¥¼ ì „ë‹¬í•˜ê³  í•´ë‹¹ ë°°ì¹˜ì— ëŒ€í•œ ì¶œë ¥ì„ ìì„¸íˆ ì‚´í´ë³´ëŠ” ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤. ëª¨ë¸ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ëŠ” ê²½ìš° ì •ë§ ìœ ìš©í•œ ë˜ ë‹¤ë¥¸ íŒì€ `run_eagerly=True`ë¡œ ëª¨ë¸ì„ `compile()`í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì†ë„ê°€ í›¨ì”¬ ëŠë ¤ì§€ì§€ë§Œ ëª¨ë¸ ì½”ë“œì—ì„œ ë¬¸ì œê°€ ë°œìƒí•œ ìœ„ì¹˜ë¥¼ ì •í™•íˆ ë‚˜íƒ€ë‚´ê¸° ë•Œë¬¸ì— ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ í›¨ì”¬ ë” ì´í•´í•˜ê¸° ì‰½ê²Œ ë§Œë“­ë‹ˆë‹¤.


For now, though, we don't need `run_eagerly` just yet. Let's run the `batch` we got before through the model and see what the outputs look like:

```py
model(batch)
```

```python out
TFSequenceClassifierOutput(loss=<tf.Tensor: shape=(16,), dtype=float32, numpy=
array([nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan,
       nan, nan, nan], dtype=float32)>, logits=<tf.Tensor: shape=(16, 2), dtype=float32, numpy=
array([[nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan],
       [nan, nan]], dtype=float32)>, hidden_states=None, attentions=None)
```

Well, this is tricky. Everything is `nan`! But that's strange, isn't it? How would all our logits become `nan`? `nan` means "not a number." `nan` values often occur when you perform a forbidden operation, such as division by zero. But one thing that's very important to know about `nan` in machine learning is that this value tends to *propagate*. If you multiply a number by `nan`, the output is also `nan`. And if you get a `nan` anywhere in your output, your loss, or your gradient, then it will rapidly spread throughout your whole model -- because when that `nan` value is propagated back through your network, you'll get `nan` gradients, and when weight updates are computed with those gradients, you'll get `nan` weights, and those weights will compute even more `nan` outputs! Soon enough the whole network will just be one big block of `nan`s. Once that happens, it's pretty hard to see where the problem started. How can we isolate where `nan` first crept in?

The answer is to try *reinitializing* our model. Once we started training, we got a `nan` somewhere and it quickly propagated through the whole model. So, let's load the model from a checkpoint and not do any weight updates, and see where we get a `nan` value:

```py
model = TFAutoModelForSequenceClassification.from_pretrained(model_checkpoint)
model(batch)
```

When we run that, we get:

```py out
TFSequenceClassifierOutput(loss=<tf.Tensor: shape=(16,), dtype=float32, numpy=
array([0.6844486 ,        nan,        nan, 0.67127866, 0.7068601 ,
              nan, 0.69309855,        nan, 0.65531296,        nan,
              nan,        nan, 0.675402  ,        nan,        nan,
       0.69831556], dtype=float32)>, logits=<tf.Tensor: shape=(16, 2), dtype=float32, numpy=
array([[-0.04761693, -0.06509043],
       [-0.0481936 , -0.04556257],
       [-0.0040929 , -0.05848458],
       [-0.02417453, -0.0684005 ],
       [-0.02517801, -0.05241832],
       [-0.04514256, -0.0757378 ],
       [-0.02656011, -0.02646275],
       [ 0.00766164, -0.04350497],
       [ 0.02060014, -0.05655622],
       [-0.02615328, -0.0447021 ],
       [-0.05119278, -0.06928903],
       [-0.02859691, -0.04879177],
       [-0.02210129, -0.05791225],
       [-0.02363213, -0.05962167],
       [-0.05352269, -0.0481673 ],
       [-0.08141848, -0.07110836]], dtype=float32)>, hidden_states=None, attentions=None)
```

*Now* we're getting somewhere! There are no `nan` values in our logits, which is reassuring. But we do see a few `nan` values in our loss! Is there something about those samples in particular that's causing this problem? Let's see which ones they are (note that if you run this code yourself, you may get different indices because the dataset has been shuffled):

```python
import numpy as np

loss = model(batch).loss.numpy()
indices = np.flatnonzero(np.isnan(loss))
indices
```

```python out
array([ 1,  2,  5,  7,  9, 10, 11, 13, 14])
```

Let's look at the samples these indices came from:

```python
input_ids = batch["input_ids"].numpy()
input_ids[indices]
```

```python out
array([[  101,  2007,  2032,  2001,  1037, 16480,  3917,  2594,  4135,
        23212,  3070,  2214, 10170,  1010,  2012,  4356,  1997,  3183,
         6838, 12953,  2039,  2000,  1996,  6147,  1997,  2010,  2606,
         1012,   102,  6838,  2001,  3294,  6625,  3773,  1996,  2214,
         2158,  1012,   102,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0],
       [  101,  1998,  6814,  2016,  2234,  2461,  2153,  1998, 13322,
         2009,  1012,   102,  2045,  1005,  1055,  2053,  3382,  2008,
         2016,  1005,  2222,  3046,  8103,  2075,  2009,  2153,  1012,
          102,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0],
       [  101,  1998,  2007,  1996,  3712,  4634,  1010,  2057,  8108,
         2025,  3404,  2028,  1012,  1996,  2616, 18449,  2125,  1999,
         1037,  9666,  1997,  4100,  8663, 11020,  6313,  2791,  1998,
         2431,  1011,  4301,  1012,   102,  2028,  1005,  1055,  5177,
         2110,  1998,  3977,  2000,  2832,  2106,  2025,  2689,  2104,
         2122,  6214,  1012,   102,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0],
       [  101,  1045,  2001,  1999,  1037, 13090,  5948,  2007,  2048,
         2308,  2006,  2026,  5001,  2043,  2026,  2171,  2001,  2170,
         1012,   102,  1045,  2001,  3564,  1999,  2277,  1012,   102,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0],
       [  101,  2195,  4279,  2191,  2039,  1996,  2181,  2124,  2004,
         1996,  2225,  7363,  1012,   102,  2045,  2003,  2069,  2028,
         2451,  1999,  1996,  2225,  7363,  1012,   102,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0],
       [  101,  2061,  2008,  1045,  2123,  1005,  1056,  2113,  2065,
         2009,  2428, 10654,  7347,  2030,  2009,  7126,  2256,  2495,
         2291,   102,  2009,  2003,  5094,  2256,  2495,  2291,  2035,
         2105,  1012,   102,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0],
       [  101,  2051,  1010,  2029,  3216,  2019,  2503,  3444,  1010,
         6732,  1996,  2265,  2038, 19840,  2098,  2125,  9906,  1998,
         2003,  2770,  2041,  1997,  4784,  1012,   102,  2051,  6732,
         1996,  2265,  2003,  9525,  1998,  4569,  1012,   102,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0],
       [  101,  1996, 10556,  2140, 11515,  2058,  1010,  2010,  2162,
         2252,  5689,  2013,  2010,  7223,  1012,   102,  2043,  1996,
        10556,  2140, 11515,  2058,  1010,  2010,  2252,  3062,  2000,
         1996,  2598,  1012,   102,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0],
       [  101, 13543,  1999,  2049,  6143,  2933,  2443,   102,  2025,
        13543,  1999,  6143,  2933,  2003,  2443,   102,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0,     0,     0,     0,     0,     0,
            0,     0,     0,     0]])
```

Well, there's a lot in here, but nothing stands out as unusual. Let's look at the labels:

```python out
labels = batch['labels'].numpy()
labels[indices]
```

```python out
array([2, 2, 2, 2, 2, 2, 2, 2, 2])
```

Ah! The `nan` samples all have the same label, and it's label 2. This is a very strong hint. The fact that we're only getting a loss of `nan` when our label is 2 suggests that this is a very good time to check the number of labels in our model:

```python
model.config.num_labels
```

```python out
2
```

Now we see the problem: the model thinks there are only two classes, but the labels go up to 2, which means there are in fact three classes (because 0 is also a class). This is how we got a `nan` -- by trying to compute the loss for a nonexistent class! Let's try changing that and fitting the model again:

```
model = TFAutoModelForSequenceClassification.from_pretrained(model_checkpoint, num_labels=3)
model.compile(optimizer='adam')
model.fit(train_dataset)
```

```python out
  869/24543 [>.............................] - ETA: 15:29 - loss: 1.1032
```

We're training! No more `nan`s, and our loss is declining... sort of. If you watch it for a while, you might start to get a bit impatient, because the loss value stays stubbornly high. Let's stop training here and try to think about what could be causing this problem. At this point, we're pretty sure both the data and the model are okay, but our model isn't learning well. What else is left? It's time to...

### Check your hyperparameters

If you look back at the code above, you might not be able to see any hyperparameters at all, except perhaps the `batch_size`, and that doesn't seem like a likely culprit. Don't be fooled, though; there are always hyperparameters, and if you can't see them, it just means that you don't know what they're set to. In particular, remember a critical thing about Keras: if you set a loss, optimizer, or activation function with a string, _all of its arguments will be set to their default values_. This means that even though using strings for this is very convenient, you should be very careful when doing so, as it can easily hide critical things from you. (Anyone trying the optional challenge above should take careful note of this fact.)

In this case, where have we set an argument with a string? We were setting the loss with a string initially, but we're not doing that anymore. We are, however, setting the optimizer with a string. Could that be hiding anything from us? Let's take a look at [its arguments](https://www.tensorflow.org/api_docs/python/tf/keras/optimizers/Adam).

Does anything stand out here? That's right -- the learning rate! When we just use the string `'adam'`, we're going to get the default learning rate, which is 0.001, or 1e-3. This is way too high for a Transformer model! In general, we recommend trying learning rates between 1e-5 and 1e-4 for your models; that's somewhere between 10X and 100X smaller than the value we're actually using here. That sounds like it might be a major problem, so let's try reducing it. To do that, we need to import the actual `optimizer` object. While we're at it, let's reinitialize the model from the checkpoint, in case training with the high learning rate damaged its weights:

```python
from tensorflow.keras.optimizers import Adam

model = TFAutoModelForSequenceClassification.from_pretrained(model_checkpoint)
model.compile(optimizer=Adam(5e-5))
```

<Tip>

ğŸ’¡ You can also import the `create_optimizer()` function from ğŸ¤— Transformers, which will give you an AdamW optimizer with correct weight decay as well as learning rate warmup and decay. This optimizer will often produce slightly better results than the ones you get with the default Adam optimizer.

</Tip>

Now, we can try fitting the model with the new, improved learning rate:

```python
model.fit(train_dataset)
```

```python out
319/24543 [..............................] - ETA: 16:07 - loss: 0.9718
```

Now our loss is really going somewhere! Training finally looks like it's working. There's a lesson here: when your model is running but loss isn't declining, and you're sure your data is okay, it's a good idea to check hyperparameters like the learning rate and weight decay. Setting either of those too high is very likely to cause training to "stall" at a high loss value.

## Other potential issues 

We've covered the issues in the script above, but there are several other common errors you might face. Let's take a look at a (very incomplete) list.

### Dealing with out-of-memory errors

The telltale sign of running out of memory is an error like "OOM when allocating tensor" -- OOM is short for "out of memory." This is a very common hazard when dealing with large language models. If you encounter this, a good strategy is to halve your batch size and try again. Bear in mind, though, that some models are *very* large. For example, the full-size GPT-2 has 1.5B parameters, which means you'll need 6 GB of memory just to store the model, and another 6 GB for its gradients! Training the full GPT-2 model will usually require over 20 GB of VRAM no matter what batch size you use, which only a few GPUs have. More lightweight models like `distilbert-base-cased` are much easier to run, and train much more quickly too.

<Tip>

In the next part of the course, we'll look at more advanced techniques that can help you reduce your memory footprint and let you fine-tune the biggest models.

</Tip>

### Hungry Hungry TensorFlow ğŸ¦›

One particular quirk of TensorFlow that you should be aware of is that it allocates *all* of your GPU memory to itself as soon as you load a model or do any training, and then it divides up that memory as required. This is different from the behavior of other frameworks, like PyTorch, which allocate memory as required with CUDA rather than doing it internally. One advantage of the TensorFlow approach is that it can often give useful errors when you run out of memory, and it can recover from that state without crashing the whole CUDA kernel. But there's also an important downside: if you run two TensorFlow processes at once, then **you're going to have a bad time**.

If you're running on Colab you don't need to worry about this, but if you're running locally this is definitely something you should be careful about. In particular, be aware that closing a notebook tab does not necessarily shut that notebook down! You may need to select running notebooks (the ones with a green icon) and manually shut them down in the directory listing. Any running notebook that was using TensorFlow could still be holding on to a bunch of your GPU memory, and that means any new notebook you start may encounter some very odd issues.

If you start getting errors about CUDA, BLAS, or cuBLAS in code that worked before, this is very often the culprit. You can use a command like `nvidia-smi` to check -- when you shut down or restart your current notebook, is most of your memory free, or is it still in use? If it's still in use, something else is holding on to it!


### Check your data (again!)

Your model will only learn something if it's actually possible to learn anything from your data. If there is a bug that corrupts the data or the labels are attributed randomly, it's very likely you won't get any model training on your dataset. One helpful tool here is `tokenizer.decode()`. This will turn `input_ids` back into strings, so you can view the data and see if your training data is teaching what you want it to teach. For example, after you get a `batch` from your `tf.data.Dataset` like we did above, you can decode the first element like so:

```py
input_ids = batch["input_ids"].numpy()
tokenizer.decode(input_ids[0])
```

Then you can compare it with the first label, like so:

```py
labels = batch["labels"].numpy()
label = labels[0]
```

Once you can view your data like this, you can ask yourself the following questions:

- Is the decoded data understandable?
- Do you agree with the labels?
- Is there one label that's more common than the others?
- What should the loss/metric be if the model predicted a random answer/always the same answer?

After looking at your data, go through a few of the model's predictions -- if your model outputs tokens, try decoding them too! If the model is always predicting the same thing it might be because your dataset is biased toward one category (for classification problems), so techniques like oversampling rare classes might help. Alternatively, this can also be caused by training issues like bad hyperparameter settings.

If the loss/metric you get on your initial model before any training is very different from the loss/metric you would expect for random predictions, double-check the way your loss or metric is computed, as there is probably a bug there. If you are using several losses that you add at the end, make sure they are of the same scale.

When you are sure your data is perfect, you can see if the model is capable of training on it with one simple test.

### Overfit your model on one batch

Overfitting is usually something we try to avoid when training, as it means the model is not learning to recognize the general features we want it to but is instead just memorizing the training samples. However, trying to train your model on one batch over and over again is a good test to check if the problem as you framed it can be solved by the model you are attempting to train. It will also help you see if your initial learning rate is too high.

Doing this once you have defined your `model` is really easy; just grab a batch of training data, then treat that `batch` as your entire dataset, fitting on it for a large number of epochs:

```py
for batch in train_dataset:
    break

# Make sure you have run model.compile() and set your optimizer,
# and your loss/metrics if you're using them

model.fit(batch, epochs=20)
```

<Tip>

ğŸ’¡ If your training data is unbalanced, make sure to build a batch of training data containing all the labels.

</Tip>

The resulting model should have close-to-perfect results on the `batch`, with a loss declining quickly toward 0 (or the minimum value for the loss you're using).

If you don't manage to have your model obtain perfect results like this, it means there is something wrong with the way you framed the problem or your data, so you should fix that. Only when you manage to pass the overfitting test can you be sure that your model can actually learn something.

<Tip warning={true}>

âš ï¸ You will have to recreate your model and recompile after this overfitting test, as the model obtained probably won't be able to recover and learn something useful on your full dataset.

</Tip>

### Don't tune anything until you have a first baseline

Intense hyperparameter tuning is always emphasized as being the hardest part of machine learning, but it's just the last step to help you gain a little bit on the metric. *Very* bad values for your hyperparameters, like using the default Adam learning rate of 1e-3 with a Transformer model, will make learning proceed very slowly or completely stall, of course, but most of the time "reasonable" hyperparameters, like a learning rate from 1e-5 to 5e-5, will work just fine to give you good results. So, don't launch into a time-consuming and costly hyperparameter search until you have something that beats the baseline you have on your dataset.

Once you have a good enough model, you can start tweaking a bit. Don't try launching a thousand runs with different hyperparameters, but compare a couple of runs with different values for one hyperparameter to get an idea of which has the greatest impact.

If you are tweaking the model itself, keep it simple and don't try anything you can't reasonably justify. Always make sure you go back to the overfitting test to verify that your change hasn't had any unintended consequences.

### Ask for help

Hopefully you will have found some advice in this section that helped you solve your issue, but if that's not the case, remember you can always ask the community on the [forums](https://discuss.huggingface.co/). 

Here are some additional resources that may prove helpful:

- ["Reproducibility as a vehicle for engineering best practices"](https://docs.google.com/presentation/d/1yHLPvPhUs2KGI5ZWo0sU-PKU3GimAk3iTsI38Z-B5Gw/edit#slide=id.p) by Joel Grus
- ["Checklist for debugging neural networks"](https://towardsdatascience.com/checklist-for-debugging-neural-networks-d8b2a9434f21) by Cecelia Shao
- ["How to unit test machine learning code"](https://medium.com/@keeper6928/how-to-unit-test-machine-learning-code-57cf6fd81765) by Chase Roberts
- ["A Recipe for Training Neural Networks"](http://karpathy.github.io/2019/04/25/recipe/) by Andrej Karpathy

Of course, not every problem you encounter when training neural nets is your own fault! If you encounter something in the ğŸ¤— Transformers or ğŸ¤— Datasets library that does not seem right, you may have encountered a bug. You should definitely tell us all about it, and in the next section we'll explain exactly how to do that.
