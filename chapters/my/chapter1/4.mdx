# Transformers တွေက ဘယ်လိုအလုပ်လုပ်လဲ။[[how-do-transformers-work]]

<CourseFloatingBanner
    chapter={1}
    classNames="absolute z-10 right-0 top-0"
/>

ဒီအပိုင်းမှာတော့ Transformer မော်ဒယ်တွေရဲ့ architecture ကို ကြည့်ရှုမှာဖြစ်ပြီး attention, encoder-decoder architecture နဲ့ အခြားအကြောင်းအရာတွေကို ပိုမိုနက်ရှိုင်းစွာ လေ့လာသွားမှာ ဖြစ်ပါတယ်။

> [!WARNING]
> 🚀 ဒီမှာ အရှိန်မြှင့်လိုက်ပါပြီ။ ဒီအပိုင်းက အသေးစိတ်ပြီး နည်းပညာပိုင်းဆိုင်ရာ အချက်အလက်များပါတယ်။ ဒါကြောင့် ချက်ချင်း နားမလည်ရင် စိတ်မပူပါနဲ့။ ဒီအယူအဆတွေကို သင်တန်းရဲ့ နောက်ပိုင်းမှာ ပြန်ပြီး ပြောပြပေးပါမယ်။

## Transformer သမိုင်း အနည်းငယ်[[a-bit-of-transformer-history]]

Transformer မော်ဒယ်တွေရဲ့ (တိုတောင်းတဲ့) သမိုင်းမှာ အရေးပါတဲ့ အချက်အချို့ကို ဒီမှာ ဖော်ပြထားပါတယ်။

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/transformers_chrono.svg" alt="A brief chronology of Transformers models.">
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/transformers_chrono-dark.svg" alt="A brief chronology of Transformers models.">
</div>

[Transformer architecture](https://arxiv.org/abs/1706.03762) ကို ၂၀၁၇ ခုနှစ်၊ ဇွန်လမှာ စတင်မိတ်ဆက်ခဲ့ပါတယ်။ မူလသုတေသနရဲ့ အဓိကအာရုံကတော့ ဘာသာပြန်ခြင်း လုပ်ငန်းတွေ ဖြစ်ပါတယ်။ ထို့နောက်မှာတော့ သြဇာကြီးမားတဲ့ မော်ဒယ်များစွာကို မိတ်ဆက်ခဲ့ပါတယ်။ ၎င်းတို့မှာ-

- **၂၀၁၈ ခုနှစ်၊ ဇွန်လ**: [GPT](https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf)၊ ပထမဆုံးသော pretrained Transformer model ဖြစ်ပြီး NLP လုပ်ငန်းမျိုးစုံအတွက် fine-tuning လုပ်ရာမှာ အသုံးပြုခဲ့ကာ state-of-the-art ရလဒ်များကို ရရှိခဲ့ပါတယ်။

- **၂၀၁၈ ခုနှစ်၊ အောက်တိုဘာလ**: [BERT](https://arxiv.org/abs/1810.04805)၊ နောက်ထပ်ကြီးမားတဲ့ pretrained model တစ်ခုဖြစ်ပြီး စာကြောင်းတွေရဲ့ အနှစ်ချုပ်တွေကို ပိုမိုကောင်းမွန်အောင် ထုတ်လုပ်ဖို့ ဒီဇိုင်းထုတ်ထားပါတယ်။ (နောက်အခန်းမှာ အသေးစိတ်ပြောပါမယ်!)

- **၂၀၁၉ ခုနှစ်၊ ဖေဖော်ဝါရီလ**: [GPT-2](https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf)၊ GPT ရဲ့ ပိုမိုကောင်းမွန်ပြီး (ပိုကြီးတဲ့) ဗားရှင်းတစ်ခုဖြစ်ပြီး ကျင့်ဝတ်ဆိုင်ရာ စိုးရိမ်ပူပန်မှုတွေကြောင့် ချက်ချင်းထုတ်ပြန်ခြင်း မရှိခဲ့ပါဘူး။

- **၂၀၁၉ ခုနှစ်၊ အောက်တိုဘာလ**: [T5](https://huggingface.co/papers/1910.10683)၊ sequence-to-sequence Transformer architecture ကို အခြေခံပြီး multi-task focused လုပ်ဆောင်နိုင်သော မော်ဒယ်တစ်ခု။

- **၂၀၂၀ ခုနှစ်၊ မေလ**: [GPT-3](https://huggingface.co/papers/2005.14165)၊ GPT-2 ထက် ပိုမိုကြီးမားသော ဗားရှင်းဖြစ်ပြီး fine-tuning လုပ်ရန်မလိုဘဲ လုပ်ငန်းမျိုးစုံကို ကောင်းစွာလုပ်ဆောင်နိုင်ပါတယ်။ (၎င်းကို _zero-shot learning_ ဟု ခေါ်ပါတယ်။)

- **၂၀၂၂ ခုနှစ်၊ ဇန်နဝါရီလ**: [InstructGPT](https://huggingface.co/papers/2203.02155)၊ ညွှန်ကြားချက်များကို ပိုမိုကောင်းမွန်စွာ လိုက်နာနိုင်ရန် လေ့ကျင့်ပေးထားသော GPT-3 ၏ ဗားရှင်းတစ်ခု။

ဒီစာရင်းက ပြည့်စုံလွန်းတာ မဟုတ်ပါဘူး။ Transformer မော်ဒယ်အမျိုးအစားအချို့ကိုသာ မီးမောင်းထိုးပြထားတာ ဖြစ်ပါတယ်။ ယေဘုယျအားဖြင့် ၎င်းတို့ကို အမျိုးအစား သုံးမျိုး ခွဲခြားနိုင်ပါတယ်။

- **၂၀၂၃ ခုနှစ်၊ ဇန်နဝါရီလ**: [Llama](https://huggingface.co/papers/2302.13971)၊ ဘာသာစကားမျိုးစုံဖြင့် စာသားများစွာကို ဖန်တီးနိုင်သော Large Language Model တစ်ခု။

- **၂၀၂၃ ခုနှစ်၊ မတ်လ**: [Mistral](https://huggingface.co/papers/2310.06825)၊ parameter ၇ ဘီလီယံပါရှိသော language model ဖြစ်ပြီး အကဲဖြတ်ထားသော benchmark အားလုံးတွင် Llama 2 13B ကို သာလွန်သည်။ ၎င်းသည် ပိုမိုမြန်ဆန်သော inference အတွက် grouped-query attention နှင့် စိတ်ကြိုက်အလျားရှိသော sequences များကို ကိုင်တွယ်ရန် sliding window attention ကို အသုံးပြုသည်။

- **၂၀၂၄ ခုနှစ်၊ မေလ**: [Gemma 2](https://huggingface.co/papers/2408.00118)၊ 2B မှ 27B parameters အထိ ရှိသော ပေါ့ပါးသော၊ state-of-the-art open models မိသားစုတစ်ခုဖြစ်ပြီး interleaved local-global attentions နှင့် group-query attention တို့ကို ပေါင်းစပ်ထားသည်။ ပိုမိုသေးငယ်သော မော်ဒယ်များကို knowledge distillation အသုံးပြု၍ လေ့ကျင့်ထားပြီး ၎င်းတို့ထက် ၂-၃ ဆ ပိုကြီးသော မော်ဒယ်များနှင့် ယှဉ်ပြိုင်နိုင်သော စွမ်းဆောင်ရည်ကို ပေးသည်။

- **၂၀၂၄ ခုနှစ်၊ နိုဝင်ဘာလ**: [SmolLM2](https://huggingface.co/papers/2502.02737)၊ state-of-the-art small language model (135 million မှ 1.7 billion parameters) ဖြစ်ပြီး ၎င်း၏ ကျစ်လျစ်သော အရွယ်အစားရှိသော်လည်း ထူးခြားသော စွမ်းဆောင်ရည်ကို ရရှိစေပြီး mobile နှင့် edge devices များအတွက် ဖြစ်နိုင်ခြေအသစ်များကို ဖွင့်ပေးသည်။

- GPT-ကဲ့သို့သော မော်ဒယ်များ  (_auto-regressive_ Transformer models လို့လည်းခေါ်ကြပါတယ်)
- BERT-ကဲ့သို့သော မော်ဒယ်များ(_auto-encoding_ Transformer models  လို့လည်းခေါ်ကြပါတယ်) 
- T5-ကဲ့သို့သော မော်ဒယ်များ (_sequence-to-sequence_ Transformer models  လို့လည်းခေါ်ကြပါတယ်)

ဒီအမျိုးအစားတွေကို နောက်ပိုင်းမှာ ပိုမိုနက်နဲစွာ လေ့လာသွားမှာ ဖြစ်ပါတယ်။

## Transformers တွေဟာ language models တွေ ဖြစ်ပါတယ်။ [[transformers-are-language-models]]

အထက်မှာ ဖော်ပြခဲ့တဲ့ Transformer မော်ဒယ်အားလုံး (GPT, BERT, T5, စသည်ဖြင့်) ကို *language models* အဖြစ် လေ့ကျင့်ထားပါတယ်။ ဒါကတော့ ၎င်းတို့ကို များပြားလှတဲ့ ကုန်ကြမ်းစာသား(raw texts)တွေပေါ်မှာ self-supervised ပုံစံနဲ့ လေ့ကျင့်ထားတယ်လို့ ဆိုလိုပါတယ်။

Self-supervised learning ဆိုတာက မော်ဒယ်ရဲ့ input တွေကနေ ရည်ရွယ်ချက်ကို အလိုအလျောက် တွက်ချက်ပေးတဲ့ သင်ယူမှုပုံစံတစ်ခုပါ။ ဒါကြောင့် ဒေတာတွေကို လူသားတွေက label လုပ်ပေးဖို့ မလိုအပ်ပါဘူး။

ဒီလို မော်ဒယ်မျိုးက သူ လေ့ကျင့်ထားတဲ့ ဘာသာစကားရဲ့ စာရင်းအင်းဆိုင်ရာ နားလည်မှုကို တည်ဆောက်ပေမယ့်၊ သီးခြားလက်တွေ့လုပ်ငန်းတာဝန်တွေအတွက်တော့ အသုံးဝင်မှု နည်းပါးပါတယ်။ ဒါကြောင့် ယေဘုယျ pretrained မော်ဒယ်ကို *transfer learning* ဒါမှမဟုတ် *fine-tuning* လို့ခေါ်တဲ့ လုပ်ငန်းစဉ်တစ်ခုကို လုပ်ဆောင်ပါတယ်။ ဒီလုပ်ငန်းစဉ်အတွင်းမှာ မော်ဒယ်ကို -- လူသားတွေက annotated လုပ်ထားတဲ့ labels တွေ အသုံးပြုပြီး -- ပေးထားတဲ့ လုပ်ငန်းတာဝန်တစ်ခုပေါ်မှာ supervised ပုံစံနဲ့ fine-tune လုပ်ပါတယ်။

လုပ်ငန်းတာဝန်တစ်ခုရဲ့ ဥပမာတစ်ခုကတော့ ယခင် *n* စကားလုံးတွေကို ဖတ်ပြီးနောက် စာကြောင်းတစ်ခုရဲ့ နောက်စကားလုံးကို ခန့်မှန်းခြင်းပါပဲ။ ဒါကို *causal language modeling* လို့ ခေါ်ပါတယ်။ ဘာဖြစ်လို့လဲဆိုတော့ output က အတိတ်နဲ့ ပစ္စုပ္ပန် input တွေပေါ် မူတည်ပေမယ့် အနာဂတ် input တွေပေါ် မမူတည်လို့ပါ။

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/causal_modeling.svg" alt="Example of causal language modeling in which the next word from a sentence is predicted.">
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/causal_modeling-dark.svg" alt="Example of causal language modeling in which the next word from a sentence is predicted.">
</div>

နောက်ထပ် ဥပမာတစ်ခုကတော့ *masked language modeling* ဖြစ်ပြီး၊ အဲဒီမှာ မော်ဒယ်က စာကြောင်းထဲက masked word ကို ခန့်မှန်းပါတယ်။

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/masked_modeling.svg" alt="Example of masked language modeling in which a masked word from a sentence is predicted.">
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/masked_modeling-dark.svg" alt="Example of masked language modeling in which a masked word from a sentence is predicted.">
</div>

## Transformers တွေဟာ မော်ဒယ်ကြီးတွေ ဖြစ်ပါတယ်။[[transformers-are-big-models]]

DistilBERT လို ထူးခြားချက်အချို့ကလွဲလို့ ပိုမိုကောင်းမွန်တဲ့ စွမ်းဆောင်ရည်ကို ရရှိဖို့အတွက် ယေဘုယျနည်းဗျူဟာကတော့ မော်ဒယ်တွေရဲ့ အရွယ်အစားကို တိုးမြှင့်ခြင်းအပြင် ၎င်းတို့ကို pretrain လုပ်တဲ့ ဒေတာပမာဏကိုပါ တိုးမြှင့်ခြင်း ဖြစ်ပါတယ်။

<div class="flex justify-center">
<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/model_parameters.png" alt="Number of parameters of recent Transformers models" width="90%">
</div>

ကံမကောင်းစွာနဲ့ပဲ မော်ဒယ်တစ်ခု၊ အထူးသဖြင့် မော်ဒယ်ကြီးတစ်ခုကို လေ့ကျင့်ဖို့အတွက် ဒေတာအမြောက်အမြား လိုအပ်ပါတယ်။ ဒါကတော့ အချိန်နဲ့ ကွန်ပျူတာ အရင်းအမြစ်တွေအတွက် အလွန်ကုန်ကျများပါတယ်။ အောက်ပါ graph မှာ မြင်ရတဲ့အတိုင်း သဘာဝပတ်ဝန်းကျင်အပေါ် သက်ရောက်မှုတွေလည်း ရှိပါတယ်။

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/carbon_footprint.svg" alt="The carbon footprint of a large language model.">
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/carbon_footprint-dark.svg" alt="The carbon footprint of a large language model.">
</div>

<Youtube id="ftWlj4FBHTg"/>

ဒါကတော့ pretraining ရဲ့ သဘာဝပတ်ဝန်းကျင်အပေါ် သက်ရောက်မှုကို လျှော့ချဖို့ သတိရှိရှိ ကြိုးစားနေတဲ့ အဖွဲ့တစ်ဖွဲ့က ဦးဆောင်တဲ့ (အလွန်ကြီးမားတဲ့) မော်ဒယ်တစ်ခုအတွက် စီမံကိန်းကို ပြသနေတာ ဖြစ်ပါတယ်။ အကောင်းဆုံး hyperparameters တွေ ရရှိဖို့အတွက် စမ်းသပ်မှုများစွာကို လုပ်ဆောင်ခဲ့ရင် ထွက်လာမယ့် ကာဗွန်ခြေရာက ပိုမိုမြင့်မားပါလိမ့်မယ်။

သုတေသနအဖွဲ့၊ ကျောင်းသားအဖွဲ့အစည်း ဒါမှမဟုတ် ကုမ္ပဏီတစ်ခုက မော်ဒယ်တစ်ခုကို လေ့ကျင့်ချင်တိုင်း အစကနေ ပြန်လေ့ကျင့်ရမယ်ဆိုရင် ဘယ်လိုဖြစ်မလဲဆိုတာ စဉ်းစားကြည့်ပါ။ ဒါက ကမ္ဘာလုံးဆိုင်ရာ အလွန်ကြီးမားပြီး မလိုအပ်တဲ့ ကုန်ကျစရိတ်တွေ ဖြစ်ပေါ်စေပါလိမ့်မယ်။

ဒါကြောင့် language models တွေကို မျှဝေခြင်းဟာ အလွန်အရေးကြီးပါတယ်။ လေ့ကျင့်ပြီးသား weights တွေကို မျှဝေခြင်းနဲ့ ရှိပြီးသား weights တွေပေါ်မှာ တည်ဆောက်ခြင်းက အလုံးစုံ ကွန်ပျူတာကုန်ကျစရိတ်နဲ့ ကာဗွန်ခြေရာကို လျှော့ချပေးပါတယ်။

စကားမစပ်၊ သင့်မော်ဒယ်တွေရဲ့ training ကာဗွန်ခြေရာကို ကိရိယာများစွာနဲ့ အကဲဖြတ်နိုင်ပါတယ်။ ဥပမာ [ML CO2 Impact](https://mlco2.github.io/impact/) ဒါမှမဟုတ် 🤗 Transformers မှာ ပေါင်းစပ်ပါဝင်တဲ့ [Code Carbon]( https://codecarbon.io/) စတာတွေ ဖြစ်ပါတယ်။ ဒီအကြောင်း ပိုမိုသိရှိလိုပါက သင်ရဲ့ training ရဲ့ ခြေရာကို ခန့်မှန်းပေးမယ့် `emissions.csv` ဖိုင်တစ်ခုကို ဘယ်လိုထုတ်လုပ်ရမယ်ဆိုတာ ပြသထားတဲ့ [blog post](https://huggingface.co/blog/carbon-emissions-on-the-hub) ကို ဖတ်ရှုနိုင်ပါတယ်။ ဒါ့အပြင် ဒီအကြောင်းအရာကို ဆွေးနွေးထားတဲ့ 🤗 Transformers ရဲ့ [documentation](https://huggingface.co/docs/hub/model-cards-co2)  ကိုလည်း ဖတ်ရှုနိုင်ပါတယ်။

## Transfer Learning[[transfer-learning]]

<Youtube id="BqqfQnyjmgg" />

*Pretraining* ဆိုတာက မော်ဒယ်တစ်ခုကို အစကနေ လေ့ကျင့်ခြင်းဖြစ်ပါတယ်။ weights တွေကို ကျပန်းသတ်မှတ်ပြီး သင်ယူမှုအတွေ့အကြုံမရှိဘဲ လေ့ကျင့်မှု စတင်ပါတယ်။

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/pretraining.svg" alt="The pretraining of a language model is costly in both time and money.">
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/pretraining-dark.svg" alt="The pretraining of a language model is costly in both time and money.">
</div>

ဒီ pretraining ကို များသောအားဖြင့် များပြားလှတဲ့ ဒေတာတွေပေါ်မှာ လုပ်ဆောင်ပါတယ်။ ဒါကြောင့် ကြီးမားတဲ့ data corpus လိုအပ်ပြီး training ဟာ ရက်သတ္တပတ်ပေါင်းများစွာ ကြာမြင့်နိုင်ပါတယ်။

*Fine-tuning* ကတော့ မော်ဒယ်တစ်ခုကို pretrained လုပ်ပြီး **နောက်**မှာ လုပ်ဆောင်တဲ့ training ဖြစ်ပါတယ်။ fine-tuning လုပ်ဖို့အတွက် သင်ဟာ pretrained language model တစ်ခုကို အရင်ရယူပြီးမှ သင်ရဲ့လုပ်ငန်းတာဝန်အတွက် သီးသန့် dataset နဲ့ ထပ်မံ training လုပ်ရပါတယ်။ ဘာလို့ ကျွန်တော်တို့ရဲ့ နောက်ဆုံးအသုံးပြုမှုအတွက် မော်ဒယ်ကို အစကနေ (**scratch**) လုံးဝ မလေ့ကျင့်တာလဲ။ အကြောင်းရင်းအချို့ ရှိပါတယ်။

*   Pretrained မော်ဒယ်ကို fine-tuning dataset နဲ့ ဆင်တူတဲ့ dataset တစ်ခုပေါ်မှာ လေ့ကျင့်ထားပြီးသား ဖြစ်ပါတယ်။ ဒါကြောင့် fine-tuning လုပ်ငန်းစဉ်ဟာ မူလမော်ဒယ်က pretraining လုပ်စဉ် ရရှိခဲ့တဲ့ အသိပညာ (ဥပမာ- NLP ပြဿနာများအတွက် pretrained မော်ဒယ်ဟာ သင်အသုံးပြုမယ့် ဘာသာစကားရဲ့ စာရင်းအင်းဆိုင်ရာ နားလည်မှု အချို့ကို ရရှိထားမှာပါ) ကို အသုံးချနိုင်ပါတယ်။
*   Pretrained မော်ဒယ်ကို ဒေတာများစွာပေါ်မှာ လေ့ကျင့်ထားပြီးဖြစ်တာကြောင့် fine-tuning လုပ်ဖို့အတွက် သင့်တင့်တဲ့ ရလဒ်တွေရဖို့ ဒေတာပမာဏ အများကြီး လျော့နည်းစွာ လိုအပ်ပါတယ်။
*   အလားတူပဲ ကောင်းမွန်တဲ့ ရလဒ်တွေရဖို့အတွက် လိုအပ်တဲ့ အချိန်နဲ့ အရင်းအမြစ် ပမာဏဟာ အများကြီး လျော့နည်းပါတယ်။

ဥပမာအားဖြင့် English ဘာသာစကားပေါ်မှာ လေ့ကျင့်ထားတဲ့ pretrained model တစ်ခုကို အသုံးပြုပြီး arXiv corpus ပေါ်မှာ fine-tune လုပ်ခြင်းဖြင့် သိပ္ပံ/သုတေသနအခြေခံ မော်ဒယ်တစ်ခုကို ရရှိနိုင်ပါတယ်။ fine-tuning လုပ်ရာမှာ ဒေတာအနည်းငယ်သာ လိုအပ်ပါလိမ့်မယ်။ pretrained model ရရှိထားတဲ့ အသိပညာကို "လွှဲပြောင်းပေးခြင်း" (transferred) ဖြစ်တာကြောင့် *transfer learning* လို့ ခေါ်ဆိုရခြင်း ဖြစ်ပါတယ်။

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/finetuning.svg" alt="The fine-tuning of a language model is cheaper than pretraining in both time and money.">
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/finetuning-dark.svg" alt="The fine-tuning of a language model is cheaper than pretraining in both time and money.">
</div>

ဒါကြောင့် မော်ဒယ်တစ်ခုကို fine-tuning လုပ်ခြင်းက အချိန်၊ ဒေတာ၊ ငွေကြေးနဲ့ သဘာဝပတ်ဝန်းကျင်ဆိုင်ရာ ကုန်ကျစရိတ်တွေကို လျှော့ချပေးပါတယ်။ training လုပ်တာဟာ pretraining အပြည့်အစုံထက် ကန့်သတ်ချက်နည်းတာကြောင့် မတူညီတဲ့ fine-tuning ပုံစံတွေကို ထပ်ခါတလဲလဲ ပြုလုပ်ဖို့ ပိုမြန်ဆန်ပြီး ပိုလွယ်ကူပါတယ်။

ဒီလုပ်ငန်းစဉ်ဟာ အစကနေ လေ့ကျင့်တာထက် ပိုမိုကောင်းမွန်တဲ့ ရလဒ်တွေ ရရှိစေပါလိမ့်မယ် (သင့်မှာ ဒေတာအများကြီးမရှိဘူးဆိုရင်)။ ဒါကြောင့် သင်ဟာ သင်လုပ်ဆောင်မယ့် လုပ်ငန်းနဲ့ အနီးစပ်ဆုံးဖြစ်တဲ့ pretrained model တစ်ခုကို အမြဲတမ်း အသုံးပြုပြီး fine-tune လုပ်သင့်ပါတယ်။

## ယေဘုယျ Transformer architecture[[general-transformer-architecture]]

ဒီအပိုင်းမှာတော့ Transformer မော်ဒယ်ရဲ့ ယေဘုယျ architecture ကို ခြုံငုံသုံးသပ်သွားပါမယ်။ အချို့အယူအဆတွေကို နားမလည်ရင် စိတ်မပူပါနဲ့။ အစိတ်အပိုင်းတစ်ခုချင်းစီကို အသေးစိတ် ဖော်ပြထားတဲ့ အပိုင်းတွေ နောက်ပိုင်းမှာ ရှိပါသေးတယ်။

<Youtube id="H39Z_720T5s" />

မော်ဒယ်ဟာ အဓိကအားဖြင့် အပိုင်းနှစ်ပိုင်းနဲ့ ဖွဲ့စည်းထားပါတယ်။

* **Encoder (ဘယ်ဘက်)**: Encoder က input ကို လက်ခံပြီး ၎င်းရဲ့ ကိုယ်စားပြုမှု (features) ကို တည်ဆောက်ပါတယ်။ ဒါကတော့ မော်ဒယ်ဟာ input ကနေ နားလည်နိုင်စွမ်းကို ရယူဖို့ အကောင်းဆုံးဖြစ်အောင် ပြင်ဆင်ထားတယ်လို့ ဆိုလိုပါတယ်။
* **Decoder (ညာဘက်)**: Decoder က encoder ရဲ့ ကိုယ်စားပြုမှု (features) ကို အခြား inputs တွေနဲ့အတူ အသုံးပြုပြီး target sequence တစ်ခုကို ဖန်တီးပေးပါတယ်။ ဒါကတော့ မော်ဒယ်ဟာ outputs တွေကို ဖန်တီးဖို့ အကောင်းဆုံးဖြစ်အောင် ပြင်ဆင်ထားတယ်လို့ ဆိုလိုပါတယ်။

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/transformers_blocks.svg" alt="Architecture of a Transformers models">
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/transformers_blocks-dark.svg" alt="Architecture of a Transformers models">
</div>

ဒီအပိုင်းတစ်ခုချင်းစီကို လုပ်ငန်းတာဝန်ပေါ်မူတည်ပြီး သီးခြားစီ အသုံးပြုနိုင်ပါတယ်။

*   **Encoder-only models**: စာကြောင်းခွဲခြားသတ်မှတ်ခြင်း (sentence classification) နဲ့ သီးခြားအမည် ဖော်ထုတ်ခြင်း (named entity recognition) လို input ကို နားလည်ဖို့ လိုအပ်တဲ့ လုပ်ငန်းတွေအတွက် ကောင်းပါတယ်။
*   **Decoder-only models**: စာသားထုတ်လုပ်ခြင်း (text generation) လို ဖန်တီးမှုဆိုင်ရာ လုပ်ငန်းတွေအတွက် ကောင်းပါတယ်။
*   **Encoder-decoder models** သို့မဟုတ် **sequence-to-sequence models**: ဘာသာပြန်ခြင်း ဒါမှမဟုတ် အကျဉ်းချုပ်ခြင်း လို input လိုအပ်တဲ့ ဖန်တီးမှုဆိုင်ရာ လုပ်ငန်းတွေအတွက် ကောင်းပါတယ်။

ဒီ architecture တွေကို နောက်ပိုင်းအပိုင်းတွေမှာ သီးခြားစီ နက်နက်နဲနဲ လေ့လာသွားမှာ ဖြစ်ပါတယ်။

## Attention layers[[attention-layers]]

Transformer မော်ဒယ်တွေရဲ့ အဓိကအင်္ဂါရပ်တစ်ခုကတော့ ၎င်းတို့ကို *attention layers* လို့ခေါ်တဲ့ အထူး layers တွေနဲ့ တည်ဆောက်ထားခြင်း ဖြစ်ပါတယ်။ တကယ်တော့ Transformer architecture ကို မိတ်ဆက်တဲ့ စာတမ်းရဲ့ ခေါင်းစဉ်က ["Attention Is All You Need"](https://arxiv.org/abs/1706.03762) ပါပဲ။ attention layers တွေရဲ့ အသေးစိတ်အချက်အလက်တွေကို သင်တန်းရဲ့ နောက်ပိုင်းမှာ လေ့လာသွားပါမယ်။ အခုအတွက်တော့ ဒီ layer က မော်ဒယ်ကို သင်ပေးပို့လိုက်တဲ့ စာကြောင်းထဲက တချို့စကားလုံးတွေကို သီးခြားအာရုံစိုက်ဖို့ (ကျန်တာတွေကိုတော့ လျစ်လျူရှုဖို့) စကားလုံးတစ်ခုစီရဲ့ ကိုယ်စားပြုမှု (representation) ကို လုပ်ဆောင်နေစဉ်မှာ ပြောပြပေးတယ်ဆိုတာကိုပဲ သိထားဖို့ လိုပါတယ်။

ဒီအကြောင်းအရာကို နားလည်လွယ်အောင် ဥပမာတစ်ခုနဲ့ ပြောရရင် အင်္ဂလိပ်ဘာသာစကားကနေ ပြင်သစ်ဘာသာစကားကို ဘာသာပြန်ခြင်း လုပ်ငန်းကို စဉ်းစားကြည့်ပါ။ "You like this course" ဆိုတဲ့ input ကို ပေးတဲ့အခါ ဘာသာပြန်မော်ဒယ်က "like" ဆိုတဲ့ စကားလုံးအတွက် မှန်ကန်တဲ့ ဘာသာပြန်ကို ရရှိဖို့အတွက် ဘေးကပ်လျက်ရှိတဲ့ "You" ဆိုတဲ့ စကားလုံးကိုလည်း အာရုံစိုက်ဖို့ လိုပါတယ်။ ဘာလို့လဲဆိုတော့ ပြင်သစ်ဘာသာစကားမှာ "like" ဆိုတဲ့ ကြိယာကို subject ပေါ်မူတည်ပြီး ကွဲပြားစွာ တွဲစပ်ရလို့ပါ။ ဒါပေမယ့် စာကြောင်းရဲ့ ကျန်တဲ့အပိုင်းတွေကတော့ အဲဒီစကားလုံးရဲ့ ဘာသာပြန်ဖို့အတွက် အသုံးမဝင်ပါဘူး။ အလားတူပဲ "this" ကို ဘာသာပြန်တဲ့အခါ မော်ဒယ်က "course" ဆိုတဲ့ စကားလုံးကိုပါ အာရုံစိုက်ဖို့ လိုပါလိမ့်မယ်။ ဘာလို့လဲဆိုတော့ "this" က သက်ဆိုင်ရာနာမ်က ပုလ္လင် (masculine) လား၊ ဣတ္ထိလင် (feminine) လားဆိုတာပေါ်မူတည်ပြီး ကွဲပြားစွာ ဘာသာပြန်လို့ပါ။ ဒီမှာလည်း စာကြောင်းထဲက အခြားစကားလုံးတွေက "course" ကို ဘာသာပြန်ဖို့အတွက် အရေးမကြီးပါဘူး။ ပိုမိုရှုပ်ထွေးတဲ့ စာကြောင်းတွေ (နဲ့ ပိုမိုရှုပ်ထွေးတဲ့ သဒ္ဒါစည်းမျဉ်းတွေ) နဲ့ဆိုရင် မော်ဒယ်က စာကြောင်းထဲမှာ ဝေးကွာနေတဲ့ စကားလုံးတွေကိုပါ သီးခြားအာရုံစိုက်ဖို့ လိုအပ်ပါလိမ့်မယ်။

ဒီလို အယူအဆမျိုးက သဘာဝဘာသာစကားနဲ့ သက်ဆိုင်တဲ့ လုပ်ငန်းတာဝန်တွေ အားလုံးမှာ အကျုံးဝင်ပါတယ်။ စကားလုံးတစ်ခုတည်းက သူ့ဘာသာသူ အဓိပ္ပာယ်ရှိပေမယ့်၊ အဲဒီအဓိပ္ပာယ်ဟာ context ကြောင့် နက်နက်နဲနဲ သက်ရောက်မှုရှိပါတယ်။ အဲဒီ context ဟာ လေ့လာနေတဲ့ စကားလုံးရဲ့ အရင် ဒါမှမဟုတ် နောက်ကပ်လျက်ရှိတဲ့ အခြားစကားလုံး (သို့မဟုတ် စကားလုံးများ) ဖြစ်နိုင်ပါတယ်။

Attention layers တွေ ဘာအကြောင်းလဲဆိုတာကို နားလည်ပြီးပြီဆိုတော့ Transformer architecture ကို ပိုမိုနီးကပ်စွာ လေ့လာကြည့်ရအောင်။

## မူလ architecture[[the-original-architecture]]

Transformer architecture ကို မူလက ဘာသာပြန်ခြင်းအတွက် ဒီဇိုင်းထုတ်ခဲ့တာပါ။ training လုပ်နေစဉ်အတွင်း encoder က သတ်မှတ်ထားတဲ့ ဘာသာစကားတစ်ခုနဲ့ input တွေ (စာကြောင်းတွေ) ကို လက်ခံရရှိပြီး၊ decoder ကတော့ တူညီတဲ့ စာကြောင်းတွေကို လိုချင်တဲ့ target language နဲ့ လက်ခံရရှိပါတယ်။ encoder မှာ attention layers တွေက စာကြောင်းတစ်ကြောင်းလုံးရှိ စကားလုံးအားလုံးကို အသုံးပြုနိုင်ပါတယ်။ (ဘာလို့လဲဆိုတော့ ခုဏက မြင်ခဲ့ရတဲ့အတိုင်း စကားလုံးတစ်ခုရဲ့ ဘာသာပြန်ခြင်းက စာကြောင်းထဲမှာ အဲဒီစကားလုံးရဲ့ နောက်က ဒါမှမဟုတ် အရင်က ရှိနေတဲ့အရာတွေပေါ် မူတည်နိုင်လို့ပါ)။ ဒါပေမယ့် decoder ကတော့ တစ်ခုချင်းစီ အစဉ်လိုက် အလုပ်လုပ်ပြီး သူ ဘာသာပြန်ပြီးသား စာကြောင်းထဲက စကားလုံးတွေကိုပဲ အာရုံစိုက်နိုင်ပါတယ်။ (ဒါကြောင့် လက်ရှိ ထုတ်လုပ်နေတဲ့ စကားလုံးရဲ့ အရင်က စကားလုံးတွေကိုသာ)။ ဥပမာအားဖြင့် ဘာသာပြန်ထားတဲ့ target ရဲ့ ပထမစကားလုံး သုံးလုံးကို ခန့်မှန်းပြီးတဲ့အခါ ၎င်းတို့ကို decoder ကို ပေးလိုက်ပါတယ်။ ထို့နောက် decoder က encoder ရဲ့ input တွေအားလုံးကို အသုံးပြုပြီး စတုတ္ထစကားလုံးကို ခန့်မှန်းဖို့ ကြိုးစားပါတယ်။

Training လုပ်နေစဉ်အတွင်း (မော်ဒယ်က target sentences တွေကို ဝင်ရောက်ကြည့်ရှုနိုင်တဲ့အခါ) အရှိန်မြှင့်ဖို့အတွက် decoder ကို target အပြည့်အစုံကို ထည့်ပေးပါတယ်။ ဒါပေမယ့် အနာဂတ်စကားလုံးတွေကို အသုံးပြုခွင့် မပြုပါဘူး။ (အကယ်၍ သူက position 2 မှာရှိတဲ့ စကားလုံးကို ခန့်မှန်းဖို့ ကြိုးစားနေစဉ် position 2 မှာရှိတဲ့ စကားလုံးကို ဝင်ရောက်ကြည့်ရှုခွင့်ရရင် ပြဿနာက သိပ်မခက်ခဲတော့ပါဘူး!)။ ဥပမာအားဖြင့် စတုတ္ထစကားလုံးကို ခန့်မှန်းဖို့ ကြိုးစားနေစဉ်မှာ attention layer က position 1 မှ 3 အထိရှိတဲ့ စကားလုံးတွေကိုပဲ ဝင်ရောက်ကြည့်ရှုနိုင်ပါလိမ့်မယ်။

မူလ Transformer architecture က ဒီလိုပုံစံဖြစ်ပြီး ဘယ်ဘက်မှာ encoder နဲ့ ညာဘက်မှာ decoder ပါဝင်ပါတယ်။

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/transformers.svg" alt="Architecture of a Transformers models">
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter1/transformers-dark.svg" alt="Architecture of a Transformers models">
</div>

decoder block မှာရှိတဲ့ ပထမ attention layer က decoder ရဲ့ အတိတ် inputs အားလုံးကို အာရုံစိုက်ပေမယ့် ဒုတိယ attention layer က encoder ရဲ့ output ကို အသုံးပြုတယ်ဆိုတာ သတိပြုပါ။ ဒါကြောင့် လက်ရှိစကားလုံးကို အကောင်းဆုံး ခန့်မှန်းနိုင်ဖို့ input စာကြောင်းတစ်ခုလုံးကို ဝင်ရောက်ကြည့်ရှုနိုင်ပါတယ်။ ဒါက အရမ်းအသုံးဝင်ပါတယ်။ ဘာလို့လဲဆိုတော့ မတူညီတဲ့ ဘာသာစကားတွေမှာ စကားလုံးတွေကို မတူညီတဲ့ အစီအစဉ်တွေနဲ့ ချထားတဲ့ သဒ္ဒါစည်းမျဉ်းတွေ ရှိနိုင်တာကြောင့် ဒါမှမဟုတ် စာကြောင်းထဲမှာ နောက်ပိုင်းမှာ ပေးထားတဲ့ context အချို့က ပေးထားတဲ့ စကားလုံးရဲ့ အကောင်းဆုံးဘာသာပြန်ကို ဆုံးဖြတ်ရာမှာ အထောက်အကူဖြစ်နိုင်လို့ပါ။

*Attention mask* ကို encoder/decoder မှာလည်း အသုံးပြုနိုင်ပြီး မော်ဒယ်က အချို့အထူးစကားလုံးတွေကို အာရုံစိုက်ခြင်းမှ ကာကွယ်ပေးပါတယ်။ ဥပမာအားဖြင့် စာကြောင်းတွေကို စုပေါင်းတဲ့အခါ input အားလုံးကို အလျားတူအောင် ပြုလုပ်ဖို့ အသုံးပြုတဲ့ အထူး padding word စတာတွေပါ။

##  Architectures vs. checkpoints[[architecture-vs-checkpoints]]

ဒီသင်တန်းမှာ Transformer မော်ဒယ်တွေထဲကို နက်နက်နဲနဲ လေ့လာတဲ့အခါ *architectures* နဲ့ *checkpoints* အပြင် *models* ဆိုတဲ့ အသုံးအနှုန်းတွေကိုလည်း တွေ့ရပါလိမ့်မယ်။ ဒီအသုံးအနှုန်းတွေ အားလုံးမှာ အဓိပ္ပာယ်အနည်းငယ် ကွဲပြားပါတယ်။

*   **Architecture**: ဒါကတော့ မော်ဒယ်ရဲ့ ပုံစံတည်ဆောက်ပုံ (skeleton) ဖြစ်ပါတယ်။ မော်ဒယ်အတွင်းမှာ ဖြစ်ပျက်နေတဲ့ layer တစ်ခုစီနဲ့ လုပ်ဆောင်မှုတစ်ခုစီရဲ့ အဓိပ္ပာယ်ဖွင့်ဆိုချက်ပါ။
*   **Checkpoints**: ဒါတွေကတော့ ပေးထားတဲ့ architecture မှာ load လုပ်မယ့် weights တွေ ဖြစ်ပါတယ်။
*   **Model**: ဒါကတော့ "architecture" သို့မဟုတ် "checkpoint" လို တိကျတဲ့ အဓိပ္ပာယ်မရှိဘဲ နှစ်ခုစလုံးကို ဆိုလိုနိုင်တဲ့ ယေဘုယျအသုံးအနှုန်းပါ။ ဒီသင်တန်းကတော့ မရေရာမှုတွေကို လျှော့ချဖို့အတွက် အရေးကြီးတဲ့အခါ *architecture* ဒါမှမဟုတ် *checkpoint* လို့ သတ်သတ်မှတ်မှတ် ဖော်ပြပေးပါလိမ့်မယ်။

ဥပမာအားဖြင့် BERT က architecture တစ်ခုဖြစ်ပြီး `bert-base-cased` ကတော့ Google အဖွဲ့က BERT ရဲ့ ပထမဆုံးထုတ်ဝေမှုအတွက် လေ့ကျင့်ပေးထားတဲ့ weights အစုအဝေးဖြစ်တာကြောင့် checkpoint တစ်ခု ဖြစ်ပါတယ်။ ဒါပေမယ့် လူတစ်ဦးက "the BERT model" နဲ့ "the `bert-base-cased` model" လို့ နှစ်မျိုးစလုံး ပြောဆိုနိုင်ပါတယ်။

## ဝေါဟာရ ရှင်းလင်းချက် (Glossary)

*   **Transformer Models**: Natural Language Processing (NLP) မှာ အောင်မြင်မှုများစွာရရှိခဲ့တဲ့ deep learning architecture တစ်မျိုးပါ။ ၎င်းတို့ဟာ စာသားတွေထဲက စကားလုံးတွေရဲ့ ဆက်နွယ်မှုတွေကို "attention mechanism" သုံးပြီး နားလည်အောင် သင်ကြားပေးပါတယ်။
*   **Attention**: Transformer model များတွင် အသုံးပြုသော ယန္တရားတစ်ခုဖြစ်ပြီး input sequence အတွင်းရှိ အရေးကြီးသော အစိတ်အပိုင်းများကို မော်ဒယ်အား ပိုမိုအာရုံစိုက်စေသည်။
*   **Encoder-Decoder Architecture**: Encoder နှင့် Decoder နှစ်ခုစလုံး ပါဝင်သော Transformer architecture တစ်မျိုးဖြစ်ပြီး ဘာသာပြန်ခြင်းကဲ့သို့သော input sequence မှ output sequence တစ်ခုသို့ ပြောင်းလဲခြင်း လုပ်ငန်းများအတွက် အသုံးပြုပါတယ်။
*   **Architecture**: Machine Learning မော်ဒယ်တစ်ခု၏ အတွင်းပိုင်းတည်ဆောက်ပုံ၊ အလွှာများ (layers) နှင့် လုပ်ဆောင်မှုများ (operations) ၏ အဓိပ္ပာယ်ဖွင့်ဆိုချက်။
*   **GPT (Generative Pre-trained Transformer)**: OpenAI မှ တီထွင်ထားသော Transformer-based Large Language Model (LLM) အမျိုးအစားတစ်ခု။
*   **Pretrained Model**: ဒေတာအမြောက်အမြားပေါ်တွင် ကြိုတင်လေ့ကျင့်ထားသော မော်ဒယ်။
*   **Fine-tuning**: ကြိုတင်လေ့ကျင့်ထားပြီးသား (pre-trained) မော်ဒယ်တစ်ခုကို သီးခြားလုပ်ငန်းတစ်ခု (specific task) အတွက် အနည်းငယ်သော ဒေတာနဲ့ ထပ်မံလေ့ကျင့်ပေးခြင်းကို ဆိုလိုပါတယ်။
*   **NLP (Natural Language Processing)**: ကွန်ပျူတာတွေ လူသားဘာသာစကားကို နားလည်၊ အဓိပ္ပာယ်ဖော်ပြီး၊ ဖန်တီးနိုင်အောင် လုပ်ဆောင်ပေးတဲ့ Artificial Intelligence (AI) ရဲ့ နယ်ပယ်ခွဲတစ်ခု ဖြစ်ပါတယ်။
*   **BERT (Bidirectional Encoder Representations from Transformers)**: Google က ထုတ်လုပ်ထားတဲ့ Transformer-based Pretrained Model တစ်ခုဖြစ်ပြီး စာသားတွေရဲ့ အဓိပ္ပာယ်ကို နားလည်ဖို့အတွက် အသုံးပြုပါတယ်။
*   **GPT-2**: GPT ရဲ့ ပိုမိုကောင်းမွန်ပြီး ပိုကြီးတဲ့ ဗားရှင်း။
*   **Ethical Concerns**: ကျင့်ဝတ်ဆိုင်ရာ စိုးရိမ်ပူပန်မှုများ။
*   **T5 (Text-to-Text Transfer Transformer)**: Google က ထုတ်လုပ်ထားတဲ့ Transformer-based Model တစ်ခုဖြစ်ပြီး NLP လုပ်ငန်းတာဝန်များစွာကို text-to-text format ဖြင့် ဖြေရှင်းရန် ဒီဇိုင်းထုတ်ထားပါတယ်။
*   **Sequence-to-sequence**: input sequence တစ်ခုကို output sequence တစ်ခုအဖြစ် ပြောင်းလဲပေးသော မော်ဒယ်အမျိုးအစား။ (ဥပမာ- ဘာသာပြန်ခြင်း)
*   **GPT-3**: GPT-2 ထက် ပိုမိုကြီးမားသော ဗားရှင်း။
*   **Zero-shot learning**: မော်ဒယ်တစ်ခုကို သီးခြားလုပ်ငန်းတစ်ခုအတွက် လေ့ကျင့်မှုမရှိဘဲ လုပ်ငန်းကို လုပ်ဆောင်စေခြင်း။
*   **InstructGPT**: ညွှန်ကြားချက်များကို ပိုမိုကောင်းမွန်စွာ လိုက်နာနိုင်ရန် လေ့ကျင့်ထားသော GPT-3 ၏ ဗားရှင်းတစ်ခု။
*   **Llama**: Meta မှ တီထွင်ထားသော Transformer-based Large Language Model (LLM) အမျိုးအစားတစ်ခု။
*   **Mistral**: ၇ ဘီလီယံ parameter ပါရှိသော Large Language Model (LLM) တစ်ခု။
*   **Grouped-query attention**: Transformer model များတွင် အသုံးပြုသော attention mechanism တစ်မျိုးဖြစ်ပြီး inference ကို ပိုမိုမြန်ဆန်စေရန် ကူညီပေးသည်။
*   **Inference**: လေ့ကျင့်ပြီးသား မော်ဒယ်တစ်ခုကို အသုံးပြု၍ input အသစ်များမှ ခန့်မှန်းချက်များ သို့မဟုတ် output များထုတ်လုပ်ခြင်း။
*   **Sliding window attention**: Transformer model များတွင် အသုံးပြုသော attention mechanism တစ်မျိုးဖြစ်ပြီး ရှည်လျားသော sequences များကို ထိထိရောက်ရောက် ကိုင်တွယ်နိုင်စေသည်။
*   **Gemma 2**: Google DeepMind မှ ထုတ်လုပ်သော lightweight, state-of-the-art open models မိသားစုတစ်ခု။
*   **Interleaved local-global attentions**: Transformer model များတွင် အသုံးပြုသော attention mechanism တစ်မျိုးဖြစ်ပြီး local နှင့် global information နှစ်ခုလုံးကို အာရုံစိုက်နိုင်စေသည်။
*   **Knowledge distillation**: ပိုမိုကြီးမားသော၊ ပိုမိုရှုပ်ထွေးသော မော်ဒယ် (teacher model) ၏ အသိပညာကို ပိုမိုသေးငယ်သော၊ ရိုးရှင်းသော မော်ဒယ် (student model) သို့ လွှဲပြောင်းပေးသည့် နည်းလမ်း။
*   **SmolLM2**: သေးငယ်သော အရွယ်အစားရှိသော်လည်း ထူးခြားသော စွမ်းဆောင်ရည်ကို ရရှိစေသော Small Language Model (SLM) တစ်ခု။
*   **Mobile and Edge Devices**: စမတ်ဖုန်းများ၊ တက်ဘလက်များ၊ IoT ကိရိယာများကဲ့သို့ ကွန်ပျူတာစွမ်းအား ကန့်သတ်ချက်ရှိသော ကိရိယာများ။
*   **Auto-regressive Transformer models**: GPT ကဲ့သို့ မော်ဒယ်များ၊ နောက်ထပ်လာမည့် token ကို ယခင် token များအပေါ် အခြေခံ၍ ခန့်မှန်းသည်။
*   **Auto-encoding Transformer models**: BERT ကဲ့သို့ မော်ဒယ်များ၊ masked token များကို input sequence တစ်ခုလုံးအပေါ် အခြေခံ၍ ခန့်မှန်းသည်။
*   **Sequence-to-sequence Transformer models**: T5 ကဲ့သို့ မော်ဒယ်များ၊ input sequence တစ်ခုကို output sequence တစ်ခုအဖြစ် ပြောင်းလဲပေးသည်။
*   **Language Models**: လူသားဘာသာစကားကို နားလည်ပြီး ဖန်တီးနိုင်အောင် သင်ကြားထားသော မော်ဒယ်များ။
*   **Self-supervised learning**: မော်ဒယ်၏ input တွေကနေ ရည်ရွယ်ချက်ကို အလိုအလျောက် တွက်ချက်ပေးတဲ့ သင်ယူမှုပုံစံတစ်ခု။
*   **Transfer Learning**: ကြိုတင်လေ့ကျင့်ထားသော မော်ဒယ်မှ ရရှိသောအသိပညာကို အခြားဆက်စပ်လုပ်ငန်းတစ်ခုသို့ လွှဲပြောင်းအသုံးပြုခြင်း။
*   **Supervised Learning**: human-annotated labels တွေကို အသုံးပြုပြီး မော်ဒယ်ကို သင်ကြားပေးတဲ့ သင်ယူမှုပုံစံတစ်ခု။
*   **Annotated Labels**: လူသားများက ဒေတာများကို မှတ်သားထားသော အမှတ်အသားများ သို့မဟုတ် အမျိုးအစားများ။
*   **Causal Language Modeling**: input sequence ၏ ယခင် token များကို အခြေခံ၍ နောက်ထပ်လာမည့် token ကို ခန့်မှန်းခြင်း။
*   **Masked Language Modeling**: input sequence ထဲရှိ masked (ဝှက်ထားသော) token များကို ခန့်မှန်းခြင်း။
*   **Outliers**: အခြားသောအချက်အလက်များနှင့် ကွဲပြားစွာ ထူးခြားနေသော အချက်အလက်များ။
*   **DistilBERT**: BERT မော်ဒယ်၏ ပိုမိုသေးငယ်ပြီး ပိုမိုမြန်ဆန်သော ဗားရှင်း။
*   **Hyperparameters**: Machine Learning မော်ဒယ်တစ်ခုကို လေ့ကျင့်ရာတွင် သတ်မှတ်ထားသော parameter များ (ဥပမာ- learning rate, batch size)။
*   **Carbon Footprint**: ကာဗွန်ဒိုင်အောက်ဆိုဒ် ထုတ်လွှတ်မှုပမာဏ။
*   **Pretraining**: မော်ဒယ်တစ်ခုကို အစကနေ လေ့ကျင့်ခြင်း။
*   **Weights**: Machine Learning မော်ဒယ်တစ်ခု၏ သင်ယူနိုင်သော အစိတ်အပိုင်းများ။
*   **Randomly Initialized**: မော်ဒယ်၏ weights များကို ကျပန်းတန်ဖိုးများဖြင့် စတင်သတ်မှတ်ခြင်း။
*   **Corpus**: စာသားများစွာ၏ စုဆောင်းမှု (Collection of text data)။
*   **arXiv corpus**: သိပ္ပံနည်းကျ စာတမ်းများ၊ သုတေသနစာတမ်းများ စသည်တို့၏ စုဆောင်းမှု။
*   **Encoder**: Transformer Architecture ရဲ့ အစိတ်အပိုင်းတစ်ခုဖြစ်ပြီး input data (ဥပမာ- စာသား) ကို နားလည်ပြီး ကိုယ်စားပြုတဲ့ အချက်အလက် (representation) အဖြစ် ပြောင်းလဲပေးပါတယ်။
*   **Decoder**: Transformer Architecture ရဲ့ အစိတ်အပိုင်းတစ်ခုဖြစ်ပြီး encoder ကနေ ရရှိတဲ့ အချက်အလက် (representation) ကို အသုံးပြုပြီး output data (ဥပမာ- ဘာသာပြန်ထားတဲ့ စာသား) ကို ထုတ်ပေးပါတယ်။
*   **Features**: ဒေတာတစ်ခု၏ ထူးခြားသော လက္ခဏာများ သို့မဟုတ် ဂုဏ်သတ္တိများ။
*   **Sentence Classification**: စာကြောင်းတစ်ခုလုံးကို ကြိုတင်သတ်မှတ်ထားသော အမျိုးအစားများထဲသို့ ခွဲခြားသတ်မှတ်ခြင်း။
*   **Named Entity Recognition (NER)**: စာသားထဲက လူအမည်၊ နေရာအမည်၊ အဖွဲ့အစည်းအမည် စတဲ့ သီးခြားအမည်တွေကို ရှာဖွေဖော်ထုတ်ခြင်း။
*   **Text Generation**: AI မော်ဒယ်များကို အသုံးပြု၍ လူသားကဲ့သို့သော စာသားအသစ်များ ဖန်တီးခြင်း။
*   **Translation**: ဘာသာစကားတစ်ခုကနေ အခြားဘာသာစကားတစ်ခုကို စာသားတွေ ဒါမှမဟုတ် စကားပြောတွေကို အလိုအလျောက် ဘာသာပြန်ဆိုခြင်း။
*   **Summarization**: စာသားတစ်ခုကို အဓိကအချက်အလက်များသာ ပါဝင်သော အကျဉ်းချုပ်အဖြစ် ပြောင်းလဲခြင်း။
*   **Attention Layers**: Transformer model များတွင် input data ၏ မတူညီသော အစိတ်အပိုင်းများအပေါ် အာရုံစိုက်နိုင်ရန် ကူညီပေးသော အလွှာများ။
*   **Attention Mechanism**: Transformer model များတွင် input sequence အတွင်းရှိ မတူညီသော စကားလုံးများ၏ ဆက်နွယ်မှုကို နားလည်ရန် ကူညီပေးသော ယန္တရား။
*   **Conjugated**: ကြိယာတစ်ခု၏ ပုံစံသည် subject သို့မဟုတ် tense ပေါ်မူတည်၍ ပြောင်းလဲခြင်း။
*   **Masculine/Feminine**: ဘာသာစကားအချို့တွင် နာမ်များကို ခွဲခြားထားသော ကျား/မ လိင်ခွဲခြားမှု။
*   **Context**: စကားလုံး၊ စာကြောင်း သို့မဟုတ် အကြောင်းအရာတစ်ခုရဲ့ အဓိပ္ပာယ်ကို နားလည်စေရန် ကူညီပေးသော ပတ်ဝန်းကျင်ရှိ အချက်အလက်များ။
*   **Target Language**: ဘာသာပြန်လိုသော ဘာသာစကား။
*   **Sequentially**: တစ်ခုပြီးတစ်ခု အစီအစဉ်အတိုင်း လုပ်ဆောင်ခြင်း။
*   **Attention Mask**: မော်ဒယ်ကို အချို့သော input token များအပေါ် အာရုံစိုက်ခြင်းမှ တားဆီးရန် အသုံးပြုသော mask (အမှတ်အသား)။
*   **Padding Word**: input sequence များ၏ အလျားကို တူညီစေရန်အတွက် ထပ်ပေါင်းထည့်သော အထူးစကားလုံး။
*   **Batching**: မော်ဒယ်ကို တစ်ကြိမ်တည်း လေ့ကျင့်ရန် သို့မဟုတ် inference လုပ်ရန်အတွက် ဒေတာနမူနာများစွာကို အစုလိုက် စုစည်းခြင်း။
*   **Checkpoint**: သတ်မှတ်ထားသော architecture အတွက် လေ့ကျင့်ပြီးသား weights များ။