# LLMs များဖြင့် စာသားထုတ်လုပ်မှု မှန်းဆတွက်ချက်ခြင်း (Text Generation Inference) ကို နက်ရှိုင်းစွာ လေ့လာခြင်း[[inference-with-llms]]

<CourseFloatingBanner
    chapter={1}
    classNames="absolute z-10 right-0 top-0"
/>

<Youtube id="Xp2w1_LKZN4" />

ခုထိ ကျွန်တော်တို့ဟာ text classification ဒါမှမဟုတ် summarization လိုမျိုး သီးခြားလုပ်ငန်းဆောင်တာအမျိုးမျိုးနဲ့ ပတ်သက်ပြီး Transformer architecture ကို လေ့လာခဲ့ပြီးပါပြီ။ ဒါပေမယ့် Large Language Models တွေကို စာသားထုတ်လုပ်ဖို့ အများဆုံးအသုံးပြုကြပြီး၊ ဒီအခန်းမှာ ဒါကိုပဲ ကျွန်တော်တို့ လေ့လာသွားမှာပါ။

ဒီစာမျက်နှာမှာ LLM inference ရဲ့ အဓိကသဘောတရားတွေကို ကျွန်တော်တို့ လေ့လာသွားမှာဖြစ်ပြီး၊ ဒီမော်ဒယ်တွေက စာသားတွေကို ဘယ်လိုထုတ်လုပ်တယ်၊ inference လုပ်ငန်းစဉ်မှာ ဘယ်လိုအဓိက အစိတ်အပိုင်းတွေ ပါဝင်တယ်ဆိုတာကို ပြည့်စုံစွာ နားလည်အောင် ရှင်းပြပေးပါမယ်။

## အခြေခံသဘောတရားများကို နားလည်ခြင်း[[understanding-the-basics]]

အခြေခံသဘောတရားများနဲ့ စလိုက်ရအောင်။ Inference ဆိုတာ လေ့ကျင့်ပြီးသား LLM တစ်ခုကို ပေးထားတဲ့ input prompt ကနေ လူသားဆန်တဲ့ စာသားတွေ ထုတ်လုပ်ဖို့ အသုံးပြုတဲ့ လုပ်ငန်းစဉ် ဖြစ်ပါတယ်။ ဘာသာစကားမော်ဒယ်တွေဟာ လေ့ကျင့်မှုကနေ ရရှိထားတဲ့ အသိပညာတွေကို အသုံးပြုပြီး တစ်ကြိမ်ကို စကားလုံးတစ်လုံးစီ စဉ်းစားကာ အဖြေတွေ ထုတ်ပေးပါတယ်။ မော်ဒယ်က parameters ဘီလီယံပေါင်းများစွာကနေ သင်ယူထားတဲ့ ဖြစ်နိုင်ခြေတွေကို အသုံးပြုပြီး sequence တစ်ခုရဲ့ နောက်ထပ် token ကို ခန့်မှန်းပြီး ထုတ်လုပ်ပေးပါတယ်။ ဒီလို အစဉ်လိုက် ထုတ်လုပ်ခြင်းက LLMs တွေကို ဆက်စပ်မှုရှိပြီး အကြောင်းအရာနဲ့ ကိုက်ညီတဲ့ စာသားတွေကို ထုတ်လုပ်နိုင်စေတာ ဖြစ်ပါတယ်။

## Attention ရဲ့ အခန်းကဏ္ဍ[[the-role-of-attention]]

Attention mechanism ဟာ LLMs တွေကို အကြောင်းအရာ (context) ကို နားလည်ပြီး ဆက်စပ်မှုရှိတဲ့ အဖြေတွေကို ထုတ်ပေးနိုင်စေတဲ့ အရာဖြစ်ပါတယ်။ နောက်ထပ်စကားလုံးကို ခန့်မှန်းတဲ့အခါ စာကြောင်းတစ်ကြောင်းထဲက စကားလုံးတိုင်းက အရေးပါမှု တူညီတာ မဟုတ်ပါဘူး။ ဥပမာ - "The capital of France is ..." ဆိုတဲ့ စာကြောင်းမှာ "France" နဲ့ "capital" ဆိုတဲ့ စကားလုံးတွေက နောက်ထပ် "Paris" ဆိုတဲ့ စကားလုံးကို ဆုံးဖြတ်ဖို့ အရေးကြီးပါတယ်။ ဒီလို သက်ဆိုင်ရာ အချက်အလက်တွေအပေါ် အာရုံစိုက်နိုင်စွမ်းကို ကျွန်တော်တို့ Attention လို့ ခေါ်ပါတယ်။

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit1/AttentionSceneFinal.gif" alt="Visual Gif of Attention" width="60%">

နောက်ထပ် token ကို ခန့်မှန်းဖို့ အသက်ဆိုင်ဆုံး စကားလုံးတွေကို ဖော်ထုတ်တဲ့ ဒီလုပ်ငန်းစဉ်ဟာ အံ့သြစရာကောင်းလောက်အောင် ထိရောက်မှုရှိတယ်ဆိုတာ သက်သေပြခဲ့ပြီးပါပြီ။ LLMs တွေ လေ့ကျင့်တဲ့ အခြေခံမူ—နောက်ထပ် token ကို ခန့်မှန်းခြင်း—ဟာ BERT နဲ့ GPT-2 ကတည်းက ယေဘုယျအားဖြင့် အတူတူပဲ ရှိခဲ့ပေမယ့်၊ neural network တွေကို ချဲ့ထွင်ရာမှာနဲ့ attention mechanism ကို ပိုမိုရှည်လျားတဲ့ sequence တွေအတွက် ကုန်ကျစရိတ်သက်သာစွာ အလုပ်လုပ်နိုင်အောင် လုပ်ဆောင်ရာမှာ သိသိသာသာ တိုးတက်မှုတွေ ရှိခဲ့ပါတယ်။

> [!TIP]
> အတိုချုပ်ပြောရရင် attention mechanism ဟာ LLMs တွေ ဆက်စပ်မှုရှိပြီး အကြောင်းအရာကို နားလည်တဲ့ စာသားတွေကို ထုတ်လုပ်နိုင်စေဖို့အတွက် အဓိကသော့ချက် ဖြစ်ပါတယ်။ ဒါက ခေတ်မီ LLMs တွေကို ယခင်မျိုးဆက် ဘာသာစကားမော်ဒယ်တွေနဲ့ ကွဲပြားစေပါတယ်။

### Context Length နဲ့ Attention Span[[context-length-and-attention-span]]

Attention ကို နားလည်ပြီးပြီဆိုတော့ LLM တစ်ခုက ဘယ်လောက်အထိ context ကို ကိုင်တွယ်နိုင်မလဲဆိုတာကို ဆက်လေ့လာကြည့်ရအောင်။ ဒါက model ရဲ့ 'attention span' လို့ခေါ်တဲ့ context length နဲ့ သက်ဆိုင်ပါတယ်။

Context length ဆိုတာ LLM တစ်ခုက တစ်ကြိမ်တည်း လုပ်ဆောင်နိုင်တဲ့ အများဆုံး token (စကားလုံး ဒါမှမဟုတ် စကားလုံးရဲ့ အစိတ်အပိုင်း) အရေအတွက်ကို ရည်ညွှန်းပါတယ်။ ဒါကို model ရဲ့ အလုပ်လုပ်တဲ့ မှတ်ဉာဏ် (working memory) ရဲ့ အရွယ်အစားလို့ တွေးကြည့်နိုင်ပါတယ်။

ဒီစွမ်းရည်တွေဟာ လက်တွေ့ကျတဲ့ အချက်အလက်အချို့ကြောင့် ကန့်သတ်ထားပါတယ်-
- Model ရဲ့ architecture နဲ့ အရွယ်အစား
- ရရှိနိုင်တဲ့ ကွန်ပျူတာ အရင်းအမြစ်များ
- input နဲ့ ထုတ်လိုတဲ့ output ရဲ့ ရှုပ်ထွေးမှု

စံပြကမ္ဘာမှာဆိုရင် မော်ဒယ်ကို ကန့်သတ်ချက်မရှိတဲ့ context တွေ ထည့်ပေးနိုင်ပေမယ့်၊ hardware ကန့်သတ်ချက်တွေနဲ့ ကွန်ပျူတာ ကုန်ကျစရိတ်တွေကြောင့် ဒါက လက်တွေ့မကျပါဘူး။ ဒါကြောင့် ကန့်သတ်ချက်နဲ့ ထိရောက်မှုကို မျှတအောင် ထိန်းညှိဖို့အတွက် မတူညီတဲ့ context length တွေနဲ့ မော်ဒယ်တွေကို ဒီဇိုင်းထုတ်ထားတာ ဖြစ်ပါတယ်။

> [!TIP]
> Context length ဆိုတာ မော်ဒယ်က အဖြေတစ်ခုကို ထုတ်လုပ်တဲ့အခါ တစ်ကြိမ်တည်းမှာ ထည့်သွင်းစဉ်းစားနိုင်တဲ့ အများဆုံး token အရေအတွက် ဖြစ်ပါတယ်။

### Prompting ပညာ[[the-art-of-prompting]]

ကျွန်တော်တို့ LLMs တွေကို အချက်အလက်တွေ ပေးပို့တဲ့အခါ၊ LLM ရဲ့ ထုတ်လုပ်မှုကို လိုချင်တဲ့ output ဆီ ဦးတည်နိုင်အောင် input ကို ပုံစံချပါတယ်။ ဒါကို _prompting_ လို့ ခေါ်ပါတယ်။

LLMs တွေက အချက်အလက်တွေကို ဘယ်လိုလုပ်ဆောင်တယ်ဆိုတာ နားလည်ခြင်းက ပိုကောင်းတဲ့ prompts တွေကို ဖန်တီးနိုင်ဖို့ ကူညီပေးပါတယ်။ မော်ဒယ်ရဲ့ အဓိကတာဝန်က input token တစ်ခုစီရဲ့ အရေးပါမှုကို ခွဲခြမ်းစိတ်ဖြာပြီး နောက်ထပ် token ကို ခန့်မှန်းဖို့ဖြစ်တာကြောင့်၊ သင်ရဲ့ input sequence ရဲ့ စကားလုံးဖွဲ့စည်းပုံက အရေးကြီးလာပါတယ်။

> [!TIP]
> Prompt ကို သေချာဒီဇိုင်းထုတ်ခြင်းက **LLM ရဲ့ ထုတ်လုပ်မှုကို လိုချင်တဲ့ output ဆီ ဦးတည်စေရန် ပိုမိုလွယ်ကူစေပါတယ်**။

## နှစ်ဆင့်ပါသော Inference လုပ်ငန်းစဉ်[[the-two-phase-inference-process]]

အခြေခံအစိတ်အပိုင်းတွေကို ကျွန်တော်တို့ နားလည်ပြီးပြီဆိုတော့ LLMs တွေက စာသားတွေကို ဘယ်လိုထုတ်လုပ်တယ်ဆိုတာကို နက်ရှိုင်းစွာ လေ့လာကြည့်ရအောင်။ လုပ်ငန်းစဉ်ကို အဓိက အဆင့်နှစ်ဆင့်ခွဲနိုင်ပါတယ်- prefill နဲ့ decode ပါ။ ဒီအဆင့်တွေက ပူးပေါင်းပြီး အလုပ်လုပ်ကြပြီး၊ စာသားတွေ ဆက်စပ်မှုရှိအောင် ထုတ်လုပ်ရာမှာ အရေးကြီးတဲ့ အခန်းကဏ္ဍတွေကနေ ပါဝင်ပါတယ်။

### Prefill အဆင့်[[the-prefill-phase]]

Prefill အဆင့်ဟာ ချက်ပြုတ်ရာမှာ ပြင်ဆင်မှုအဆင့်နဲ့ တူပါတယ်။ ဒီအဆင့်မှာ ကနဦးပါဝင်ပစ္စည်းအားလုံးကို လုပ်ဆောင်ပြီး အသင့်ပြင်ဆင်ပါတယ်။ ဒီအဆင့်မှာ အဓိကအချက် (၃) ချက် ပါဝင်ပါတယ်-

1.  **Tokenization**: input စာသားကို tokens တွေအဖြစ် ပြောင်းလဲခြင်း (ဒါတွေကို မော်ဒယ်က နားလည်တဲ့ အခြေခံ building blocks တွေလို့ တွေးကြည့်နိုင်ပါတယ်)
2.  **Embedding Conversion**: ဒီ tokens တွေကို ၎င်းတို့ရဲ့ အဓိပ္ပာယ်ကို ဖမ်းယူထားတဲ့ ဂဏန်းဆိုင်ရာ ကိုယ်စားပြုမှု (numerical representations) တွေအဖြစ် ပြောင်းလဲခြင်း
3.  **ကနဦး လုပ်ဆောင်ခြင်း (Initial Processing)**: context ကို ပြည့်ပြည့်စုံစုံ နားလည်မှု ဖန်တီးဖို့အတွက် ဒီ embeddings တွေကို model ရဲ့ neural network တွေကနေတဆင့် လုပ်ဆောင်ခြင်း

ဒီအဆင့်ဟာ input tokens အားလုံးကို တစ်ကြိမ်တည်း လုပ်ဆောင်ဖို့ လိုအပ်တာကြောင့် ကွန်ပျူတာအရင်းအမြစ်များစွာ လိုအပ်ပါတယ်။ ဒါကို အဖြေမရေးခင် စာပိုဒ်တစ်ခုလုံးကို ဖတ်ပြီး နားလည်တာနဲ့ တူတယ်လို့ တွေးကြည့်နိုင်ပါတယ်။

အောက်က interactive playground မှာ မတူညီတဲ့ tokenizers တွေနဲ့ စမ်းသပ်ကြည့်နိုင်ပါတယ်-

<iframe
	src="https://agents-course-the-tokenizer-playground.static.hf.space"
	frameborder="0"
	width="850"
	height="450"
></iframe>

### Decode အဆင့်[[the-decode-phase]]

Prefill အဆင့်က input ကို လုပ်ဆောင်ပြီးနောက်မှာတော့ decode အဆင့်ကို ရောက်ရှိလာပါပြီ - ဒီနေရာမှာ စာသားထုတ်လုပ်ခြင်း အမှန်တကယ် ဖြစ်လာပါတယ်။ မော်ဒယ်က တစ်ကြိမ်ကို token တစ်ခုစီ ထုတ်လုပ်ပြီး၊ ဒါကို autoregressive process (အသစ်ထွက်လာတဲ့ token တိုင်းက ယခင် tokens အားလုံးပေါ် မူတည်ပါတယ်) လို့ ခေါ်ပါတယ်။

Decode အဆင့်မှာ အသစ်ထွက်လာတဲ့ token တိုင်းအတွက် အဓိကအချက်များစွာ ပါဝင်ပါတယ်-
1.  **Attention Computation**: context ကို နားလည်ဖို့ ယခင် tokens အားလုံးကို ပြန်ကြည့်ခြင်း
2.  **ဖြစ်နိုင်ခြေ တွက်ချက်ခြင်း (Probability Calculation)**: ဖြစ်နိုင်ခြေရှိတဲ့ နောက်ထပ် token တစ်ခုစီရဲ့ ဖြစ်နိုင်ခြေကို ဆုံးဖြတ်ခြင်း
3.  **Token ရွေးချယ်ခြင်း (Token Selection)**: ဒီဖြစ်နိုင်ခြေတွေအပေါ် အခြေခံပြီး နောက်ထပ် token ကို ရွေးချယ်ခြင်း
4.  **ဆက်လက်လုပ်ဆောင်မှု စစ်ဆေးခြင်း (Continuation Check)**: ဆက်လုပ်မလား ဒါမှမဟုတ် ထုတ်လုပ်မှုကို ရပ်မလားဆိုတာကို ဆုံးဖြတ်ခြင်း

ဒီအဆင့်ဟာ မော်ဒယ်က ယခင်ထုတ်လုပ်ထားတဲ့ tokens အားလုံးနဲ့ ၎င်းတို့ရဲ့ ဆက်စပ်မှုတွေကို မှတ်ထားဖို့ လိုအပ်တာကြောင့် memory-intensive ဖြစ်ပါတယ်။

## Sampling နည်းဗျူဟာများ[[sampling-strategies]]

မော်ဒယ်က စာသားတွေကို ဘယ်လိုထုတ်လုပ်တယ်ဆိုတာ နားလည်ပြီးပြီဆိုတော့ ဒီထုတ်လုပ်မှု လုပ်ငန်းစဉ်ကို ဘယ်လိုထိန်းချုပ်နိုင်မလဲဆိုတာကို လေ့လာကြည့်ရအောင်။ စာရေးဆရာတစ်ဦးက ပိုမိုတီထွင်ဖန်တီးမှုရှိမလား ဒါမှမဟုတ် ပိုမိုတိကျမလားဆိုတာ ရွေးချယ်နိုင်သလိုပဲ၊ ကျွန်တော်တို့လည်း မော်ဒယ်က tokens တွေကို ဘယ်လိုရွေးချယ်တယ်ဆိုတာကို ချိန်ညှိနိုင်ပါတယ်။

ဒီ Space မှာ SmolLM2 နဲ့ အခြေခံ decoding လုပ်ငန်းစဉ်ကို ကိုယ်တိုင် အပြန်အလှန်လုပ်ဆောင်နိုင်ပါတယ် (မှတ်ထားပါ၊ ဒီမော်ဒယ်အတွက် **<|im_end|>** ဖြစ်တဲ့ **EOS** token ကို မရောက်မချင်း decode လုပ်ပါလိမ့်မယ်)-

<iframe
	src="https://agents-course-decoding-visualizer.hf.space"
	frameborder="0"
	width="850"
	height="450"
></iframe>

### Token ရွေးချယ်မှုကို နားလည်ခြင်း- ဖြစ်နိုင်ခြေများမှ Token ရွေးချယ်မှုများဆီသို့[[understanding-token-selection-from-probabilities-to-token-choices]]

မော်ဒယ်က နောက်ထပ် token ကို ရွေးချယ်ဖို့ လိုအပ်တဲ့အခါ၊ ၎င်းရဲ့ ဝေါဟာရ (vocabulary) ထဲက စကားလုံးတိုင်းအတွက် ကနဦး ဖြစ်နိုင်ခြေ (logits) တွေနဲ့ စတင်ပါတယ်။ ဒါပေမယ့် ဒီဖြစ်နိုင်ခြေတွေကို လက်တွေ့ရွေးချယ်မှုတွေအဖြစ် ဘယ်လိုပြောင်းလဲမလဲ။ လုပ်ငန်းစဉ်ကို ခွဲခြမ်းစိတ်ဖြာကြည့်ရအောင်-

![image](https://huggingface.co/reasoning-course/images/resolve/main/inference/1.png)  

1.  **Raw Logits**: ဒါတွေကို မော်ဒယ်ရဲ့ နောက်ထပ် ဖြစ်နိုင်ခြေရှိတဲ့ စကားလုံးတိုင်းအတွက် ကနဦး ခံစားချက်တွေလို့ တွေးကြည့်ပါ။
2.  **Temperature Control**: တီထွင်ဖန်တီးမှု ခလုတ်လိုပါပဲ - တန်ဖိုးမြင့်လေ (>1.0) ရွေးချယ်မှုတွေ ပိုမိုကျပန်းဆန်ပြီး ဖန်တီးမှုရှိလေ၊ တန်ဖိုးနိမ့်လေ (<1.0) ပိုမိုအာရုံစိုက်ပြီး တိကျလေ ဖြစ်ပါတယ်။
3.  **Top-p (Nucleus) Sampling**: ဖြစ်နိုင်ခြေရှိတဲ့ စကားလုံးအားလုံးကို ထည့်သွင်းစဉ်းစားမယ့်အစား၊ ကျွန်တော်တို့ ရွေးချယ်ထားတဲ့ ဖြစ်နိုင်ခြေ ကန့်သတ်ချက် (ဥပမာ- ထိပ်ဆုံး 90%) နဲ့ ကိုက်ညီတဲ့ အဖြစ်နိုင်ဆုံး စကားလုံးတွေကိုပဲ ကြည့်ပါတယ်။
4.  **Top-k Filtering**: အခြားနည်းလမ်းတစ်ခုဖြစ်ပြီး၊ ကျွန်တော်တို့ဟာ အဖြစ်နိုင်ဆုံး နောက်ထပ်စကားလုံး k လုံးကိုပဲ ထည့်သွင်းစဉ်းစားပါတယ်။

### ထပ်ခါတလဲလဲဖြစ်ခြင်းကို ထိန်းချုပ်ခြင်း- Output ကို လတ်ဆတ်နေစေခြင်း[[managing-repetition-keeping-output-fresh]]

LLMs တွေနဲ့ အဖြစ်များတဲ့ စိန်ခေါ်မှုတစ်ခုကတော့ သူတို့ကိုယ်သူတို့ ထပ်ခါတလဲလဲပြောတတ်တဲ့ သဘောရှိခြင်းပါ - အချက်အလက်တွေကို အကြိမ်ကြိမ် ပြန်ပြောတတ်တဲ့ စကားပြောသူတစ်ဦးနဲ့ တူပါတယ်။ ဒါကို ဖြေရှင်းဖို့အတွက် ကျွန်တော်တို့ဟာ ပြစ်ဒဏ်နှစ်မျိုးကို အသုံးပြုပါတယ်-

1.  **Presence Penalty**: ယခင်က ပါဝင်ခဲ့ဖူးတဲ့ token တစ်ခုစီအတွက် အကြိမ်အရေအတွက် ဘယ်လောက်ပဲ ဖြစ်ပါစေ၊ သတ်မှတ်ထားတဲ့ ပြစ်ဒဏ်တစ်ခုကို ပေးပါတယ်။ ဒါက မော်ဒယ်ကို တူညီတဲ့ စကားလုံးတွေကို ထပ်ခါတလဲလဲ အသုံးမပြုမိအောင် ကူညီပေးပါတယ်။
2.  **Frequency Penalty**: token တစ်ခု ဘယ်နှစ်ကြိမ် အသုံးပြုပြီးပြီလဲဆိုတာပေါ်မူတည်ပြီး တိုးလာတဲ့ ပြစ်ဒဏ်တစ်ခုပါ။ စကားလုံးတစ်ခု ပိုမိုပါဝင်လေ၊ နောက်ထပ်ရွေးချယ်ခံရဖို့ အခွင့်အလမ်း နည်းလေ ဖြစ်ပါတယ်။

![image](https://huggingface.co/reasoning-course/images/resolve/main/inference/2.png)  

ဒီပြစ်ဒဏ်တွေကို token ရွေးချယ်မှု လုပ်ငန်းစဉ်ရဲ့ အစောပိုင်းမှာ လိမ်းကျံပြီး၊ အခြား sampling နည်းဗျူဟာတွေကို အသုံးမပြုခင် ကနဦး ဖြစ်နိုင်ခြေတွေကို ချိန်ညှိပေးပါတယ်။ ဒါတွေကို မော်ဒယ်ကို ဝေါဟာရအသစ်တွေ ရှာဖွေဖို့ နူးညံ့စွာ တွန်းအားပေးတာနဲ့ တူတယ်လို့ တွေးကြည့်နိုင်ပါတယ်။

### ထုတ်လုပ်မှု အရှည်ကို ထိန်းချုပ်ခြင်း- ကန့်သတ်ချက်များ သတ်မှတ်ခြင်း[[controlling-generation-length-setting-boundaries]]

ကောင်းမွန်တဲ့ ပုံပြင်တစ်ခုမှာ သင့်လျော်တဲ့ စည်းမျဉ်းစည်းကမ်းနဲ့ အရှည်ရှိဖို့ လိုအပ်သလိုပဲ၊ ကျွန်တော်တို့ရဲ့ LLM က ဘယ်လောက်များများ စာသားထုတ်လုပ်မလဲဆိုတာကို ထိန်းချုပ်ဖို့ နည်းလမ်းတွေ လိုအပ်ပါတယ်။ ဒါက လက်တွေ့အသုံးချမှုတွေအတွက် အရေးကြီးပါတယ် - tweet တစ်ခုလောက်တိုတဲ့ အဖြေဖြစ်စေ၊ blog post အပြည့်အစုံဖြစ်စေပေါ့။

ထုတ်လုပ်မှု အရှည်ကို နည်းလမ်းများစွာနဲ့ ထိန်းချုပ်နိုင်ပါတယ်-
1.  **Token Limits**: အနည်းဆုံးနဲ့ အများဆုံး token အရေအတွက်ကို သတ်မှတ်ခြင်း
2.  **Stop Sequences**: ထုတ်လုပ်မှု ပြီးဆုံးကြောင်း အချက်ပြတဲ့ သီးခြားပုံစံတွေကို သတ်မှတ်ခြင်း
3.  **End-of-Sequence Detection**: မော်ဒယ်ကို သူ့ဘာသာသူ အဖြေကို သဘာဝအတိုင်း နိဂုံးချုပ်စေခြင်း

ဥပမာအားဖြင့်၊ ကျွန်တော်တို့ဟာ စာပိုဒ်တစ်ပိုဒ်တည်းကိုပဲ ထုတ်လုပ်ချင်တယ်ဆိုရင် အများဆုံး tokens 100 သတ်မှတ်ပြီး "\n\n" ကို stop sequence အဖြစ် အသုံးပြုနိုင်ပါတယ်။ ဒါက ကျွန်တော်တို့ရဲ့ output က ရည်ရွယ်ချက်နဲ့ ကိုက်ညီတဲ့ အရွယ်အစားနဲ့ အာရုံစိုက်မှု ရှိစေပါတယ်။

![image](https://huggingface.co/reasoning-course/images/resolve/main/inference/3.png)  

### Beam Search: ပိုမိုကောင်းမွန်တဲ့ ဆက်စပ်မှုအတွက် ကြိုတင်မျှော်မှန်းခြင်း[[beam-search-looking-ahead-for-better-coherence]]

ကျွန်တော်တို့ ခုထိ ဆွေးနွေးခဲ့တဲ့ နည်းဗျူဟာတွေက တစ်ကြိမ်ကို token တစ်ခုစီ ဆုံးဖြတ်ချက်ချပေမယ့်၊ beam search ကတော့ ပိုမိုပြည့်စုံတဲ့ ချဉ်းကပ်မှုကို လုပ်ဆောင်ပါတယ်။ ခြေလှမ်းတိုင်းမှာ ရွေးချယ်မှုတစ်ခုတည်းကိုပဲ လုပ်ဆောင်မယ့်အစား၊ ၎င်းဟာ ကစားသမားတစ်ဦးက အရှေ့ကို အကြိမ်ကြိမ် တွေးတောသလိုမျိုး ဖြစ်နိုင်ခြေရှိတဲ့ လမ်းကြောင်းပေါင်းစုံကို တစ်ပြိုင်နက်တည်း ရှာဖွေပါတယ်။

![image](https://huggingface.co/reasoning-course/images/resolve/main/inference/4.png)  

ဒါက ဘယ်လိုအလုပ်လုပ်လဲဆိုတာကို ကြည့်ရအောင်-
1.  ခြေလှမ်းတိုင်းမှာ၊ ဖြစ်နိုင်ခြေရှိတဲ့ candidate sequence အများအပြားကို ထိန်းသိမ်းထားပါတယ် (များသောအားဖြင့် ၅-၁၀ ခု)။
2.  candidate တစ်ခုစီအတွက်၊ နောက်ထပ် token ရဲ့ ဖြစ်နိုင်ခြေတွေကို တွက်ချက်ပါတယ်။
3.  sequence တွေနဲ့ နောက်ထပ် token တွေရဲ့ အဖြစ်နိုင်ဆုံး ပေါင်းစပ်မှုတွေကိုသာ ထိန်းသိမ်းထားပါတယ်။
4.  လိုချင်တဲ့ အရှည် ဒါမှမဟုတ် ရပ်တန့်တဲ့အခြေအနေကို ရောက်တဲ့အထိ ဒီလုပ်ငန်းစဉ်ကို ဆက်လုပ်ပါတယ်။
5.  အလုံးစုံ ဖြစ်နိုင်ခြေအမြင့်ဆုံးရှိတဲ့ sequence ကို ရွေးချယ်ပါတယ်။

ဒီနေရာမှာ beam search ကို ပုံမှန်ကြည့်ရှုနိုင်ပါတယ်-

<iframe
	src="https://agents-course-beam-search-visualizer.hf.space"
	frameborder="0"
	width="850"
	height="450"
></iframe>

ဒီချဉ်းကပ်မှုက ပိုမိုဆက်စပ်မှုရှိပြီး သဒ္ဒါမှန်ကန်တဲ့ စာသားတွေကို မကြာခဏ ထုတ်လုပ်ပေးတတ်ပေမယ့်၊ ရိုးရှင်းတဲ့ နည်းလမ်းတွေထက် ကွန်ပျူတာ အရင်းအမြစ် ပိုမိုလိုအပ်ပါတယ်။

## လက်တွေ့ စိန်ခေါ်မှုများနှင့် အကောင်းဆုံးဖြစ်အောင် ပြုလုပ်ခြင်း (Optimization)[[practical-challenges-and-optimization]]

LLM inference ကို ကျွန်တော်တို့ လေ့လာမှု ပြီးဆုံးခါနီးမှာ ဒီမော်ဒယ်တွေကို အသုံးပြုတဲ့အခါ သင်ရင်ဆိုင်ရမယ့် လက်တွေ့ကျတဲ့ စိန်ခေါ်မှုတွေနဲ့ ၎င်းတို့ရဲ့ စွမ်းဆောင်ရည်ကို ဘယ်လိုတိုင်းတာပြီး အကောင်းဆုံးဖြစ်အောင် လုပ်ရမလဲဆိုတာကို ကြည့်ရအောင်။

### အဓိက စွမ်းဆောင်ရည် တိုင်းတာချက်များ (Key Performance Metrics)[[key-performance-metrics]]

LLMs တွေနဲ့ အလုပ်လုပ်တဲ့အခါ အရေးကြီးတဲ့ တိုင်းတာချက် (၄) ခုက သင်ရဲ့ implement လုပ်မယ့် ဆုံးဖြတ်ချက်တွေကို ပုံဖော်ပေးပါလိမ့်မယ်-

1.  **ပထမဆုံး Token ရရှိချိန် (Time to First Token - TTFT)**: ပထမဆုံး အဖြေကို ဘယ်လောက် မြန်မြန်ရနိုင်မလဲ။ ဒါက user experience အတွက် အရေးကြီးပြီး prefill အဆင့်ကြောင့် အဓိကအားဖြင့် ထိခိုက်ပါတယ်။
2.  **Output Token တစ်ခုစီအတွက် အချိန် (Time Per Output Token - TPOT)**: နောက်ထပ် tokens တွေကို ဘယ်လောက် မြန်မြန်ထုတ်လုပ်နိုင်မလဲ။ ဒါက အလုံးစုံ ထုတ်လုပ်မှု အမြန်နှုန်းကို ဆုံးဖြတ်ပါတယ်။
3.  **Throughput**: တစ်ပြိုင်နက်တည်း request ဘယ်နှစ်ခုကို ကိုင်တွယ်နိုင်မလဲ။ ဒါက scaling နဲ့ ကုန်ကျစရိတ် ထိရောက်မှုအပေါ် သက်ရောက်မှုရှိပါတယ်။
4.  **VRAM အသုံးပြုမှု (VRAM Usage)**: GPU memory ဘယ်လောက်လိုအပ်မလဲ။ ဒါက လက်တွေ့အသုံးချမှုတွေမှာ အဓိက ကန့်သတ်ချက် ဖြစ်လာတတ်ပါတယ်။

### Context Length စိန်ခေါ်မှု[[the-context-length-challenge]]

LLM inference မှာ အရေးအကြီးဆုံး စိန်ခေါ်မှုတစ်ခုကတော့ context length ကို ထိထိရောက်ရောက် စီမံခန့်ခွဲခြင်းပါပဲ။ ပိုမိုရှည်လျားတဲ့ contexts တွေက အချက်အလက် ပိုပေးပေမယ့် ကုန်ကျစရိတ်များစွာနဲ့ လာပါတယ်-

- **Memory အသုံးပြုမှု**: context length နဲ့အမျှ quadratically တိုးလာပါတယ်။
- **လုပ်ဆောင်မှု အမြန်နှုန်း (Processing Speed)**: ပိုမိုရှည်လျားတဲ့ contexts တွေနဲ့အမျှ linearly လျော့ကျသွားပါတယ်။
- **အရင်းအမြစ် ခွဲဝေမှု (Resource Allocation)**: VRAM အသုံးပြုမှုကို သေချာမျှတအောင် ထိန်းညှိဖို့ လိုအပ်ပါတယ်။

[Qwen2.5-1M](https://huggingface.co/Qwen/Qwen2.5-14B-Instruct-1M) လို ခေတ်မီမော်ဒယ်တွေကတော့ 1M token context windows တွေကို စွဲမက်ဖွယ်ကောင်းအောင် ပေးစွမ်းနိုင်ပေမယ့်၊ ဒါဟာ inference လုပ်ဆောင်ချိန် သိသိသာသာ နှေးကွေးခြင်းရဲ့ အဖိုးအခနဲ့ လာပါတယ်။ အဓိကသော့ချက်ကတော့ သင်ရဲ့ သီးခြားအသုံးပြုမှုအတွက် မှန်ကန်တဲ့ မျှတမှုကို ရှာဖွေဖို့ပါပဲ။

<div style="max-width: 800px; margin: 20px auto; padding: 20px; 
font-family: system-ui;">
    <div style="border: 2px solid #ddd; border-radius: 8px; 
    padding: 20px; margin-bottom: 20px;">
        <div style="display: flex; align-items: center; 
        margin-bottom: 15px;">
            <div style="flex: 1; text-align: center; padding: 
            10px; background: #f0f0f0; border-radius: 4px;">
                Input Text (Raw)
            </div>
            <div style="margin: 0 10px;">→</div>
            <div style="flex: 1; text-align: center; padding: 
            10px; background: #e1f5fe; border-radius: 4px;">
                Tokenized Input
            </div>
        </div>
        <div style="display: flex; margin-bottom: 15px;">
            <div style="flex: 1; border: 1px solid #ccc; 
            padding: 10px; margin: 5px; background: #e8f5e9; 
            border-radius: 4px; text-align: center;">
                Context Window<br/>(ဥပမာ- 4K tokens)
                <div style="display: flex; margin-top: 10px;">
                    <div style="flex: 1; background: #81c784; 
                    margin: 2px; height: 20px; border-radius: 
                    2px;"></div>
                    <div style="flex: 1; background: #81c784; 
                    margin: 2px; height: 20px; border-radius: 
                    2px;"></div>
                    <div style="flex: 1; background: #81c784; 
                    margin: 2px; height: 20px; border-radius: 
                    2px;"></div>
                    <div style="flex: 1; background: #81c784; 
                    margin: 2px; height: 20px; border-radius: 
                    2px;"></div>
                </div>
            </div>
        </div>
        <div style="display: flex; justify-content: 
        space-between; text-align: center; font-size: 0.9em; 
        color: #666;">
            <div style="flex: 1;">
                <div style="border: 1px solid #ffcc80; padding: 
                8px; margin: 5px; background: #fff3e0; 
                border-radius: 4px;">
                    Memory အသုံးပြုမှု<br/>∝ အရှည်²
                </div>
            </div>
            <div style="flex: 1;">
                <div style="border: 1px solid #90caf9; padding: 
                8px; margin: 5px; background: #e3f2fd; 
                border-radius: 4px;">
                    လုပ်ဆောင်ချိန်<br/>∝ အရှည်
                </div>
            </div>
        </div>
    </div>
</div>

### KV Cache Optimization[[the-kv-cache-optimization]]

ဒီစိန်ခေါ်မှုတွေကို ဖြေရှင်းဖို့အတွက် အစွမ်းအထက်ဆုံး optimization တစ်ခုကတော့ KV (Key-Value) caching ပါ။ ဒီနည်းပညာက ကြားဖြတ်တွက်ချက်မှုတွေကို သိုလှောင်ပြီး ပြန်လည်အသုံးပြုခြင်းဖြင့် inference အမြန်နှုန်းကို သိသိသာသာ တိုးတက်စေပါတယ်။ ဒီ optimization က-
- ထပ်ခါတလဲလဲ တွက်ချက်မှုတွေကို လျှော့ချပေးပါတယ်
- ထုတ်လုပ်မှု အမြန်နှုန်းကို တိုးတက်စေပါတယ်
- ရှည်လျားတဲ့ context ထုတ်လုပ်မှုကို လက်တွေ့ကျအောင် လုပ်ဆောင်ပေးပါတယ်

အားနည်းချက်ကတော့ memory အသုံးပြုမှု ပိုများလာတာပါပဲ၊ ဒါပေမယ့် စွမ်းဆောင်ရည် အကျိုးကျေးဇူးတွေက ဒီကုန်ကျစရိတ်ထက် များသောအားဖြင့် သာလွန်ပါတယ်။

## နိဂုံး[[conclusion]]

LLM inference ကို နားလည်ထားခြင်းက ဒီအစွမ်းထက်တဲ့ မော်ဒယ်တွေကို ထိထိရောက်ရောက် အသုံးပြုပြီး အကောင်းဆုံးဖြစ်အောင် လုပ်ဆောင်ဖို့အတွက် အရေးကြီးပါတယ်။ ကျွန်တော်တို့ဟာ အဓိကအစိတ်အပိုင်းတွေကို လေ့လာခဲ့ပြီးပါပြီ-

- Attention နဲ့ context ရဲ့ အခြေခံအခန်းကဏ္ဍ
- နှစ်ဆင့်ပါသော inference လုပ်ငန်းစဉ်
- ထုတ်လုပ်မှုကို ထိန်းချုပ်ရန် အမျိုးမျိုးသော sampling နည်းဗျူဟာများ
- လက်တွေ့ စိန်ခေါ်မှုများနှင့် optimization များ

ဒီသဘောတရားတွေကို ကျွမ်းကျင်ခြင်းဖြင့် LLMs တွေကို ထိရောက်စွာနဲ့ စွမ်းဆောင်ရည်မြင့်စွာ အသုံးပြုနိုင်တဲ့ applications တွေ တည်ဆောက်ဖို့ သင်ပိုပြီး အသင့်ဖြစ်လာပါလိမ့်မယ်။

LLM inference နယ်ပယ်ဟာ အဆက်မပြတ် တိုးတက်ပြောင်းလဲနေပြီး၊ နည်းစနစ်အသစ်တွေနဲ့ optimization တွေ ပုံမှန်ပေါ်ထွက်လာနေတာကို သတိရပါ။ သင်ရဲ့ သီးခြားအသုံးပြုမှုအတွက် ဘယ်အရာက အကောင်းဆုံးလဲဆိုတာကို ရှာဖွေဖို့ စူးစမ်းလိုစိတ်ထားပြီး မတူညီတဲ့ ချဉ်းကပ်မှုတွေနဲ့ ဆက်လက်စမ်းသပ်ပါ။

## ဝေါဟာရ ရှင်းလင်းချက် (Glossary)

*   **Inference**: လေ့ကျင့်ပြီးသား Artificial Intelligence (AI) မော်ဒယ်တစ်ခုကို အသုံးပြုပြီး input data ကနေ ခန့်မှန်းချက်တွေ ဒါမှမဟုတ် output တွေကို ထုတ်လုပ်တဲ့ လုပ်ငန်းစဉ်။
*   **Large Language Models (LLMs)**: လူသားဘာသာစကားကို နားလည်ပြီး ထုတ်လုပ်ပေးနိုင်တဲ့ အလွန်ကြီးမားတဲ့ Artificial Intelligence (AI) မော်ဒယ်တွေ ဖြစ်ပါတယ်။ ၎င်းတို့ဟာ ဒေတာအမြောက်အမြားနဲ့ သင်ကြားလေ့ကျင့်ထားပြီး စာရေးတာ၊ မေးခွန်းဖြေတာ စတဲ့ ဘာသာစကားဆိုင်ရာ လုပ်ငန်းမျိုးစုံကို လုပ်ဆောင်နိုင်ပါတယ်။
*   **Transformer Architecture**: Natural Language Processing (NLP) မှာ အောင်မြင်မှုများစွာရရှိခဲ့တဲ့ deep learning architecture တစ်မျိုးပါ။ ၎င်းတို့ဟာ စာသားတွေထဲက စကားလုံးတွေရဲ့ ဆက်နွယ်မှုတွေကို "attention mechanism" သုံးပြီး နားလည်အောင် သင်ကြားပေးပါတယ်။
*   **Text Generation**: AI မော်ဒယ်များကို အသုံးပြု၍ လူသားကဲ့သို့သော စာသားအသစ်များ ဖန်တီးခြင်း။
*   **Text Classification**: စာသားတစ်ခုကို သတ်မှတ်ထားသော အမျိုးအစားများ သို့မဟုတ် အတန်းများထဲသို့ ခွဲခြားသတ်မှတ်ခြင်း။
*   **Summarization**: စာသားရှည်ကြီးတစ်ခုကို အဓိကအချက်အလက်များ မပျောက်ပျက်စေဘဲ အကျဉ်းချုံးဖော်ပြခြင်း။
*   **Prompt**: Large Language Models (LLMs) ကို တိကျသောလုပ်ငန်းတစ်ခု လုပ်ဆောင်ရန် သို့မဟုတ် အချက်အလက်ပေးရန်အတွက် ပေးပို့သော input text သို့မဟုတ် မေးခွန်း။
*   **Parameters**: Machine Learning မော်ဒယ်တစ်ခု၏ သင်ယူနိုင်သော အစိတ်အပိုင်းများ။ ၎င်းတို့သည် လေ့ကျင့်နေစဉ်အတွင်း ဒေတာများမှ ပုံစံများကို သင်ယူကာ ချိန်ညှိပေးသည်။
*   **Token**: စာသား (သို့မဟုတ် အခြားဒေတာ) ကို AI မော်ဒယ်များ စီမံဆောင်ရွက်နိုင်ရန် ပိုင်းခြားထားသော အသေးငယ်ဆုံးယူနစ်။ စကားလုံး၊ စာလုံးတစ်ပိုင်း သို့မဟုတ် တစ်ခုတည်းသော စာလုံးတစ်လုံး ဖြစ်နိုင်သည်။
*   **Sequence**: အစဉ်လိုက် စီစဉ်ထားသော tokens များ။
*   **Coherent**: ယုတ္တိရှိရှိ ဆက်စပ်နေခြင်း၊ နားလည်လွယ်ခြင်း။
*   **Context**: စကားလုံး၊ စာကြောင်း သို့မဟုတ် အကြောင်းအရာတစ်ခုရဲ့ အဓိပ္ပာယ်ကို နားလည်စေရန် ကူညီပေးသော ပတ်ဝန်းကျင်ရှိ အချက်အလက်များ။
*   **Attention Mechanism**: Transformer မော်ဒယ်များတွင် အသုံးပြုသော နည်းစနစ်တစ်ခုဖြစ်ပြီး input sequence အတွင်းရှိ အရေးပါသော အစိတ်အပိုင်းများကို အာရုံစိုက်ပြီး ဆက်နွယ်မှုများကို သင်ယူစေသည်။
*   **BERT (Bidirectional Encoder Representations from Transformers)**: Google မှ တီထွင်ထားသော Transformer-based NLP မော်ဒယ်တစ်ခု။
*   **GPT-2 (Generative Pre-trained Transformer 2)**: OpenAI မှ တီထွင်ထားသော Transformer-based NLP မော်ဒယ်တစ်ခု။
*   **Neural Networks**: လူသားဦးနှောက်၏ လုပ်ဆောင်မှုပုံစံကို အတုယူထားသော ကွန်ပျူတာစနစ်များ။
*   **Context Length**: Large Language Model (LLM) တစ်ခုက တစ်ကြိမ်တည်း လုပ်ဆောင်နိုင်သော အများဆုံး token အရေအတွက်။
*   **Working Memory**: မော်ဒယ်က လက်ရှိလုပ်ငန်းဆောင်တာအတွက် လိုအပ်တဲ့ အချက်အလက်တွေကို ခဏတာ ထိန်းသိမ်းထားတဲ့ မှတ်ဉာဏ်။
*   **Hardware Constraints**: ကွန်ပျူတာစနစ်ရဲ့ ရုပ်ပိုင်းဆိုင်ရာ ကန့်သတ်ချက်များ (ဥပမာ- GPU memory, processing power)။
*   **Computational Costs**: ကွန်ပျူတာအရင်းအမြစ်များ (ဥပမာ- လျှပ်စစ်ဓာတ်အား၊ စက်အချိန်) အသုံးပြုခြင်းအတွက် ကုန်ကျစရိတ်။
*   **Tokenization**: input text ကို AI မော်ဒယ် နားလည်နိုင်တဲ့ tokens တွေအဖြစ် ပြောင်းလဲတဲ့ လုပ်ငန်းစဉ်။
*   **Embeddings**: tokens တွေရဲ့ အဓိပ္ပာယ်ကို ဖမ်းယူထားတဲ့ ဂဏန်းဆိုင်ရာ ကိုယ်စားပြုမှုများ။
*   **Neural Networks**: လူသားဦးနှောက်၏ လုပ်ဆောင်မှုပုံစံကို အတုယူထားသော ကွန်ပျူတာစနစ်များ။
*   **Autoregressive Process**: နောက်ထပ်ထုတ်လုပ်မယ့် output က ယခင်ထုတ်လုပ်ခဲ့တဲ့ outputs အားလုံးပေါ် မူတည်နေတဲ့ လုပ်ငန်းစဉ်။
*   **Logits**: မော်ဒယ်က နောက်ထပ် ဖြစ်နိုင်ခြေရှိတဲ့ token တစ်ခုစီအတွက် ထုတ်ပေးတဲ့ ကနဦး၊ အဆင့်မမီသေးတဲ့ ဖြစ်နိုင်ခြေတန်ဖိုးများ။
*   **Temperature Control**: LLM ရဲ့ output မှာ ကျပန်းဆန်မှု (randomness) သို့မဟုတ် တီထွင်ဖန်တီးမှု (creativity) ပမာဏကို ထိန်းညှိရန် အသုံးပြုသော parameter တစ်ခု။
*   **Top-p (Nucleus) Sampling**: နောက်ထပ် token ကို ရွေးချယ်ရာတွင် ဖြစ်နိုင်ခြေအမြင့်ဆုံး token များ၏ စုစုပေါင်းဖြစ်နိုင်ခြေ ကန့်သတ်ချက်အောက်တွင်ရှိသော token များကိုသာ ထည့်သွင်းစဉ်းစားခြင်း။
*   **Top-k Filtering**: နောက်ထပ် token ကို ရွေးချယ်ရာတွင် အဖြစ်နိုင်ဆုံး k လုံးကိုသာ ထည့်သွင်းစဉ်းစားခြင်း။
*   **Presence Penalty**: ယခင်က ပေါ်ထွက်ဖူးသော token များအတွက် ပုံသေပြစ်ဒဏ်ချမှတ်ခြင်း။
*   **Frequency Penalty**: ယခင်က ပေါ်ထွက်ဖူးသော token များအတွက် ၎င်းတို့ပေါ်ထွက်သည့် အကြိမ်အရေအတွက်အလိုက် ပြစ်ဒဏ်ကို တိုးမြှင့်ချမှတ်ခြင်း။
*   **Token Limits**: ထုတ်လုပ်မည့် token အရေအတွက်အတွက် အနည်းဆုံးနှင့် အများဆုံး ကန့်သတ်ချက်များ။
*   **Stop Sequences**: စာသားထုတ်လုပ်မှုကို ရပ်တန့်ရန် အချက်ပြသည့် သတ်မှတ်ထားသော စာသားပုံစံများ။
*   **End-of-Sequence (EOS) Token**: မော်ဒယ်က စာသားထုတ်လုပ်မှုကို ပြီးဆုံးရန် အချက်ပြသည့် အထူး token တစ်ခု။
*   **Beam Search**: စာသားထုတ်လုပ်ရာတွင် ဖြစ်နိုင်ခြေအကောင်းဆုံး sequence များစွာကို တစ်ပြိုင်နက်တည်း ရှာဖွေပြီး အကောင်းဆုံးကို ရွေးချယ်သည့် နည်းဗျူဟာ။
*   **Time to First Token (TTFT)**: LLM တစ်ခုက input prompt ကို လက်ခံရရှိပြီးနောက် ပထမဆုံး token ကို ထုတ်လုပ်ရန် ကြာမြင့်သော အချိန်။
*   **Time Per Output Token (TPOT)**: LLM တစ်ခုက နောက်ဆက်တွဲ output token တစ်ခုစီကို ထုတ်လုပ်ရန် ကြာမြင့်သော အချိန်။
*   **Throughput**: LLM စနစ်တစ်ခုက သတ်မှတ်ထားသော အချိန်ကာလတစ်ခုအတွင်း လုပ်ဆောင်နိုင်သော requests အရေအတွက်။
*   **VRAM Usage**: GPU (Graphics Processing Unit) ၏ memory အသုံးပြုမှု။
*   **KV (Key-Value) Caching**: LLM inference တွင် အကြားအချက်အလက်များကို သိုလှောင်ပြီး ပြန်လည်အသုံးပြုခြင်းဖြင့် လုပ်ဆောင်မှုအမြန်နှုန်းကို မြှင့်တင်ပေးသော နည်းပညာ။