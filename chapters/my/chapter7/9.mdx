<FrameworkSwitchCourse {fw} />

<!-- DISABLE-FRONTMATTER-SECTIONS -->

# အခန်း (၇) ဆိုင်ရာ မေးခွန်းများ[[end-of-chapter-quiz]]

<CourseFloatingBanner
    chapter={7}
    classNames="absolute z-10 right-0 top-0"
/>

ဒီအခန်းမှာ သင်ယူခဲ့တာတွေကို စစ်ဆေးကြည့်ရအောင်။

### ၁။ အောက်ပါ tasks တွေထဲက ဘယ်ဟာတွေကို token classification problem အဖြစ် ပုံဖော်နိုင်သလဲ။

<Question
	choices={[
		{
			text: "စာကြောင်းတစ်ကြောင်းထဲက grammatical components တွေကို ရှာပါ။",
			explain: "မှန်ပါတယ်။ အဲဒီအခါမှာ စကားလုံးတစ်လုံးစီကို noun, verb စသည်ဖြင့် label လုပ်နိုင်ပါတယ်။",
			correct: true
		},
		{
			text: "စာကြောင်းတစ်ကြောင်းဟာ grammatical အရ မှန်ကန်ခြင်း ရှိမရှိ ရှာပါ။",
			explain: "မမှန်ပါဘူး၊ ဒါက sequence classification problem တစ်ခုပါ။"
		},
		{
			text: "စာကြောင်းတစ်ကြောင်းမှာ ဖော်ပြထားတဲ့ လူပုဂ္ဂိုလ်တွေကို ရှာပါ။",
			explain: "မှန်ပါတယ်။ စကားလုံးတစ်လုံးစီကို person ဒါမှမဟုတ် not person အဖြစ် label လုပ်နိုင်ပါတယ်။",
            correct: true
		},
        {
			text: "မေးခွန်းတစ်ခုရဲ့ အဖြေကို ပေးတဲ့ စာကြောင်းတစ်ကြောင်းထဲက words chunk ကို ရှာပါ။",
			explain: "မမှန်ပါဘူး၊ ဒါက question answering problem တစ်ခု ဖြစ်ပါလိမ့်မယ်။"
		}
	]}
/>

### ၂။ token classification အတွက် preprocessing ရဲ့ ဘယ်အပိုင်းက အခြား preprocessing pipelines တွေနဲ့ ကွာခြားသလဲ။

<Question
	choices={[
		{
			text: "ဘာမှ လုပ်စရာ မလိုပါဘူး၊ texts တွေကို tokenize လုပ်ပြီးသားပါ။",
			explain: "Texts တွေဟာ သီးခြား words တွေအဖြစ် ပေးထားတာ မှန်ပါတယ်၊ ဒါပေမယ့် subword tokenization model ကိုတော့ အသုံးပြုဖို့ လိုအပ်ပါသေးတယ်။"
		},
		{
			text: "Texts တွေကို words တွေအဖြစ် ပေးထားတာကြောင့် subword tokenization ကိုပဲ အသုံးပြုဖို့ လိုပါတယ်။",
			explain: "မှန်ပါတယ်။ ဒါက ပုံမှန် preprocessing နဲ့ ကွာခြားပါတယ်၊ ပုံမှန်မှာတော့ ကျွန်တော်တို့ full tokenization pipeline ကို အသုံးပြုဖို့ လိုပါတယ်။ တခြားကွာခြားချက်တစ်ခုကို စဉ်းစားနိုင်မလား။",
			correct: true
		},
		{
			text: "special tokens တွေကို label လုပ်ဖို့ <code>-100</code> ကို အသုံးပြုပါတယ်။",
			explain: "ဒါက token classification အတွက် သီးခြားမဟုတ်ပါဘူး — ကျွန်တော်တို့ loss မှာ ignore လုပ်ချင်တဲ့ tokens တွေအတွက် label အဖြစ် <code>-100</code> ကို အမြဲတမ်း အသုံးပြုပါတယ်။"
		},
		{
			text: "truncation/padding ကို အသုံးပြုတဲ့အခါ labels တွေကို inputs တွေနဲ့ တူညီတဲ့ size အထိ truncate ဒါမှမဟုတ် pad လုပ်ထားဖို့ သေချာစေရပါမယ်။",
			explain: "ဟုတ်ပါတယ်။ ဒါပေမယ့် ဒါတစ်ခုတည်းသော ကွာခြားချက်တော့ မဟုတ်ပါဘူး။",
			correct: true
		}
	]}
/>

### ၃။ token classification problem တစ်ခုမှာ words တွေကို tokenize လုပ်ပြီး tokens တွေကို label လုပ်ချင်တဲ့အခါ ဘယ်ပြဿနာ ဖြစ်ပေါ်လာသလဲ။

<Question
	choices={[
		{
			text: "tokenizer က special tokens တွေ ထည့်ပေးပြီး ၎င်းတို့အတွက် labels တွေ မရှိပါဘူး။",
			explain: "ကျွန်တော်တို့ ၎င်းတို့ကို <code>-100</code> လို့ label လုပ်တာကြောင့် loss မှာ ignore လုပ်ပါတယ်။"
		},
		{
			text: "word တစ်လုံးစီက tokens အများအပြားကို ထုတ်လုပ်နိုင်တာကြောင့် labels တွေထက် tokens တွေ ပိုများလာပါတယ်။",
			explain: "ဒါက အဓိကပြဿနာဖြစ်ပြီး၊ ကျွန်တော်တို့ original labels တွေကို tokens တွေနဲ့ align လုပ်ဖို့ လိုအပ်ပါတယ်။",
			correct: true
		},
		{
			text: "ထည့်သွင်းထားတဲ့ tokens တွေမှာ labels တွေ မရှိတာကြောင့် ပြဿနာ မရှိပါဘူး။",
			explain: "ဒါက မမှန်ပါဘူး၊ ကျွန်တော်တို့မှာ tokens အရေအတွက်အတိုင်း labels တွေ လိုအပ်ပါတယ်၊ မဟုတ်ရင် ကျွန်တော်တို့ models တွေ error ဖြစ်ပါလိမ့်မယ်။"
		}
	]}
/>

### ၄။ "Domain adaptation" ဆိုတာ ဘာကိုဆိုလိုသလဲ။

<Question
	choices={[
		{
			text: "dataset တစ်ခုပေါ်မှာ model တစ်ခုကို run ပြီး အဲဒီ dataset ထဲက sample တစ်ခုစီအတွက် predictions တွေ ရယူတာ။",
			explain: "မမှန်ပါဘူး၊ ဒါက inference ကို run တာပါပဲ။"
		},
		{
			text: "dataset တစ်ခုပေါ်မှာ model တစ်ခုကို train လုပ်တာ။",
			explain: "မမှန်ပါဘူး၊ ဒါက model တစ်ခုကို training လုပ်တာပါ၊ ဒီနေရာမှာ adaptation မရှိပါဘူး။"
		},
		{
			text: "pretrained model တစ်ခုကို dataset အသစ်တစ်ခုပေါ်မှာ fine-tune လုပ်ပြီး၊ အဲဒီ dataset အတွက် ပိုမိုသင့်လျော်တဲ့ predictions တွေ ပေးတာ။",
			explain: "မှန်ပါတယ်။ model က သူ့ရဲ့ အသိပညာကို dataset အသစ်နဲ့ လိုက်လျောညီထွေဖြစ်အောင် လုပ်လိုက်တာပါ။",
            correct: true
		},
        {
			text: "model ကို ပိုမို robust ဖြစ်အောင်လုပ်ဖို့ dataset ထဲကို misclassified samples တွေ ထည့်သွင်းတာ။",
			explain: "သင်က သင့် model ကို ပုံမှန် retrain လုပ်ရင် ဒါက သေချာပေါက် လုပ်သင့်တဲ့အရာပါ၊ ဒါပေမယ့် ဒါက domain adaptation မဟုတ်ပါဘူး။"
		}
	]}
/>

### ၅။ Masked language modeling problem မှာ labels တွေက ဘာတွေလဲ။

<Question
	choices={[
		{
			text: "input sentence ထဲက tokens အချို့ကို random အနေနဲ့ mask လုပ်ထားပြီး labels တွေက original input tokens တွေပါ။",
			explain: "မှန်ပါပြီ။",
            correct: true
		},
		{
			text: "input sentence ထဲက tokens အချို့ကို random အနေနဲ့ mask လုပ်ထားပြီး labels တွေက original input tokens တွေဖြစ်ကာ၊ ဘယ်ဘက်ကို shifting လုပ်ထားပါတယ်။",
			explain: "မမှန်ပါဘူး၊ labels တွေကို ဘယ်ဘက်ကို shifting လုပ်တာက နောက်ထပ် word ကို ခန့်မှန်းတာနဲ့ ကိုက်ညီပြီး၊ ဒါက causal language modeling ပါ။"
		},
		{
			text: "input sentence ထဲက tokens အချို့ကို random အနေနဲ့ mask လုပ်ထားပြီး၊ label က sentence ဟာ positive ဖြစ်မဖြစ် ဒါမှမဟုတ် negative ဖြစ်မဖြစ်ပါ။",
			explain: "ဒါက sequence classification problem တစ်ခုဖြစ်ပြီး data augmentation အချို့ပါဝင်ပါတယ်၊ masked language modeling မဟုတ်ပါဘူး။"
		},
        {
			text: "input sentences နှစ်ခုထဲက tokens အချို့ကို random အနေနဲ့ mask လုပ်ထားပြီး၊ label က sentences နှစ်ခုဟာ ဆင်တူခြင်း ရှိမရှိပါ။",
			explain: "ဒါက sequence classification problem တစ်ခုဖြစ်ပြီး data augmentation အချို့ပါဝင်ပါတယ်၊ masked language modeling မဟုတ်ပါဘူး။"
		}
	]}
/>

### ၆။ အောက်ပါ tasks တွေထဲက ဘယ်ဟာတွေကို sequence-to-sequence problem အဖြစ် မြင်နိုင်သလဲ။

<Question
	choices={[
		{
			text: "ရှည်လျားတဲ့ documents တွေရဲ့ အတိုချုပ် reviews တွေ ရေးသားတာ။",
			explain: "ဟုတ်ပါတယ်၊ ဒါက summarization problem တစ်ခုပါ။ တခြားအဖြေတစ်ခု စမ်းကြည့်ပါ။",
            correct: true
		},
		{
			text: "document တစ်ခုနဲ့ပတ်သက်ပြီး မေးခွန်းတွေ ဖြေတာ။",
			explain: "ဒါက sequence-to-sequence problem အဖြစ် ပုံဖော်နိုင်ပါတယ်။ ဒါပေမယ့် ဒါတစ်ခုတည်းသော အဖြေမှန်တော့ မဟုတ်ပါဘူး။",
            correct: true
		},
		{
			text: "Chinese text တစ်ခုကို English လို ဘာသာပြန်တာ။",
			explain: "ဒါက သေချာပေါက် sequence-to-sequence problem တစ်ခုပါပဲ။ တခြားတစ်ခုကို တွေ့နိုင်မလား။",
            correct: true
		},
        {
			text: "ကျွန်ုပ်ရဲ့ တူလေး/သူငယ်ချင်း ပို့တဲ့ မက်ဆေ့ခ်ျတွေကို မှန်ကန်တဲ့ English ဖြစ်အောင် ပြင်ဆင်တာ။",
			explain: "ဒါက ဘာသာပြန်ခြင်း ပြဿနာတစ်မျိုးဖြစ်တာကြောင့် သေချာပေါက် sequence-to-sequence task ပါ။ ဒါပေမယ့် ဒါတစ်ခုတည်းတော့ အဖြေမှန် မဟုတ်ပါဘူး!",
			correct: true
		}
	]}
/>

### ၇။ sequence-to-sequence problem အတွက် data ကို မှန်ကန်စွာ preprocess လုပ်ဖို့ နည်းလမ်းက ဘာလဲ။

<Question
	choices={[
		{
			text: "inputs တွေနဲ့ targets တွေကို <code>inputs=...</code> နဲ့ <code>targets=...</code> နဲ့ tokenizer ကို အတူတူ ပေးပို့ရမယ်။",
			explain: "ဒါက အနာဂတ်မှာ ကျွန်တော်တို့ ထည့်သွင်းမယ့် API တစ်ခု ဖြစ်နိုင်ပေမယ့်၊ အခုတော့ မရပါသေးဘူး။"
		},
		{
			text: "inputs တွေနဲ့ targets တွေ နှစ်ခုလုံးကို tokenizer ကို သီးခြားစီ ခေါ်ဆိုမှုနှစ်ခုနဲ့ preprocess လုပ်ရမယ်။",
			explain: "ဒါက မှန်ပေမယ့် မပြည့်စုံပါဘူး။ tokenizer က နှစ်ခုလုံးကို မှန်ကန်စွာ လုပ်ဆောင်နိုင်ဖို့ သင်လုပ်ရမယ့်အရာတစ်ခု ရှိပါတယ်။"
		},
		{
			text: "ပုံမှန်အတိုင်း၊ inputs တွေကိုပဲ tokenize လုပ်ရပါမယ်။",
			explain: "sequence classification problem မှာတော့ မဟုတ်ပါဘူး။ targets တွေကလည်း ကျွန်တော်တို့ numbers တွေအဖြစ် ပြောင်းလဲဖို့ လိုအပ်တဲ့ texts တွေပါပဲ!"
		},
        {
			text: "inputs တွေကို tokenizer ကို ပေးပို့ရမယ်၊ targets တွေကိုလည်း ပေးပို့ရမယ်၊ ဒါပေမယ့် special context manager အောက်မှာ ပေးပို့ရမယ်။",
			explain: "မှန်ပါတယ်။ tokenizer ကို အဲဒီ context manager က target mode ထဲကို ထည့်ဖို့ လိုအပ်ပါတယ်။",
			correct: true
		}
	]}
/>

{#if fw === 'pt'}

### ၈။ sequence-to-sequence problems တွေအတွက် <code>Trainer</code> ရဲ့ သီးခြား subclass တစ်ခု ဘာကြောင့် ရှိတာလဲ။

<Question
	choices={[
		{
			text: "sequence-to-sequence problems တွေက <code>-100</code> လို့ သတ်မှတ်ထားတဲ့ labels တွေကို ignore လုပ်ဖို့ custom loss တစ်ခု အသုံးပြုတာကြောင့်။",
			explain: "ဒါက custom loss မဟုတ်ပါဘူး၊ loss ကို အမြဲတမ်း တွက်ချက်တဲ့ နည်းလမ်းပါပဲ။"
		},
		{
			text: "sequence-to-sequence problems တွေက special evaluation loop တစ်ခု လိုအပ်တာကြောင့်။",
			explain: "မှန်ပါတယ်။ Sequence-to-sequence models ရဲ့ predictions တွေကို <code>generate()</code> method ကို အသုံးပြုပြီး မကြာခဏ run ပါတယ်။",
			correct: true
		},
		{
			text: "sequence-to-sequence problems တွေမှာ targets တွေက texts တွေ ဖြစ်နေတာကြောင့်။",
			explain: "<code>Trainer</code> က ဒါကို သိပ်ဂရုမစိုက်ပါဘူး၊ ဘာလို့လဲဆိုတော့ ၎င်းတို့ကို အရင်က preprocess လုပ်ပြီးသား ဖြစ်လို့ပါ။"
		},
        {
			text: "sequence-to-sequence problems တွေမှာ models နှစ်ခုကို အသုံးပြုတာကြောင့်။",
			explain: "ကျွန်တော်တို့ encoder နဲ့ decoder ဆိုပြီး models နှစ်ခုကို အသုံးပြုတာ မှန်ပါတယ်၊ ဒါပေမယ့် ၎င်းတို့ကို model တစ်ခုတည်းမှာ အတူတကွ ပေါင်းစည်းထားပါတယ်။"
		}
	]}
/>

{:else}

### ၉။ Transformer model တစ်ခုပေါ်မှာ `compile()` ကို ခေါ်ဆိုတဲ့အခါ loss ကို သတ်မှတ်ဖို့ မလိုအပ်တာ ဘာကြောင့်လဲ။

<Question
	choices={[
		{
			text: "Transformer models တွေကို unsupervised learning နဲ့ train လုပ်ထားတာကြောင့်။",
			explain: "မမှန်ပါဘူး -- unsupervised learning တောင်မှ loss function တစ်ခု လိုအပ်ပါသေးတယ်!"
		},
		{
			text: "model ရဲ့ internal loss output ကို default အနေနဲ့ အသုံးပြုတာကြောင့်။",
			explain: "မှန်ပါတယ်။",
			correct: true
		},
		{
			text: "training လုပ်ပြီးမှ metrics တွေကို တွက်ချက်တာကြောင့်။",
			explain: "ကျွန်တော်တို့ အဲဒီလို လုပ်တာ မကြာခဏ မှန်ပါတယ်၊ ဒါပေမယ့် training မှာ ကျွန်တော်တို့ optimize လုပ်တဲ့ loss value ကို ဘယ်ကနေ ရသလဲဆိုတာ ရှင်းပြတာ မဟုတ်ပါဘူး။"
		},
        {
			text: "<code>model.fit()</code> မှာ loss ကို သတ်မှတ်တာကြောင့်။",
			explain: "မမှန်ပါဘူး၊ loss function ကို `model.compile()` run ပြီးတာနဲ့ အမြဲတမ်း fix လုပ်ထားတာဖြစ်ပြီး `model.fit()` မှာ ပြောင်းလဲလို့ မရပါဘူး။"
		}
	]}
/>

{/if}

### ၁၀။ model အသစ်တစ်ခုကို ဘယ်အချိန်မှာ pretrain လုပ်သင့်လဲ။

<Question
	choices={[
		{
			text: "သင့်ရဲ့ သီးခြားဘာသာစကားအတွက် pretrained model မရနိုင်တဲ့အခါ။",
			explain: "မှန်ပါတယ်။",
			correct: true
		},
		{
			text: "သင့်မှာ data အများကြီး ရနိုင်ပေမယ့်၊ အဲဒါနဲ့ အလုပ်လုပ်နိုင်မယ့် pretrained model တစ်ခု ရှိနေရင်တောင်။",
			explain: "ဒီကိစ္စမှာတော့၊ ကြီးမားတဲ့ compute costs တွေကို ရှောင်ရှားဖို့အတွက် pretrained model ကို အသုံးပြုပြီး သင့် data ပေါ်မှာ fine-tune လုပ်သင့်ပါတယ်။"
		},
		{
			text: "သင်အသုံးပြုနေတဲ့ pretrained model ရဲ့ ဘက်လိုက်မှုအပေါ် စိုးရိမ်ပူပန်မှုတွေ ရှိတဲ့အခါ။",
			explain: "ဒါက မှန်ပါတယ်၊ ဒါပေမယ့် training အတွက် အသုံးပြုမယ့် data ဟာ တကယ်ကောင်းတယ်ဆိုတာ သေချာစေရပါမယ်။",
			correct: true
		},
        {
			text: "ရနိုင်တဲ့ pretrained models တွေက မလုံလောက်တဲ့အခါ။",
			explain: "သင်ရဲ့ training ကို ကောင်းကောင်း debug လုပ်ခဲ့ပြီလားဆိုတာ သေချာရဲ့လား။"
		}
	]}
/>

### ၁၁။ language model တစ်ခုကို texts အများကြီးပေါ်မှာ pretrain လုပ်ဖို့ ဘာကြောင့် လွယ်ကူတာလဲ။

<Question
	choices={[
		{
			text: "အင်တာနက်ပေါ်မှာ texts တွေ အများကြီး ရရှိနိုင်တာကြောင့်။",
			explain: "မှန်ပေမယ့်၊ ဒါက မေးခွန်းကို တကယ်ဖြေတာ မဟုတ်ပါဘူး။ ထပ်ကြိုးစားပါ။"
		},
		{
			text: "pretraining objective က data ကို လူသားတွေက label လုပ်ဖို့ မလိုအပ်တာကြောင့်။",
			explain: "မှန်ပါတယ်။ language modeling ဟာ self-supervised problem တစ်ခုပါ။",
			correct: true
		},
		{
			text: "🤗 Transformers library က training ကို စတင်ဖို့ code လိုင်းအနည်းငယ်ပဲ လိုအပ်တာကြောင့်။",
			explain: "မှန်ပေမယ့်၊ ဒါက မေးထားတဲ့ မေးခွန်းကို တကယ်ဖြေတာ မဟုတ်ပါဘူး။ တခြားအဖြေတစ်ခု စမ်းကြည့်ပါ။"
		}
	]}
/>

### ၁၂။ question answering task အတွက် data ကို preprocess လုပ်တဲ့အခါ အဓိက စိန်ခေါ်မှုတွေက ဘာတွေလဲ။

<Question
	choices={[
		{
			text: "inputs တွေကို tokenize လုပ်ဖို့ လိုပါတယ်။",
			explain: "မှန်ပါတယ်၊ ဒါပေမယ့် ဒါက တကယ် အဓိက စိန်ခေါ်မှုတစ်ခုလား။"
		},
		{
			text: "အလွန်ရှည်လျားတဲ့ contexts တွေကို ကိုင်တွယ်ဖြေရှင်းဖို့ လိုပါတယ်။ ဒါတွေက training features အများအပြားကို ဖြစ်ပေါ်စေပြီး အဖြေပါဝင်နိုင်ချေ ရှိသလို မရှိဘဲလည်း ဖြစ်နိုင်ပါတယ်။",
			explain: "ဒါက သေချာပေါက် စိန်ခေါ်မှုတွေထဲက တစ်ခုပါပဲ။",
			correct: true
		},
		{
			text: "မေးခွန်းရဲ့ အဖြေတွေကိုရော inputs တွေကိုပါ tokenize လုပ်ဖို့ လိုပါတယ်။",
			explain: "မမှန်ပါဘူး၊ သင်ရဲ့ question answering problem ကို sequence-to-sequence task အဖြစ် ပုံဖော်ထားတာမဟုတ်ရင်ပေါ့။"
		},
       {
			text: "text ထဲက answer span ကနေ၊ tokenized input ထဲက start နဲ့ end token ကို ရှာရပါမယ်။",
			explain: "ဟုတ်ပါတယ်၊ ဒါက ခက်ခဲတဲ့ အပိုင်းတွေထဲက တစ်ခုပါပဲ။",
			correct: true
		}
	]}
/>

### ၁၃။ question answering မှာ post-processing ကို ပုံမှန်အားဖြင့် ဘယ်လိုလုပ်ဆောင်သလဲ။

<Question
	choices={[
		{
			text: "model က အဖြေရဲ့ start နဲ့ end positions တွေကို ပေးပါတယ်၊ ပြီးတော့ သင်ဟာ သက်ဆိုင်ရာ tokens span ကို decode လုပ်ဖို့ပဲ လိုပါတယ်။",
			explain: "ဒါက လုပ်ဆောင်နိုင်တဲ့ နည်းလမ်းတစ်ခု ဖြစ်နိုင်ပေမယ့်၊ နည်းနည်းရိုးရှင်းလွန်းပါတယ်။"
		},
		{
			text: "model က example တစ်ခုကနေ ဖန်တီးထားတဲ့ feature တစ်ခုစီအတွက် အဖြေရဲ့ start နဲ့ end positions တွေကို ပေးပါတယ်၊ ပြီးတော့ သင်ဟာ အကောင်းဆုံး score ရှိတဲ့ အဲဒီ feature အတွက် context ထဲက သက်ဆိုင်ရာ tokens span ကို decode လုပ်ဖို့ပဲ လိုပါတယ်။",
			explain: "ဒါက ကျွန်တော်တို့ လေ့လာခဲ့တဲ့ post-processing နဲ့ နီးစပ်ပေမယ့်၊ လုံးဝမှန်ကန်တာတော့ မဟုတ်ပါဘူး။"
		},
		{
			text: "model က example တစ်ခုကနေ ဖန်တီးထားတဲ့ feature တစ်ခုစီအတွက် အဖြေရဲ့ start နဲ့ end positions တွေကို ပေးပါတယ်၊ ပြီးတော့ သင်ဟာ အကောင်းဆုံး score ရှိတဲ့ အဲဒီ feature အတွက် context ထဲက span ကို ကိုက်ညီအောင် လုပ်ဖို့ပဲ လိုပါတယ်။",
			explain: "ဒါက အနှစ်ချုပ်ပါပဲ!",
			correct: true
		},
        {
			text: "model က အဖြေတစ်ခုကို generate လုပ်ပါတယ်၊ ပြီးတော့ သင်ဟာ အဲဒါကို decode လုပ်ဖို့ပဲ လိုပါတယ်။",
			explain: "မမှန်ပါဘူး၊ သင်ရဲ့ question answering problem ကို sequence-to-sequence task အဖြစ် ပုံဖော်ထားတာမဟုတ်ရင်ပေါ့။"
		}
	]}
/>

## ဝေါဟာရ ရှင်းလင်းချက် (Glossary)

*   **Token Classification Problem**: စာသား sequence တစ်ခုအတွင်းရှိ token တစ်ခုစီကို အမျိုးအစားခွဲခြားသတ်မှတ်ခြင်း လုပ်ငန်း (ဥပမာ- Named Entity Recognition)။
*   **Grammatical Components**: စာကြောင်းတစ်ကြောင်းအတွင်းရှိ သဒ္ဒါဆိုင်ရာ အစိတ်အပိုင်းများ (ဥပမာ- noun, verb, adjective)။
*   **Sequence Classification Problem**: စာသား sequence တစ်ခုလုံးကို သတ်မှတ်ထားသော အမျိုးအစားတစ်ခုသို့ ခွဲခြားသတ်မှတ်ခြင်း လုပ်ငန်း။
*   **Named Entity Recognition (NER)**: စာသားထဲက လူအမည်၊ နေရာအမည်၊ အဖွဲ့အစည်းအမည် စတဲ့ သီးခြားအမည်တွေကို ရှာဖွေဖော်ထုတ်ခြင်း။
*   **Preprocessing Pipelines**: AI မော်ဒယ်များအတွက် ဒေတာများကို ပြင်ဆင်ရန် အဆင့်ဆင့်လုပ်ဆောင်ရသော လုပ်ငန်းစဉ်များ။
*   **Tokenize**: စာသား (သို့မဟုတ် အခြားဒေတာ) ကို AI မော်ဒယ်များ စီမံဆောင်ရွက်နိုင်ရန် tokens တွေအဖြစ် ပိုင်းခြားပေးသည့် လုပ်ငန်းစဉ်။
*   **Subword Tokenization Model**: စကားလုံးများကို သေးငယ်သော subword units (ဥပမာ- word pieces, byte-pair encodings) များအဖြစ် ပိုင်းခြားသော model။
*   **Full Tokenization Pipeline**: စာသားကို tokens များအဖြစ် ပြောင်းလဲရန် လိုအပ်သော အဆင့်များအားလုံး (ဥပမာ- splitting, subword tokenization, special token addition)။
*   **Special Tokens**: Model များအတွက် အထူးအဓိပ္ပာယ်ရှိသော tokens များ (ဥပမာ- `[CLS]`, `[SEP]`, `[PAD]`)။
*   **`-100` (Label)**: Loss တွက်ချက်မှုတွင် လျစ်လျူရှုရန် သတ်မှတ်ထားသော label တန်ဖိုး။
*   **Truncate**: input sequence ကို အရှည်သတ်မှတ်ချက်တစ်ခုအထိ ဖြတ်တောက်ခြင်း။
*   **Pad**: input sequence များကို သတ်မှတ်ထားသော အရှည်အထိ တူညီအောင် အပို tokens များထည့်သွင်းခြင်း။
*   **Labels**: AI မော်ဒယ်ကို လေ့ကျင့်ရာတွင် အသုံးပြုသော မှန်ကန်သည့် output တန်ဖိုးများ။
*   **Original Labels**: preprocessing မလုပ်မီက ဒေတာနှင့် တွဲလျက်ပါရှိသော မူရင်း labels များ။
*   **Align Labels**: original labels များကို tokenization ပြုလုပ်ပြီးနောက် ရရှိလာသော tokens များနှင့် ကိုက်ညီအောင် ချိန်ညှိခြင်း။
*   **Domain Adaptation**: မော်ဒယ်တစ်ခုကို မူလလေ့ကျင့်ထားသော domain မှ ကွဲပြားခြားနားသော domain အသစ်တစ်ခုတွင် ပိုမိုကောင်းမွန်စွာ လုပ်ဆောင်နိုင်စေရန် ချိန်ညှိခြင်း။
*   **Inference**: လေ့ကျင့်ပြီးသား Artificial Intelligence (AI) မော်ဒယ်တစ်ခုကို အသုံးပြုပြီး input data ကနေ ခန့်မှန်းချက်တွေ ဒါမှမဟုတ် output တွေကို ထုတ်လုပ်တဲ့ လုပ်ငန်းစဉ်။
*   **Fine-tune**: ကြိုတင်လေ့ကျင့်ထားပြီးသား (pre-trained) မော်ဒယ်တစ်ခုကို သီးခြားလုပ်ငန်းတစ်ခု (specific task) အတွက် အနည်းငယ်သော ဒေတာနဲ့ ထပ်မံလေ့ကျင့်ပေးခြင်းကို ဆိုလိုပါတယ်။
*   **Robust**: မတူညီသော input များ သို့မဟုတ် အခြေအနေများအောက်တွင် ကောင်းစွာလုပ်ဆောင်နိုင်ခြင်း။
*   **Masked Language Modeling (MLM)**: စာကြောင်းတစ်ခုထဲမှ စကားလုံးအချို့ကို ဝှက်ထားပြီး ၎င်းတို့ကို ခန့်မှန်းစေခြင်းဖြင့် model ကို လေ့ကျင့်သော task (BERT ကဲ့သို့)။
*   **Input Sentence**: model သို့ ပေးပို့သော စာကြောင်း။
*   **Randomly Masked**: ကျပန်းရွေးချယ်ထားသော စကားလုံးများကို ဖုံးကွယ်ထားခြင်း။
*   **Original Input Tokens**: mask မလုပ်မီက မူရင်း input sequence ရှိ tokens များ။
*   **Causal Language Modeling**: စာကြောင်းတစ်ခု၏ နောက်ဆက်တွဲ token (စကားလုံး) ကို ခန့်မှန်းခြင်းဖြင့် model ကို လေ့ကျင့်သော task (GPT-2 ကဲ့သို့)။
*   **Data Augmentation**: Training data ကို အမျိုးမျိုးသော နည်းလမ်းများဖြင့် တိုးချဲ့ခြင်း။
*   **Sequence-to-sequence Problem**: input sequence တစ်ခုမှ output sequence တစ်ခုသို့ ပြောင်းလဲခြင်း လုပ်ငန်း (ဥပမာ- translation, summarization)။
*   **Summarization**: ရှည်လျားသော စာသားတစ်ခု၏ အနှစ်ချုပ်ကို ထုတ်လုပ်ခြင်း။
*   **Question Answering Problem**: ပေးထားသော စာသားတစ်ခုမှ မေးခွန်းတစ်ခု၏ အဖြေကို ရှာဖွေခြင်း။
*   **Translation Problem**: ဘာသာစကားတစ်ခုမှ အခြားဘာသာစကားတစ်ခုသို့ စာသားများကို ဘာသာပြန်ခြင်း။
*   **Inputs**: model သို့ ပေးပို့သော ဒေတာ။
*   **Targets**: model ၏ လိုချင်သော output များ (labels)။
*   **Context Manager (Python)**: `with` statement ကို အသုံးပြု၍ အရင်းအမြစ်များကို စီမံခန့်ခွဲရန် ကူညီပေးသော Python အင်္ဂါရပ်။
*   **`Trainer`**: Hugging Face Transformers library မှ model များကို လေ့ကျင့်ရန်အတွက် မြင့်မားသောအဆင့် (high-level) API။
*   **Custom Loss**: ပုံမှန် loss function မဟုတ်ဘဲ သီးခြားလိုအပ်ချက်များအတွက် ဖန်တီးထားသော loss function။
*   **Evaluation Loop**: model ၏ စွမ်းဆောင်ရည်ကို အကဲဖြတ်ရန် လုပ်ဆောင်သော လုပ်ငန်းစဉ်။
*   **`generate()` Method**: Sequence-to-sequence models များတွင် text ကို generate (ထုတ်လုပ်) ရန် အသုံးပြုသော method။
*   **Encoder**: Transformer Architecture ၏ အစိတ်အပိုင်းတစ်ခုဖြစ်ပြီး input data (ဥပမာ- စာသား) ကို နားလည်ပြီး ကိုယ်စားပြုတဲ့ အချက်အလက် (representation) အဖြစ် ပြောင်းလဲပေးပါတယ်။
*   **Decoder**: Transformer Architecture ၏ အစိတ်အပိုင်းတစ်ခုဖြစ်ပြီး encoder ကနေ ရရှိတဲ့ အချက်အလက် (representation) ကို အသုံးပြုပြီး output data (ဥပမာ- ဘာသာပြန်ထားတဲ့ စာသား) ကို ထုတ်ပေးပါတယ်။
*   **`compile()` Method**: Keras API တွင် model ကို training အတွက် ပြင်ဆင်ရန် အသုံးပြုသော method။ ၎င်းသည် optimizer, loss function နှင့် metrics များကို သတ်မှတ်သည်။
*   **Unsupervised Learning**: Labels မပါဝင်သော data များကို အသုံးပြု၍ model ကို လေ့ကျင့်ခြင်း။
*   **Loss Function**: Model ၏ ခန့်မှန်းချက်များနှင့် အမှန်တကယ် labels များကြား ကွာခြားမှုကို တိုင်းတာသော function။
*   **`model.internal_loss_output`**: model ၏အတွင်းပိုင်းမှ ထုတ်လုပ်သော loss တန်ဖိုး။
*   **`model.fit()`**: Keras API တွင် model ကို training data ဖြင့် လေ့ကျင့်ရန် အသုံးပြုသော method။
*   **Pretrain a New Model**: မည်သည့် ကြိုတင်လေ့ကျင့်မှုမျှ မရှိဘဲ လုံးဝအသစ်ကနေ model တစ်ခုကို လေ့ကျင့်ခြင်း။
*   **Compute Costs**: AI model များ လေ့ကျင့်ရန်အတွက် လိုအပ်သော ကွန်ပျူတာ အရင်းအမြစ်များ (CPU, GPU) ၏ ကုန်ကျစရိတ်။
*   **Self-supervised Problem**: Input data ကိုယ်တိုင်ကနေ labels တွေကို ဖန်တီးယူပြီး model ကို လေ့ကျင့်တဲ့ ပြဿနာ (ဥပမာ- language modeling)။
*   **Contexts (QA)**: မေးခွန်းရဲ့ အဖြေပါဝင်နိုင်တဲ့ ရှည်လျားသော စာသား။
*   **Training Features**: training အတွက် ပြင်ဆင်ထားသော input data ၏ အစိတ်အပိုင်းများ။
*   **Answer Span**: မေးခွန်းရဲ့ အဖြေပါဝင်တဲ့ text ထဲက အပိုင်း။
*   **Start/End Token**: answer span ရဲ့ စတင်တဲ့ token နဲ့ ဆုံးဖြတ်တဲ့ token ရဲ့ အနေအထား။
*   **Post-processing**: Model ၏ output များကို နောက်ဆုံးအသုံးပြုမှုအတွက် ပြင်ဆင်ခြင်း လုပ်ငန်းစဉ်။
*   **Decode**: token IDs များကို မူရင်းစာသား (သို့မဟုတ် အခြားပုံစံ) အဖြစ် ပြန်လည်ပြောင်းလဲခြင်း။
*   **Score**: Model က ခန့်မှန်းချက်တစ်ခုအတွက် ပေးသော ယုံကြည်စိတ်ချရမှု တန်ဖိုး။