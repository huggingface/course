<FrameworkSwitchCourse {fw} />

# ဘာသာပြန်ခြင်း[[translation]]

{#if fw === 'pt'}

<CourseFloatingBanner chapter={7}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter7/section4_pt.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter7/section4_pt.ipynb"},
]} />

{:else}

<CourseFloatingBanner chapter={7}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter7/section4_tf.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter7/section4_tf.ipynb"},
]} />

{/if}

အခု ဘာသာပြန်ခြင်းထဲကို နက်နက်နဲနဲ လေ့လာကြည့်ရအောင်။ ဒါက နောက်ထပ် [sequence-to-sequence task](/course/chapter1/7) တစ်ခုဖြစ်ပြီး၊ ဒါဟာ sequence တစ်ခုကနေ နောက်တစ်ခုကို သွားတဲ့ ပြဿနာတစ်ခုအဖြစ် ဖော်စပ်နိုင်ပါတယ်။ ဒီသဘောအရ ပြဿနာက [summarization](/course/chapter7/6) နဲ့ အတော်လေး နီးစပ်ပြီး၊ ဒီနေရာမှာ ကျွန်တော်တို့ တွေ့ရမယ့်အရာတွေကို အခြား sequence-to-sequence problem တွေအတွက် လိုက်လျောညီထွေ ပြုပြင်နိုင်ပါတယ်၊ ဥပမာ...

-   **Style transfer**: သတ်မှတ်ထားတဲ့ style နဲ့ ရေးသားထားတဲ့ texts တွေကို တခြား style (ဥပမာ - formal ကနေ casual ဒါမှမဟုတ် Shakespearean English ကနေ modern English) ကို *ဘာသာပြန်* ပေးမယ့် model တစ်ခုကို ဖန်တီးခြင်း။
-   **Generative question answering**: context တစ်ခုပေးထားပြီး မေးခွန်းတွေအတွက် အဖြေတွေကို ထုတ်ပေးမယ့် model တစ်ခုကို ဖန်တီးခြင်း။

<Youtube id="1JvfrvZgi6c"/>

သင့်မှာ ဘာသာစကားနှစ်ခု (သို့မဟုတ် ထို့ထက်ပိုသော) ဖြင့် ကြီးမားသော texts corpus တစ်ခုရှိတယ်ဆိုရင်၊ [causal language modeling](/course/chapter7/6) အပိုင်းမှာ ကျွန်တော်တို့ လုပ်ဆောင်မှာလိုပဲ translation model အသစ်တစ်ခုကို အစကနေ train လုပ်နိုင်ပါတယ်။ သို့သော်လည်း၊ ရှိပြီးသား translation model တစ်ခုကို fine-tune လုပ်တာက ပိုမြန်ပါလိမ့်မယ်။ ဥပမာ - သင်ဟာ သီးခြား language pair တစ်ခုအတွက် fine-tune လုပ်ချင်တဲ့ mT5 ဒါမှမဟုတ် mBART လို multilingual model တစ်ခု၊ ဒါမှမဟုတ် သင့်ရဲ့ သီးခြား corpus အတွက် fine-tune လုပ်ချင်တဲ့ ဘာသာစကားတစ်ခုကနေ တခြားဘာသာစကားတစ်ခုကို ဘာသာပြန်ဖို့အတွက် အထူးပြု model တစ်ခု ဖြစ်နိုင်ပါတယ်။

ဒီအပိုင်းမှာ၊ [KDE4 dataset](https://huggingface.co/datasets/kde4) ပေါ်မှာ English ကနေ French ကို ဘာသာပြန်ဖို့ pretrained လုပ်ထားတဲ့ Marian model တစ်ခုကို fine-tune လုပ်ပါမယ် (Hugging Face ဝန်ထမ်းအများစုက ဘာသာစကားနှစ်ခုလုံးကို ပြောတတ်လို့ပါ)။ KDE4 dataset ဟာ [KDE apps](https://apps.kde.org/) အတွက် localized files တွေရဲ့ dataset တစ်ခုပါ။ ကျွန်တော်တို့ အသုံးပြုမယ့် model ကို [Opus dataset](https://opus.nlpl.eu/) ကနေ ယူထားတဲ့ French နဲ့ English texts ကြီးမားတဲ့ corpus တစ်ခုပေါ်မှာ pretrained လုပ်ခဲ့တာဖြစ်ပြီး၊ အဲဒီ Opus dataset ထဲမှာ KDE4 dataset ပါဝင်ပါတယ်။ ဒါပေမယ့် ကျွန်တော်တို့ အသုံးပြုမယ့် pretrained model က ၎င်းရဲ့ pretraining အတွင်းမှာ အဲဒီ data တွေကို တွေ့မြင်ခဲ့ရဖူးရင်တောင်မှ၊ fine-tuning လုပ်ပြီးနောက်မှာ ပိုကောင်းတဲ့ version တစ်ခုကို ရရှိနိုင်တယ်ဆိုတာ ကျွန်တော်တို့ တွေ့မြင်ရပါလိမ့်မယ်။

ကျွန်တော်တို့ ပြီးစီးသွားတာနဲ့၊ ဒီလိုမျိုး predictions တွေ လုပ်ဆောင်နိုင်တဲ့ model တစ်ခု ရရှိပါလိမ့်မယ်။

<iframe src="https://course-demos-marian-finetuned-kde4-en-to-fr.hf.space" frameBorder="0" height="350" title="Gradio app" class="block dark:hidden container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

<a class="flex justify-center" href="/huggingface-course/marian-finetuned-kde4-en-to-fr">
<img class="block dark:hidden lg:w-3/5" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/modeleval-marian-finetuned-kde4-en-to-fr.png" alt="One-hot encoded labels for question answering."/>
<img class="hidden dark:block lg:w-3/5" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/modeleval-marian-finetuned-kde4-en-to-fr-dark.png" alt="One-hot encoded labels for question answering."/>
</a>

ယခင်အပိုင်းတွေမှာလိုပဲ၊ အောက်ပါ code ကို အသုံးပြုပြီး ကျွန်တော်တို့ train လုပ်ပြီး Hub ကို upload လုပ်မယ့် model ကို [ဒီနေရာမှာ](https://huggingface.co/huggingface-course/marian-finetuned-kde4-en-to-fr?text=This+plugin+allows+you+to+automatically+translate+web+pages+between+several+languages.) double-check လုပ်နိုင်ပါတယ်။

## ဒေတာများကို ပြင်ဆင်ခြင်း[[preparing-the-data]]

translation model တစ်ခုကို အစကနေ fine-tune လုပ်ဖို့ ဒါမှမဟုတ် train လုပ်ဖို့အတွက်၊ task နဲ့ သင့်လျော်တဲ့ dataset တစ်ခု ကျွန်တော်တို့ လိုအပ်ပါလိမ့်မယ်။ အရင်က ပြောခဲ့သလိုပဲ၊ ဒီအပိုင်းမှာ [KDE4 dataset](https://huggingface.co/datasets/kde4) ကို ကျွန်တော်တို့ အသုံးပြုပါမယ်။ ဒါပေမယ့် သင့်ရဲ့ ကိုယ်ပိုင် data ကို အသုံးပြုဖို့ code ကို အလွယ်တကူ ပြုပြင်ပြောင်းလဲနိုင်ပါတယ်၊ သင်ဘာသာပြန်လိုသော ဘာသာစကားနှစ်ခု (source and target) မှာ စာကြောင်းအတွဲများ ရှိသမျှကာလပတ်လုံးပေါ့။ သင့်ရဲ့ custom data ကို `Dataset` ထဲမှာ ဘယ်လို load လုပ်ရမလဲဆိုတာ မှတ်မိဖို့ လိုအပ်ရင် [Chapter 5](/course/chapter5) ကို ပြန်ကြည့်နိုင်ပါတယ်။

### KDE4 Dataset[[the-kde4-dataset]]

ပုံမှန်အတိုင်းပါပဲ၊ ကျွန်တော်တို့ရဲ့ dataset ကို `load_dataset()` function အသုံးပြုပြီး download လုပ်ပါတယ်။

```py
from datasets import load_dataset

raw_datasets = load_dataset("kde4", lang1="en", lang2="fr")
```

သင်ဟာ မတူညီတဲ့ language pair တစ်ခုနဲ့ အလုပ်လုပ်ချင်တယ်ဆိုရင်၊ ၎င်းတို့ရဲ့ codes တွေနဲ့ သတ်မှတ်နိုင်ပါတယ်။ ဒီ dataset အတွက် ဘာသာစကား ၉၂ မျိုး ရရှိနိုင်ပါတယ်။ ၎င်းတို့အားလုံးကို ၎င်းရဲ့ [dataset card](https://huggingface.co/datasets/kde4) ပေါ်ရှိ language tags များကို ချဲ့ထွင်ကြည့်ရှုခြင်းဖြင့် မြင်နိုင်ပါတယ်။

<img src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/language_tags.png" alt="Language available for the KDE4 dataset." width="100%">

dataset ကို ကြည့်ရအောင်...

```py
raw_datasets
```

```python out
DatasetDict({
    train: Dataset({
        features: ['id', 'translation'],
        num_rows: 210173
    })
})
```

ကျွန်တော်တို့မှာ စာကြောင်းအတွဲပေါင်း ၂၁၀,၁၇၃ ခုရှိပေမယ့်၊ split တစ်ခုတည်းမှာပဲ ရှိနေတာကြောင့် ကိုယ်ပိုင် validation set တစ်ခု ဖန်တီးဖို့ လိုအပ်ပါလိမ့်မယ်။ [Chapter 5](/course/chapter5) မှာ ကျွန်တော်တို့ တွေ့ခဲ့ရတဲ့အတိုင်း၊ `Dataset` မှာ ကျွန်တော်တို့ကို ကူညီပေးနိုင်တဲ့ `train_test_split()` method တစ်ခု ရှိပါတယ်။ reproducibility အတွက် seed တစ်ခု ပေးပါမယ်။

```py
split_datasets = raw_datasets["train"].train_test_split(train_size=0.9, seed=20)
split_datasets
```

```python out
DatasetDict({
    train: Dataset({
        features: ['id', 'translation'],
        num_rows: 189155
    })
    test: Dataset({
        features: ['id', 'translation'],
        num_rows: 21018
    })
})
```

`"test"` key ကို `"validation"` အဖြစ် ဒီလို ပြန်လည်နာမည်ပြောင်းနိုင်ပါတယ်။

```py
split_datasets["validation"] = split_datasets.pop("test")
```

အခု dataset ရဲ့ element တစ်ခုကို ကြည့်ရအောင်...

```py
split_datasets["train"][1]["translation"]
```

```python out
{'en': 'Default to expanded threads',
 'fr': 'Par défaut, développer les fils de discussion'}
```

ကျွန်တော်တို့ တောင်းဆိုခဲ့တဲ့ ဘာသာစကားနှစ်ခုတွဲထဲမှာ စာကြောင်းနှစ်ကြောင်းပါတဲ့ dictionary တစ်ခု ရရှိပါတယ်။ ဒီ dataset ရဲ့ ထူးခြားချက်တစ်ခုကတော့ နည်းပညာဆိုင်ရာ computer science ဝေါဟာရတွေ အပြည့်အစုံကို French ဘာသာနဲ့ ဘာသာပြန်ထားတာပါပဲ။ သို့သော်လည်း၊ French အင်ဂျင်နီယာတွေက စကားပြောတဲ့အခါ computer science-specific words တွေကို English နဲ့ပဲ ထားလေ့ရှိပါတယ်။ ဒီနေရာမှာ ဥပမာအားဖြင့်၊ "threads" ဆိုတဲ့ စကားလုံးက French စာကြောင်းမှာ ပေါ်လာနိုင်ပါတယ်၊ အထူးသဖြင့် နည်းပညာဆိုင်ရာ စကားပြောဆိုမှုတွေမှာပေါ့။ ဒါပေမယ့် ဒီ dataset မှာတော့ "fils de discussion" လို့ ပိုမှန်ကန်တဲ့ စကားလုံးနဲ့ ဘာသာပြန်ထားပါတယ်။ ကျွန်တော်တို့ အသုံးပြုမယ့် pretrained model က French နဲ့ English စာကြောင်းများစွာပါဝင်တဲ့ ပိုကြီးမားတဲ့ corpus တစ်ခုပေါ်မှာ pretrained လုပ်ထားတာဖြစ်ပြီး၊ စကားလုံးကို မူရင်းအတိုင်းထားခဲ့ခြင်းက ပိုလွယ်ကူတဲ့ ရွေးချယ်မှုတစ်ခုကို ရယူပါတယ်။

```py
from transformers import pipeline

model_checkpoint = "Helsinki-NLP/opus-mt-en-fr"
translator = pipeline("translation", model=model_checkpoint)
translator("Default to expanded threads")
```

```python out
[{'translation_text': 'Par défaut pour les threads élargis'}]
```

ဒီအပြုအမူရဲ့ နောက်ထပ်ဥပမာတစ်ခုကို "plugin" ဆိုတဲ့ စကားလုံးနဲ့ မြင်နိုင်ပါတယ်။ ဒါက တရားဝင် French စကားလုံး မဟုတ်ပေမယ့်၊ native speakers အများစုက နားလည်ပြီး ဘာသာပြန်ဖို့ စိတ်မပူပါဘူး။
KDE4 dataset မှာ ဒီစကားလုံးကို French ဘာသာနဲ့ ပိုမိုတရားဝင်တဲ့ "module d'extension" လို့ ဘာသာပြန်ထားပါတယ်-

```py
split_datasets["train"][172]["translation"]
```

```python out
{'en': 'Unable to import %1 using the OFX importer plugin. This file is not the correct format.',
 'fr': "Impossible d'importer %1 en utilisant le module d'extension d'importation OFX. Ce fichier n'a pas un format correct."}
```

သို့သော်လည်း၊ ကျွန်တော်တို့ရဲ့ pretrained model ကတော့ ကျစ်လျစ်ပြီး ရင်းနှီးပြီးသား English စကားလုံးကိုပဲ ဆုပ်ကိုင်ထားပါတယ်-

```py
translator(
    "Unable to import %1 using the OFX importer plugin. This file is not the correct format."
)
```

```python out
[{'translation_text': "Impossible d'importer %1 en utilisant le plugin d'importateur OFX. Ce fichier n'est pas le bon format."}]
```

ကျွန်တော်တို့ရဲ့ fine-tuned model က dataset ရဲ့ ဒီထူးခြားချက်တွေကို လက်ခံမလားဆိုတာ ကြည့်ရတာ စိတ်ဝင်စားစရာ ကောင်းပါလိမ့်မယ် (spoiler alert: လက်ခံပါလိမ့်မယ်)။

<Youtube id="0Oxphw4Q9fo"/>

> [!TIP]
> ✏️ **သင့်အလှည့်!** French မှာ မကြာခဏ အသုံးပြုတဲ့ နောက်ထပ် English စကားလုံးတစ်လုံးက "email" ဖြစ်ပါတယ်။ training dataset မှာ ဒီစကားလုံးကို အသုံးပြုထားတဲ့ ပထမဆုံး sample ကို ရှာပါ။ ဘယ်လို ဘာသာပြန်ထားလဲ။ pretrained model က အဲဒီ English စာကြောင်းကို ဘယ်လို ဘာသာပြန်လဲ။

### ဒေတာများကို စီမံဆောင်ရွက်ခြင်း[[processing-the-data]]

<Youtube id="XAR8jnZZuUs"/>

အခုဆိုရင် သင်ဟာ လုပ်ဆောင်ရမယ့် အဆင့်တွေကို သိပြီးဖြစ်ပါလိမ့်မယ်- texts တွေအားလုံးကို token IDs အစုအဝေးအဖြစ် ပြောင်းလဲဖို့ လိုအပ်ပါတယ်။ ဒါမှ model က ၎င်းတို့ကို နားလည်နိုင်မှာပါ။ ဒီ task အတွက်၊ inputs နဲ့ targets နှစ်ခုလုံးကို tokenize လုပ်ဖို့ လိုအပ်ပါလိမ့်မယ်။ ကျွန်တော်တို့ရဲ့ ပထမဆုံး task ကတော့ `tokenizer` object ကို ဖန်တီးဖို့ပါပဲ။ အရင်က ဖော်ပြခဲ့တဲ့အတိုင်း၊ Marian English to French pretrained model ကို ကျွန်တော်တို့ အသုံးပြုပါမယ်။ သင်ဟာ ဒီ code ကို အခြား language pair တစ်ခုနဲ့ စမ်းသပ်နေတယ်ဆိုရင်၊ model checkpoint ကို သေချာလိုက်လျောညီထွေ ပြုပြင်ပါ။ [Helsinki-NLP](https://huggingface.co/Helsinki-NLP) organization က multiple languages နဲ့ models ပေါင်း တစ်ထောင်ကျော်ကို ပံ့ပိုးပေးပါတယ်။

```python
from transformers import AutoTokenizer

model_checkpoint = "Helsinki-NLP/opus-mt-en-fr"
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint, return_tensors="pt")
```

သင်ဟာ `model_checkpoint` ကို [Hub](https://huggingface.co/models) က သင်နှစ်သက်တဲ့ model တစ်ခုခု ဒါမှမဟုတ် pretrained model နဲ့ tokenizer တစ်ခုကို သိမ်းဆည်းထားတဲ့ local folder တစ်ခုနဲ့လည်း အစားထိုးနိုင်ပါတယ်။

> [!TIP]
> 💡 သင်ဟာ mBART, mBART-50, ဒါမှမဟုတ် M2M100 လို multilingual tokenizer တစ်ခုကို အသုံးပြုနေတယ်ဆိုရင်၊ `tokenizer.src_lang` နဲ့ `tokenizer.tgt_lang` တို့ကို မှန်ကန်တဲ့ တန်ဖိုးတွေနဲ့ သတ်မှတ်ခြင်းဖြင့် သင့် inputs နဲ့ targets တွေရဲ့ language codes တွေကို tokenizer မှာ သတ်မှတ်ဖို့ လိုပါလိမ့်မယ်။

ကျွန်တော်တို့ရဲ့ data ကို ပြင်ဆင်တာက အလွန်ရိုးရှင်းပါတယ်။ မှတ်သားစရာ တစ်ခုတည်းသော အရာကတော့၊ tokenizer က output language (ဒီနေရာမှာ French) မှာရှိတဲ့ targets တွေကို စီမံဆောင်ရွက်တယ်ဆိုတာကို သေချာစေဖို့ လိုအပ်ပါတယ်။ ဒါကို tokenizer ရဲ့ `__call__` method ရဲ့ `text_targets` argument ကို targets တွေ ပေးခြင်းဖြင့် လုပ်ဆောင်နိုင်ပါတယ်။

ဒါက ဘယ်လိုအလုပ်လုပ်တယ်ဆိုတာ ကြည့်ဖို့၊ training set ထဲက ဘာသာစကားတစ်ခုစီရဲ့ sample တစ်ခုကို စီမံဆောင်ရွက်ကြည့်ရအောင်။

```python
en_sentence = split_datasets["train"][1]["translation"]["en"]
fr_sentence = split_datasets["train"][1]["translation"]["fr"]

inputs = tokenizer(en_sentence, text_target=fr_sentence)
inputs
```

```python out
{'input_ids': [47591, 12, 9842, 19634, 9, 0], 'attention_mask': [1, 1, 1, 1, 1, 1], 'labels': [577, 5891, 2, 3184, 16, 2542, 5, 1710, 0]}
```

ကျွန်တော်တို့ မြင်ရတဲ့အတိုင်း၊ output မှာ English စာကြောင်းနဲ့ ဆက်စပ်နေတဲ့ input IDs တွေ ပါဝင်နေပြီး၊ French စာကြောင်းနဲ့ ဆက်စပ်နေတဲ့ IDs တွေကတော့ `labels` field ထဲမှာ သိမ်းဆည်းထားပါတယ်။ သင် labels တွေကို tokenize လုပ်နေတယ်ဆိုတာကို ဖော်ပြဖို့ မေ့သွားရင်၊ ၎င်းတို့ကို input tokenizer က tokenize လုပ်ပါလိမ့်မယ်။ Marian model ရဲ့ ကိစ္စမှာတော့ ဒါက လုံးဝအဆင်ပြေမှာ မဟုတ်ပါဘူး။

```python
wrong_targets = tokenizer(fr_sentence)
print(tokenizer.convert_ids_to_tokens(wrong_targets["input_ids"]))
print(tokenizer.convert_ids_to_tokens(inputs["labels"]))
```

```python out
[' Par', ' dé', 'f', 'aut', ',', ' dé', 've', 'lop', 'per', ' les', ' fil', 's', ' de', ' discussion', '</s>']
[' Par', ' défaut', ',', ' développer', ' les', ' fils', ' de', ' discussion', '</s>']
```

ကျွန်တော်တို့ မြင်ရတဲ့အတိုင်း၊ French စာကြောင်းတစ်ခုကို preprocess လုပ်ဖို့ English tokenizer ကို အသုံးပြုခြင်းက tokens ပိုများစွာကို ရရှိစေပါတယ်။ ဘာလို့လဲဆိုတော့ tokenizer က French စကားလုံးတွေကို (English ဘာသာစကားမှာလည်း ပါဝင်တဲ့ "discussion" လို စကားလုံးတွေကလွဲလို့) မသိလို့ပါပဲ။

`inputs` က ကျွန်တော်တို့ရဲ့ ပုံမှန် keys တွေ (input IDs, attention mask စသည်) ပါဝင်တဲ့ dictionary တစ်ခုဖြစ်တဲ့အတွက်၊ နောက်ဆုံးအဆင့်ကတော့ datasets တွေပေါ်မှာ ကျွန်တော်တို့ အသုံးပြုမယ့် preprocessing function ကို သတ်မှတ်ဖို့ပါပဲ။

```python
max_length = 128


def preprocess_function(examples):
    inputs = [ex["en"] for ex in examples["translation"]]
    targets = [ex["fr"] for ex in examples["translation"]]
    model_inputs = tokenizer(
        inputs, text_target=targets, max_length=max_length, truncation=True
    )
    return model_inputs
```

ကျွန်တော်တို့ inputs နဲ့ outputs တွေအတွက် maximum length တူတူကို သတ်မှတ်ထားတာကို သတိပြုပါ။ ကျွန်တော်တို့ ကိုင်တွယ်နေတဲ့ texts တွေက အတော်လေး တိုတောင်းပုံရတာကြောင့်၊ ၁၂၈ ကို အသုံးပြုပါတယ်။

> [!TIP]
> 💡 သင်ဟာ T5 model (အထူးသဖြင့် `t5-xxx` checkpoints များထဲမှ တစ်ခု) ကို အသုံးပြုနေတယ်ဆိုရင်၊ model က input texts တွေမှာ `translate: English to French:` လိုမျိုး task ကို ဖော်ပြတဲ့ prefix တစ်ခု ပါဝင်ဖို့ မျှော်လင့်ပါလိမ့်မယ်။

> [!WARNING]
> ⚠️ ကျွန်တော်တို့ targets တွေရဲ့ attention mask ကို ဂရုမစိုက်ပါဘူး၊ ဘာလို့လဲဆိုတော့ model က အဲဒါကို မျှော်လင့်မှာ မဟုတ်လို့ပါ။ အဲဒီအစား၊ padding token နဲ့ ကိုက်ညီတဲ့ labels တွေကို `-100` အဖြစ် သတ်မှတ်ထားသင့်ပါတယ်။ ဒါမှ loss computation မှာ ၎င်းတို့ကို လျစ်လျူရှုနိုင်မှာပါ။ ဒါကို နောက်ပိုင်းမှာ ကျွန်တော်တို့ရဲ့ data collator က လုပ်ဆောင်ပေးပါလိမ့်မယ်။ ဘာလို့လဲဆိုတော့ ကျွန်တော်တို့ dynamic padding ကို အသုံးပြုနေလို့ပါ၊ ဒါပေမယ့် သင်ဒီနေရာမှာ padding ကို အသုံးပြုတယ်ဆိုရင်၊ padding token နဲ့ ကိုက်ညီတဲ့ labels အားလုံးကို `-100` အဖြစ် သတ်မှတ်ဖို့ preprocessing function ကို ပြင်ဆင်သင့်ပါတယ်။

အခုဆိုရင် ကျွန်တော်တို့ အဲဒီ preprocessing ကို dataset ရဲ့ splits အားလုံးပေါ်မှာ တစ်ခါတည်း အသုံးပြုနိုင်ပါပြီ-

```py
tokenized_datasets = split_datasets.map(
    preprocess_function,
    batched=True,
    remove_columns=split_datasets["train"].column_names,
)
```

data ကို preprocess လုပ်ပြီးတာနဲ့၊ ကျွန်တော်တို့ရဲ့ pretrained model ကို fine-tune လုပ်ဖို့ အဆင်သင့်ပါပဲ!

{#if fw === 'pt'}

## `Trainer` API ဖြင့် Model ကို Fine-tuning လုပ်ခြင်း[[fine-tuning-the-model-with-the-trainer-api]]

`Trainer` ကို အသုံးပြုတဲ့ code အမှန်တကယ်က အရင်ကနဲ့ တူတူပဲ ဖြစ်ပါလိမ့်မယ်၊ သေးငယ်တဲ့ ပြောင်းလဲမှုတစ်ခုပဲ ရှိပါမယ်- ဒီနေရာမှာ `Seq2SeqTrainer` ([`Seq2SeqTrainer`](https://huggingface.co/transformers/main_classes/trainer.html#seq2seqtrainer)) ကို ကျွန်တော်တို့ အသုံးပြုပါတယ်။ ဒါက `Trainer` ရဲ့ subclass တစ်ခုဖြစ်ပြီး၊ inputs တွေကနေ outputs တွေကို predict လုပ်ဖို့ `generate()` method ကို အသုံးပြုပြီး evaluation ကို မှန်ကန်စွာ ကိုင်တွယ်နိုင်စေပါလိမ့်မယ်။ metrics computation အကြောင်း ပြောတဲ့အခါ ဒါကို ပိုပြီး အသေးစိတ်လေ့လာပါမယ်။

ပထမဆုံးအနေနဲ့၊ fine-tune လုပ်ဖို့အတွက် အမှန်တကယ် model တစ်ခု လိုအပ်ပါတယ်။ ပုံမှန် `AutoModel` API ကို ကျွန်တော်တို့ အသုံးပြုပါမယ်။

```py
from transformers import AutoModelForSeq2SeqLM

model = AutoModelForSeq2SeqLM.from_pretrained(model_checkpoint)
```

{:else}

## Keras ဖြင့် Model ကို Fine-tuning လုပ်ခြင်း[[fine-tuning-the-model-with-keras]]

ပထမဆုံးအနေနဲ့၊ fine-tune လုပ်ဖို့အတွက် အမှန်တကယ် model တစ်ခု လိုအပ်ပါတယ်။ ပုံမှန် `AutoModel` API ကို ကျွန်တော်တို့ အသုံးပြုပါမယ်။

```py
from transformers import TFAutoModelForSeq2SeqLM

model = TFAutoModelForSeq2SeqLM.from_pretrained(model_checkpoint, from_pt=True)
```

<Tip warning={false}>

💡 `Helsinki-NLP/opus-mt-en-fr` checkpoint မှာ PyTorch weights တွေပဲ ရှိတာကြောင့်၊
`from_pretrained()` method မှာ `from_pt=True` argument ကို အသုံးပြုခြင်းမရှိဘဲ
model ကို load လုပ်ဖို့ ကြိုးစားရင် error ရပါလိမ့်မယ်။ သင် `from_pt=True` ကို သတ်မှတ်လိုက်တဲ့အခါ၊
library က PyTorch weights တွေကို အလိုအလျောက် download လုပ်ပြီး သင့်အတွက် convert လုပ်ပေးပါလိမ့်မယ်။
သင်တွေ့ရတဲ့အတိုင်း၊ 🤗 Transformers မှာ frameworks တွေကြား ပြောင်းလဲတာက အလွန်ရိုးရှင်းပါတယ်။

</Tip>

{/if}

ဒီတစ်ခါ ကျွန်တော်တို့ translation task ပေါ်မှာ train လုပ်ထားပြီးသား model တစ်ခုကို အသုံးပြုနေတာဖြစ်ပြီး အမှန်တကယ် အသုံးပြုနိုင်နေပြီဆိုတာကို သတိပြုပါ။ ဒါကြောင့် weights တွေ ပျောက်ဆုံးနေတာ ဒါမှမဟုတ် အသစ် initialized လုပ်ထားတဲ့ weights တွေအကြောင်း warning မရှိပါဘူး။

### Data Collation[[data-collation]]

dynamic batching အတွက် padding ကို ကိုင်တွယ်ဖို့ data collator တစ်ခု ကျွန်တော်တို့ လိုအပ်ပါလိမ့်မယ်။ [Chapter 3](/course/chapter3) မှာလိုမျိုး `DataCollatorWithPadding` ကို ဒီကိစ္စမှာ အသုံးပြုလို့ မရပါဘူး၊ ဘာလို့လဲဆိုတော့ အဲဒါက inputs တွေကို (input IDs, attention mask, token type IDs) ပဲ padding လုပ်ပေးလို့ပါ။ ကျွန်တော်တို့ရဲ့ labels တွေကိုလည်း labels တွေမှာ တွေ့ရတဲ့ maximum length အထိ padding လုပ်သင့်ပါတယ်။ ပြီးတော့၊ အရင်က ပြောခဲ့သလိုပဲ၊ labels တွေကို padding လုပ်ဖို့ အသုံးပြုတဲ့ padding value ကို `-100` အဖြစ် သတ်မှတ်သင့်ပါတယ်။ ဒါမှ အဲဒီ padded values တွေကို loss computation မှာ လျစ်လျူရှုနိုင်မှာပါ။

ဒါတွေအားလုံးကို [`DataCollatorForSeq2Seq`](https://huggingface.co/transformers/main_classes/data_collator.html#datacollatorforseq2seq) က လုပ်ဆောင်ပေးပါတယ်။ `DataCollatorWithPadding` လိုပဲ၊ ဒါက inputs တွေကို preprocess လုပ်ဖို့ အသုံးပြုတဲ့ `tokenizer` ကို ယူပါတယ်၊ ဒါပေမယ့် `model` ကိုလည်း ယူပါတယ်။ ဒါက ဘာလို့လဲဆိုတော့ ဒီ data collator က decoder input IDs တွေကို ပြင်ဆင်ပေးဖို့လည်း တာဝန်ရှိမှာပါ။ ဒါတွေက အစမှာ special token တစ်ခုနဲ့ labels တွေရဲ့ shift လုပ်ထားတဲ့ version တွေပါ။ ဒီ shift က မတူညီတဲ့ architectures တွေအတွက် အနည်းငယ်ကွာခြားစွာ လုပ်ဆောင်တာကြောင့်၊ `DataCollatorForSeq2Seq` က `model` object ကို သိဖို့ လိုအပ်ပါတယ်။

{#if fw === 'pt'}

```py
from transformers import DataCollatorForSeq2Seq

data_collator = DataCollatorForSeq2Seq(tokenizer, model=model)
```

{:else}

```py
from transformers import DataCollatorForSeq2Seq

data_collator = DataCollatorForSeq2Seq(tokenizer, model=model, return_tensors="tf")
```

{/if}

samples အနည်းငယ်ပေါ်မှာ ဒါကို စမ်းသပ်ကြည့်ဖို့၊ ကျွန်တော်တို့ရဲ့ tokenized training set က ဥပမာတွေ စာရင်းတစ်ခုပေါ်မှာ ဒါကို ခေါ်လိုက်ရုံပါပဲ။

```py
batch = data_collator([tokenized_datasets["train"][i] for i in range(1, 3)])
batch.keys()
```

```python out
dict_keys(['attention_mask', 'input_ids', 'labels', 'decoder_input_ids'])
```

ကျွန်တော်တို့ရဲ့ labels တွေကို batch ရဲ့ maximum length အထိ `-100` ကို အသုံးပြုပြီး padding လုပ်ထားခြင်းရှိမရှိ စစ်ဆေးနိုင်ပါတယ်။

```py
batch["labels"]
```

```python out
tensor([[  577,  5891,     2,  3184,    16,  2542,     5,  1710,     0,  -100,
          -100,  -100,  -100,  -100,  -100,  -100],
        [ 1211,     3,    49,  9409,  1211,     3, 29140,   817,  3124,   817,
           550,  7032,  5821,  7907, 12649,     0]])
```

ပြီးတော့ decoder input IDs တွေကိုလည်း ကြည့်နိုင်ပါတယ်၊ ဒါတွေက labels တွေရဲ့ shifted versions တွေဆိုတာကို မြင်နိုင်ပါလိမ့်မယ်။

```py
batch["decoder_input_ids"]
```

```python out
tensor([[59513,   577,  5891,     2,  3184,    16,  2542,     5,  1710,     0,
         59513, 59513, 59513, 59513, 59513, 59513],
        [59513,  1211,     3,    49,  9409,  1211,     3, 29140,   817,  3124,
           817,   550,  7032,  5821,  7907, 12649]])
```

ဒီနေရာမှာ ကျွန်တော်တို့ရဲ့ dataset ထဲက ပထမဆုံးနဲ့ ဒုတိယမြောက် elements တွေအတွက် labels တွေပါ။

```py
for i in range(1, 3):
    print(tokenized_datasets["train"][i]["labels"])
```

```python out
[577, 5891, 2, 3184, 16, 2542, 5, 1710, 0]
[1211, 3, 49, 9409, 1211, 3, 29140, 817, 3124, 817, 550, 7032, 5821, 7907, 12649, 0]
```

{#if fw === 'pt'}

ကျွန်တော်တို့ ဒီ `data_collator` ကို `Seq2SeqTrainer` ဆီ ပေးပါမယ်။ နောက်တစ်ဆင့်အနေနဲ့ metric ကို ကြည့်ရအောင်။

{:else}

အခု ကျွန်တော်တို့ ဒီ `data_collator` ကို အသုံးပြုပြီး ကျွန်တော်တို့ရဲ့ datasets တစ်ခုစီကို training အတွက် အဆင်သင့်ဖြစ်တဲ့ `tf.data.Dataset` အဖြစ် ပြောင်းလဲနိုင်ပါပြီ။

```python
tf_train_dataset = model.prepare_tf_dataset(
    tokenized_datasets["train"],
    collate_fn=data_collator,
    shuffle=True,
    batch_size=32,
)
tf_eval_dataset = model.prepare_tf_dataset(
    tokenized_datasets["validation"],
    collate_fn=data_collator,
    shuffle=False,
    batch_size=16,
)
```

{/if}

### Metrics[[metrics]]

<Youtube id="M05L1DhFqcw"/>

{#if fw === 'pt'}

`Seq2SeqTrainer` က ၎င်းရဲ့ superclass `Trainer` ကို ထပ်ထည့်ပေးတဲ့ feature ကတော့ evaluation ဒါမှမဟုတ် prediction လုပ်နေစဉ်အတွင်း `generate()` method ကို အသုံးပြုနိုင်ခြင်းပါပဲ။ training လုပ်နေစဉ်အတွင်း model က `decoder_input_ids` ကို အာရုံစိုက်မှု mask တစ်ခုနဲ့ အသုံးပြုပါလိမ့်မယ်။ ဒါက model က ခန့်မှန်းဖို့ ကြိုးစားနေတဲ့ token နောက်က tokens တွေကို မသုံးမိအောင် သေချာစေပြီး training ကို မြန်ဆန်စေပါတယ်။ inference လုပ်နေစဉ်အတွင်းမှာတော့ ကျွန်တော်တို့ labels တွေ မရှိတော့တဲ့အတွက် ဒါတွေကို အသုံးပြုနိုင်မှာ မဟုတ်ပါဘူး။ ဒါကြောင့် ကျွန်တော်တို့ရဲ့ model ကို ဒီ setup တူတူနဲ့ evaluate လုပ်တာက ကောင်းမွန်တဲ့ အကြံဥာဏ်တစ်ခုပါပဲ။

[Chapter 1](/course/chapter1/6) မှာ ကျွန်တော်တို့ တွေ့ခဲ့ရတဲ့အတိုင်း၊ decoder က tokens တွေကို တစ်ခုပြီးတစ်ခု ခန့်မှန်းခြင်းဖြင့် inference ကို လုပ်ဆောင်ပါတယ် — ဒါက 🤗 Transformers မှာ `generate()` method ကနေ နောက်ကွယ်မှာ အကောင်အထည်ဖော်ထားတာပါ။ ကျွန်တော်တို့ `predict_with_generate=True` လို့ သတ်မှတ်ထားရင် `Seq2SeqTrainer` က အဲဒီ method ကို evaluation အတွက် အသုံးပြုနိုင်စေပါလိမ့်မယ်။

{/if}

ဘာသာပြန်ခြင်းအတွက် အသုံးပြုတဲ့ ရိုးရာ metric ကတော့ [BLEU score](https://en.wikipedia.org/wiki/BLEU) ဖြစ်ပြီး၊ Kishore Papineni et al. ရေးသားခဲ့တဲ့ [၂၀၀၂ ခုနှစ် ဆောင်းပါး](https://aclanthology.org/P02-1040.pdf) မှာ မိတ်ဆက်ခဲ့တာပါ။ BLEU score က translation တွေဟာ ၎င်းတို့ရဲ့ labels တွေနဲ့ ဘယ်လောက်နီးစပ်သလဲဆိုတာကို အကဲဖြတ်ပါတယ်။ ဒါက model က ထုတ်ပေးတဲ့ outputs တွေရဲ့ နားလည်လွယ်မှု ဒါမှမဟုတ် သဒ္ဒါမှန်ကန်မှုကို တိုင်းတာတာမဟုတ်ပါဘူး၊ ဒါပေမယ့် generated outputs တွေထဲက စကားလုံးအားလုံးဟာ targets တွေမှာလည်း ပေါ်လာတယ်ဆိုတာကို သေချာစေဖို့ statistical rules တွေကို အသုံးပြုပါတယ်။ ဒါ့အပြင်၊ targets တွေမှာလည်း မထပ်တဲ့ စကားလုံးတွေ ထပ်ခါတလဲလဲ ပေါ်လာရင် (model က "the the the the the" လို စာကြောင်းတွေ ထုတ်မပေးအောင်) နဲ့ targets တွေမှာရှိတဲ့ စာကြောင်းတွေထက် ပိုတိုတဲ့ output စာကြောင်းတွေ (model က "the" လို စာကြောင်းတွေ ထုတ်မပေးအောင်) အတွက် အပြစ်ပေးတဲ့ rules တွေလည်း ရှိပါတယ်။

BLEU ရဲ့ အားနည်းချက်တစ်ခုကတော့ text ကို tokenized လုပ်ပြီးသားဖြစ်ဖို့ မျှော်လင့်ထားတာကြောင့်၊ မတူညီတဲ့ tokenizers တွေ အသုံးပြုတဲ့ models တွေကြား score တွေကို နှိုင်းယှဉ်ဖို့ ခက်ခဲပါတယ်။ ဒါကြောင့်၊ ဒီနေ့ခေတ် translation models တွေကို benchmarking လုပ်ရာမှာ အသုံးအများဆုံး metric က [SacreBLEU](https://github.com/mjpost/sacrebleu) ဖြစ်ပြီး၊ ဒါက tokenization step ကို standardization လုပ်ခြင်းဖြင့် ဒီအားနည်းချက် (နှင့် အခြားအားနည်းချက်များ) ကို ဖြေရှင်းပေးပါတယ်။ ဒီ metric ကို အသုံးပြုဖို့၊ ပထမဆုံး SacreBLEU library ကို install လုပ်ဖို့ လိုအပ်ပါလိမ့်မယ်။

```py
!pip install sacrebleu
```

ပြီးရင် [Chapter 3](/course/chapter3) မှာ လုပ်ခဲ့သလိုပဲ `evaluate.load()` မှတစ်ဆင့် load လုပ်နိုင်ပါတယ်။

```py
import evaluate

metric = evaluate.load("sacrebleu")
```

ဒီ metric က texts တွေကို inputs နဲ့ targets အဖြစ် ယူပါလိမ့်မယ်။ ဒါကို လက်ခံနိုင်ဖွယ်ရာ targets များစွာကို လက်ခံနိုင်အောင် ဒီဇိုင်းထုတ်ထားပါတယ်၊ ဘာလို့လဲဆိုတော့ တူညီတဲ့ စာကြောင်းတစ်ခုရဲ့ လက်ခံနိုင်ဖွယ် ဘာသာပြန်များစွာ ရှိတတ်လို့ပါပဲ — ကျွန်တော်တို့ အသုံးပြုနေတဲ့ dataset က တစ်ခုတည်းသာ ပံ့ပိုးပေးပေမယ့်၊ NLP မှာ labels အဖြစ် စာကြောင်းများစွာ ပေးထားတဲ့ datasets တွေကို တွေ့ရတာ မထူးဆန်းပါဘူး။ ဒါကြောင့်၊ predictions တွေက sentences စာရင်းတစ်ခု ဖြစ်သင့်ပြီး၊ references တွေကတော့ sentences စာရင်းများစွာပါဝင်တဲ့ စာရင်းတစ်ခု ဖြစ်သင့်ပါတယ်။

ဥပမာတစ်ခု စမ်းကြည့်ရအောင်...

```py
predictions = [
    "This plugin lets you translate web pages between several languages automatically."
]
references = [
    [
        "This plugin allows you to automatically translate web pages between several languages."
    ]
]
metric.compute(predictions=predictions, references=references)
```

```python out
{'score': 46.750469682990165,
 'counts': [11, 6, 4, 3],
 'totals': [12, 11, 10, 9],
 'precisions': [91.67, 54.54, 40.0, 33.33],
 'bp': 0.9200444146293233,
 'sys_len': 12,
 'ref_len': 13}
```

ဒါက 46.75 ရဲ့ BLEU score ကို ရရှိပြီး၊ ဒါက အတော်လေး ကောင်းမွန်ပါတယ်။ ဥပမာအနေနဲ့၊ ["Attention Is All You Need" စာတမ်း](https://arxiv.org/pdf/1706.03762.pdf) ထဲက မူရင်း Transformer model က English နဲ့ French ကြား အလားတူ translation task တစ်ခုမှာ 41.8 ရဲ့ BLEU score ကို ရရှိခဲ့ပါတယ်! (individual metrics တွေ (ဥပမာ- `counts` နဲ့ `bp`) အကြောင်း အသေးစိတ်အချက်အလက်တွေအတွက် [SacreBLEU repository](https://github.com/mjpost/sacrebleu/blob/078c440168c6adc89ba75fe6d63f0d922d42bcfe/sacrebleu/metrics/bleu.py#L74) ကို ကြည့်ပါ။) အခြားတစ်ဖက်မှာ၊ translation models တွေကနေ မကြာခဏ ထွက်လာတတ်တဲ့ ဆိုးရွားတဲ့ prediction အမျိုးအစားနှစ်ခု (ထပ်ခါတလဲလဲများစွာ ဒါမှမဟုတ် အလွန်တိုတောင်းခြင်း) နဲ့ စမ်းကြည့်ရင်၊ BLEU scores တွေ အတော်လေး ဆိုးရွားပါလိမ့်မယ်။

```py
predictions = ["This This This This"]
references = [
    [
        "This plugin allows you to automatically translate web pages between several languages."
    ]
]
metric.compute(predictions=predictions, references=references)
```

```python out
{'score': 1.683602693167689,
 'counts': [1, 0, 0, 0],
 'totals': [4, 3, 2, 1],
 'precisions': [25.0, 16.67, 12.5, 12.5],
 'bp': 0.10539922456186433,
 'sys_len': 4,
 'ref_len': 13}
```

```py
predictions = ["This plugin"]
references = [
    [
        "This plugin allows you to automatically translate web pages between several languages."
    ]
]
metric.compute(predictions=predictions, references=references)
```

```python out
{'score': 0.0,
 'counts': [2, 1, 0, 0],
 'totals': [2, 1, 0, 0],
 'precisions': [100.0, 100.0, 0.0, 0.0],
 'bp': 0.004086771438464067,
 'sys_len': 2,
 'ref_len': 13}
```

score က ၀ ကနေ ၁၀၀ အထိ ရှိနိုင်ပြီး၊ မြင့်လေ ကောင်းလေပါပဲ။

{#if fw === 'tf'}

model outputs ကနေ metric က အသုံးပြုနိုင်တဲ့ texts တွေ ရယူဖို့၊ ကျွန်တော်တို့ `tokenizer.batch_decode()` method ကို အသုံးပြုပါမယ်။ labels တွေထဲက `-100` တွေအားလုံးကို ရှင်းလင်းဖို့ပဲ လိုအပ်ပါတယ်၊ tokenizer က padding token အတွက်လည်း အလိုအလျောက် လုပ်ပေးပါလိမ့်မယ်။ ကျွန်တော်တို့ရဲ့ model နဲ့ dataset ကို ယူပြီး metrics တွေ တွက်ချက်ပေးမယ့် function တစ်ခုကို သတ်မှတ်ရအောင်။ ကျွန်တော်တို့ စွမ်းဆောင်ရည်ကို သိသိသာသာ တိုးတက်စေမယ့် နည်းလမ်းတစ်ခုကိုလည်း အသုံးပြုပါမယ် -- TensorFlow ရဲ့ accelerated linear algebra compiler ဖြစ်တဲ့ [XLA](https://www.tensorflow.org/xla) နဲ့ ကျွန်တော်တို့ရဲ့ generation code ကို compile လုပ်တာပါ။ XLA က model ရဲ့ computation graph ကို optimizations မျိုးစုံ အသုံးပြုပြီး speed နဲ့ memory usage မှာ သိသိသာသာ တိုးတက်မှုကို ရရှိစေပါတယ်။ Hugging Face [blog](https://huggingface.co/blog/tf-xla-generate) မှာ ဖော်ပြထားတဲ့အတိုင်း၊ XLA က ကျွန်တော်တို့ရဲ့ input shapes တွေ အများကြီး ကွဲပြားခြင်း မရှိတဲ့အခါ အကောင်းဆုံး အလုပ်လုပ်ပါတယ်။ ဒါကို ကိုင်တွယ်ဖို့အတွက်၊ ကျွန်တော်တို့ inputs တွေကို ၁၂၈ ရဲ့ multiples တွေအထိ padding လုပ်ပြီး၊ padding collator နဲ့ dataset အသစ်တစ်ခု ပြုလုပ်ပါမယ်၊ ပြီးတော့ XLA နဲ့ compile လုပ်ဖို့ function တစ်ခုလုံးကို မှတ်သားပေးမယ့် `@tf.function(jit_compile=True)` decorator ကို ကျွန်တော်တို့ရဲ့ generation function မှာ အသုံးပြုပါမယ်။

```py
import numpy as np
import tensorflow as tf
from tqdm import tqdm

generation_data_collator = DataCollatorForSeq2Seq(
    tokenizer, model=model, return_tensors="tf", pad_to_multiple_of=128
)

tf_generate_dataset = model.prepare_tf_dataset(
    tokenized_datasets["validation"],
    collate_fn=generation_data_collator,
    shuffle=False,
    batch_size=8,
)


@tf.function(jit_compile=True)
def generate_with_xla(batch):
    return model.generate(
        input_ids=batch["input_ids"],
        attention_mask=batch["attention_mask"],
        max_new_tokens=128,
    )


def compute_metrics():
    all_preds = []
    all_labels = []

    for batch, labels in tqdm(tf_generate_dataset):
        predictions = generate_with_xla(batch)
        decoded_preds = tokenizer.batch_decode(predictions, skip_special_tokens=True)
        labels = labels.numpy()
        labels = np.where(labels != -100, labels, tokenizer.pad_token_id)
        decoded_labels = tokenizer.batch_decode(labels, skip_special_tokens=True)
        decoded_preds = [pred.strip() for pred in decoded_preds]
        decoded_labels = [[label.strip()] for label in decoded_labels]
        all_preds.extend(decoded_preds)
        all_labels.extend(decoded_labels)

    result = metric.compute(predictions=all_preds, references=all_labels)
    return {"bleu": result["score"]}
```

{:else}

model outputs ကနေ metric က အသုံးပြုနိုင်တဲ့ texts တွေ ရယူဖို့၊ ကျွန်တော်တို့ `tokenizer.batch_decode()` method ကို အသုံးပြုပါမယ်။ labels တွေထဲက `-100` တွေအားလုံးကို ရှင်းလင်းဖို့ပဲ လိုအပ်ပါတယ် (tokenizer က padding token အတွက်လည်း အလိုအလျောက် လုပ်ပေးပါလိမ့်မယ်)။

```py
import numpy as np


def compute_metrics(eval_preds):
    preds, labels = eval_preds
    # In case the model returns more than the prediction logits
    if isinstance(preds, tuple):
        preds = preds[0]

    decoded_preds = tokenizer.batch_decode(preds, skip_special_tokens=True)

    # Replace -100s in the labels as we can't decode them
    labels = np.where(labels != -100, labels, tokenizer.pad_token_id)
    decoded_labels = tokenizer.batch_decode(labels, skip_special_tokens=True)

    # Some simple post-processing
    decoded_preds = [pred.strip() for pred in decoded_preds]
    decoded_labels = [[label.strip()] for label in decoded_labels]

    result = metric.compute(predictions=decoded_preds, references=decoded_labels)
    return {"bleu": result["score"]}
```

{/if}

အခု ဒါပြီးသွားတာနဲ့၊ ကျွန်တော်တို့ရဲ့ model ကို fine-tune လုပ်ဖို့ အဆင်သင့်ပါပဲ!

### Model ကို Fine-tuning လုပ်ခြင်း[[fine-tuning-the-model]]

ပထမဆုံးအဆင့်က Hugging Face ကို log in ဝင်ဖို့ပါပဲ။ ဒါမှ သင်ရဲ့ ရလဒ်တွေကို Model Hub ကို upload လုပ်နိုင်ပါလိမ့်မယ်။ notebook မှာ ဒါကို ကူညီပေးမယ့် convenience function တစ်ခုရှိပါတယ်-

```python
from huggingface_hub import notebook_login

notebook_login()
```

ဒါက သင့်ရဲ့ Hugging Face login credentials တွေကို ထည့်သွင်းနိုင်မယ့် widget တစ်ခုကို ပြသပါလိမ့်မယ်။

သင် notebook မှာ အလုပ်မလုပ်ဘူးဆိုရင်၊ သင့် terminal မှာ အောက်ပါစာကြောင်းကို ရိုက်ထည့်လိုက်ရုံပါပဲ-

```bash
huggingface-cli login
```

{#if fw === 'tf'}

မစတင်ခင်၊ training မလုပ်ဘဲ ကျွန်တော်တို့ရဲ့ model ကနေ ဘယ်လိုရလဒ်တွေ ရမလဲဆိုတာ ကြည့်ရအောင်-

```py
print(compute_metrics())
```

```
{'bleu': 33.26983701454733}
```

ဒါပြီးသွားတာနဲ့၊ ကျွန်တော်တို့ရဲ့ model ကို compile လုပ်ပြီး train လုပ်ဖို့ လိုအပ်သမျှအားလုံးကို ပြင်ဆင်နိုင်ပါပြီ။ `tf.keras.mixed_precision.set_global_policy("mixed_float16")` ကို အသုံးပြုတာကို သတိပြုပါ -- ဒါက Keras ကို float16 ကို အသုံးပြုပြီး train လုပ်ဖို့ ပြောပါလိမ့်မယ်။ ဒါက float16 ကို ထောက်ပံ့တဲ့ GPUs တွေမှာ (Nvidia 20xx/V100 ဒါမှမဟုတ် အသစ်တွေ) သိသိသာသာ speedup ကို ပေးနိုင်ပါတယ်။

```python
from transformers import create_optimizer
from transformers.keras_callbacks import PushToHubCallback
import tensorflow as tf

# The number of training steps is the number of samples in the dataset, divided by the batch size then multiplied
# by the total number of epochs. Note that the tf_train_dataset here is a batched tf.data.Dataset,
# not the original Hugging Face Dataset, so its len() is already num_samples // batch_size.
num_epochs = 3
num_train_steps = len(tf_train_dataset) * num_epochs

optimizer, schedule = create_optimizer(
    init_lr=5e-5,
    num_warmup_steps=0,
    num_train_steps=num_train_steps,
    weight_decay_rate=0.01,
)
model.compile(optimizer=optimizer)

# Train in mixed-precision float16
tf.keras.mixed_precision.set_global_policy("mixed_float16")
```

နောက်တစ်ဆင့်အနေနဲ့၊ training လုပ်နေစဉ်အတွင်း ကျွန်တော်တို့ရဲ့ model ကို Hub သို့ upload လုပ်ဖို့ `PushToHubCallback` တစ်ခုကို သတ်မှတ်ပါမယ်။ [အပိုင်း ၂](/course/chapter7/2) မှာ ကျွန်တော်တို့ တွေ့ခဲ့ရတဲ့အတိုင်း၊ ပြီးတော့ အဲဒီ callback နဲ့ model ကို ရိုးရှင်းစွာ fit လုပ်ပါမယ်-

```python
from transformers.keras_callbacks import PushToHubCallback

callback = PushToHubCallback(
    output_dir="marian-finetuned-kde4-en-to-fr", tokenizer=tokenizer
)

model.fit(
    tf_train_dataset,
    validation_data=tf_eval_dataset,
    callbacks=[callback],
    epochs=num_epochs,
)
```

သင် push လုပ်ချင်တဲ့ repository ရဲ့ နာမည်ကို `hub_model_id` argument နဲ့ သတ်မှတ်နိုင်တာကို သတိပြုပါ။ (အထူးသဖြင့်၊ organization တစ်ခုသို့ push လုပ်ဖို့အတွက် ဒီ argument ကို အသုံးပြုရပါလိမ့်မယ်)။ ဥပမာ၊ ကျွန်တော်တို့ model ကို [`huggingface-course` organization](https://huggingface.co/huggingface-course) ကို push လုပ်ခဲ့တဲ့အခါ၊ `hub_model_id="huggingface-course/marian-finetuned-kde4-en-to-fr"` ကို `Seq2SeqTrainingArguments` မှာ ထပ်ထည့်ခဲ့ပါတယ်။ default အားဖြင့်၊ အသုံးပြုတဲ့ repository က သင့် namespace မှာ ရှိပြီး သင်သတ်မှတ်ထားတဲ့ output directory ရဲ့ နာမည်ကို ယူပါလိမ့်မယ်။ ဒါကြောင့် ဒီနေရာမှာ `"sgugger/marian-finetuned-kde4-en-to-fr"` ဖြစ်ပါလိမ့်မယ် (ဒါက ဒီအပိုင်းအစမှာ ကျွန်တော်တို့ ချိတ်ဆက်ခဲ့တဲ့ model ပါပဲ)။

> [!TIP]
> 💡 သင်အသုံးပြုနေတဲ့ output directory က ရှိပြီးသားဆိုရင်၊ ဒါဟာ သင် push လုပ်ချင်တဲ့ repository ရဲ့ local clone တစ်ခု ဖြစ်ဖို့ လိုအပ်ပါတယ်။ မဟုတ်ဘူးဆိုရင်၊ `model.fit()` ကို ခေါ်တဲ့အခါ error ရပါလိမ့်မယ်။ ပြီးတော့ နာမည်အသစ်တစ်ခု သတ်မှတ်ဖို့ လိုအပ်ပါလိမ့်မယ်။

နောက်ဆုံးအနေနဲ့၊ training ပြီးဆုံးသွားပြီဆိုတော့ ကျွန်တော်တို့ရဲ့ metrics တွေ ဘယ်လိုပုံစံရှိလဲ ကြည့်ရအောင်။

```py
print(compute_metrics())
```

```
{'bleu': 57.334066271545865}
```

ဒီအဆင့်မှာ၊ Model Hub ပေါ်က inference widget ကို အသုံးပြုပြီး သင့် model ကို စမ်းသပ်နိုင်ပြီး သင့်သူငယ်ချင်းတွေနဲ့ မျှဝေနိုင်ပါပြီ။ သင်ဟာ translation task တစ်ခုပေါ်မှာ model တစ်ခုကို အောင်မြင်စွာ fine-tune လုပ်ခဲ့ပါပြီ -- ဂုဏ်ယူပါတယ်!

{:else}   ="no",
    save_strategy="epoch",
    learning_rate=2e-5,
    per_device_train_batch_size=32,
    per_device_eval_batch_size=64,
    weight_decay=0.01,
    save_total_limit=3,
    num_train_epochs=3,
    predict_with_generate=True,
    fp16=True,
    push_to_hub=True,
)
```

ပုံမှန် hyperparameters တွေ (learning rate, epochs အရေအတွက်, batch size, weight decay အချို့) ကလွဲလို့၊ ယခင်အပိုင်းတွေမှာ ကျွန်တော်တို့ တွေ့ခဲ့ရတာတွေနဲ့ နှိုင်းယှဉ်ရင် ဒီနေရာမှာ အပြောင်းအလဲအနည်းငယ် ရှိပါတယ်-

-   ကျွန်တော်တို့ ပုံမှန် evaluation ကို မသတ်မှတ်ပါဘူး၊ ဘာလို့လဲဆိုတော့ evaluation လုပ်တာက အချိန်အကြာကြီး ယူလို့ပါ။ training မလုပ်ခင်နဲ့ နောက်ပိုင်းမှာ model ကို တစ်ကြိမ်ပဲ evaluate လုပ်ပါမယ်။
-   `fp16=True` ကို ကျွန်တော်တို့ သတ်မှတ်ထားပါတယ်။ ဒါက modern GPUs တွေမှာ training ကို မြန်ဆန်စေပါတယ်။
-   အပေါ်မှာ ဆွေးနွေးခဲ့တဲ့အတိုင်း `predict_with_generate=True` ကို ကျွန်တော်တို့ သတ်မှတ်ထားပါတယ်။
-   epoch တစ်ခုစီရဲ့ အဆုံးမှာ model ကို Hub ကို upload လုပ်ဖို့ `push_to_hub=True` ကို ကျွန်တော်တို့ အသုံးပြုပါတယ်။

သင် push လုပ်ချင်တဲ့ repository ရဲ့ နာမည်အပြည့်အစုံကို `hub_model_id` argument နဲ့ သတ်မှတ်နိုင်တာကို သတိပြုပါ။ (အထူးသဖြင့်၊ organization တစ်ခုသို့ push လုပ်ဖို့အတွက် ဒီ argument ကို အသုံးပြုရပါလိမ့်မယ်)။ ဥပမာ၊ ကျွန်တော်တို့ model ကို [`huggingface-course` organization](https://huggingface.co/huggingface-course) ကို push လုပ်ခဲ့တဲ့အခါ၊ `hub_model_id="huggingface-course/marian-finetuned-kde4-en-to-fr"` ကို `Seq2SeqTrainingArguments` မှာ ထပ်ထည့်ခဲ့ပါတယ်။ default အားဖြင့်၊ အသုံးပြုတဲ့ repository က သင့် namespace မှာ ရှိပြီး သင်သတ်မှတ်ထားတဲ့ output directory ရဲ့ နာမည်ကို ယူပါလိမ့်မယ်။ ဒါကြောင့် ကျွန်တော်တို့ရဲ့ ကိစ္စမှာ `"sgugger/marian-finetuned-kde4-en-to-fr"` ဖြစ်ပါလိမ့်မယ် (ဒါက ဒီအပိုင်းအစမှာ ကျွန်တော်တို့ ချိတ်ဆက်ခဲ့တဲ့ model ပါပဲ)။

> [!TIP]
> 💡 သင်အသုံးပြုနေတဲ့ output directory က ရှိပြီးသားဆိုရင်၊ ဒါဟာ သင် push လုပ်ချင်တဲ့ repository ရဲ့ local clone တစ်ခု ဖြစ်ဖို့ လိုအပ်ပါတယ်။ မဟုတ်ဘူးဆိုရင်၊ သင် `Seq2SeqTrainer` ကို သတ်မှတ်တဲ့အခါ error ရပါလိမ့်မယ်။ ပြီးတော့ နာမည်အသစ်တစ်ခု သတ်မှတ်ဖို့ လိုအပ်ပါလိမ့်မယ်။

နောက်ဆုံးအနေနဲ့၊ ကျွန်တော်တို့ အရာအားလုံးကို `Seq2SeqTrainer` ကို ပေးလိုက်ရုံပါပဲ-

```python
from transformers import Seq2SeqTrainer

trainer = Seq2SeqTrainer(
    model,
    args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
)
```

training မလုပ်ခင်၊ ကျွန်တော်တို့ရဲ့ model ရရှိတဲ့ score ကို အရင်ဆုံး ကြည့်ပါမယ်။ ဒါမှ ကျွန်တော်တို့ fine-tuning နဲ့ အခြေအနေကို ပိုဆိုးအောင် မလုပ်မိဘူးဆိုတာ double-check လုပ်နိုင်ပါတယ်။ ဒီ command က အချိန်အနည်းငယ် ကြာပါလိမ့်မယ်၊ ဒါကြောင့် ဒါအလုပ်လုပ်နေစဉ် ကော်ဖီသောက်နိုင်ပါတယ်။

```python
trainer.evaluate(max_length=max_length)
```

```python out
{'eval_loss': 1.6964408159255981,
 'eval_bleu': 39.26865061007616,
 'eval_runtime': 965.8884,
 'eval_samples_per_second': 21.76,
 'eval_steps_per_second': 0.341}
```

BLEU score 39 က မဆိုးပါဘူး၊ ဒါက ကျွန်တော်တို့ရဲ့ model က English စာကြောင်းတွေကို French စာကြောင်းတွေအဖြစ် ဘာသာပြန်ရာမှာ ကောင်းမွန်နေပြီးသားဆိုတာကို ထင်ဟပ်ပါတယ်။

နောက်တစ်ဆင့်က training ဖြစ်ပြီး၊ ဒါကလည်း အချိန်အနည်းငယ် ကြာပါလိမ့်မယ်။

```python
trainer.train()
```

training လုပ်နေစဉ်အတွင်း၊ model ကို save လုပ်တဲ့အခါတိုင်း (ဒီနေရာမှာ၊ epoch တိုင်း) ဒါကို Hub ကို နောက်ကွယ်မှာ upload လုပ်ပါတယ်ဆိုတာ သတိပြုပါ။ ဒီနည်းနဲ့၊ လိုအပ်ရင် အခြား machine တစ်ခုပေါ်မှာ သင်ရဲ့ training ကို ပြန်လည်စတင်နိုင်ပါလိမ့်မယ်။

training ပြီးတာနဲ့၊ ကျွန်တော်တို့ model ကို ထပ်မံ evaluate လုပ်ပါမယ် — BLEU score မှာ တိုးတက်မှုအချို့ တွေ့ရဖို့ မျှော်လင့်ပါတယ်!

```py
trainer.evaluate(max_length=max_length)
```

```python out
{'eval_loss': 0.8558505773544312,
 'eval_bleu': 52.94161337775576,
 'eval_runtime': 714.2576,
 'eval_samples_per_second': 29.426,
 'eval_steps_per_second': 0.461,
 'epoch': 3.0}
```

ဒါက ၁၄ မှတ်နီးပါး တိုးတက်လာတာဖြစ်ပြီး၊ ဒါဟာ အကောင်းဆုံးပါပဲ။

နောက်ဆုံးအနေနဲ့၊ model ရဲ့ နောက်ဆုံး version ကို upload လုပ်ဖို့ `push_to_hub()` method ကို အသုံးပြုပါတယ်။ `Trainer` က evaluation results တွေ အားလုံးပါဝင်တဲ့ model card draft တစ်ခုကိုလည်း ရေးဆွဲပြီး upload လုပ်ပါတယ်။ ဒီ model card မှာ inference demo အတွက် widget ကို ရွေးချယ်ဖို့ Model Hub ကို ကူညီပေးတဲ့ metadata တွေ ပါဝင်ပါတယ်။ ပုံမှန်အားဖြင့်၊ model class ကနေ မှန်ကန်တဲ့ widget ကို ခန့်မှန်းနိုင်တာကြောင့် ဘာမှပြောစရာ မလိုပါဘူး၊ ဒါပေမယ့် ဒီကိစ္စမှာတော့ sequence-to-sequence problem မျိုးစုံအတွက် model class တူတူကို အသုံးပြုနိုင်တာကြောင့်၊ ဒါက translation model တစ်ခုဖြစ်တယ်လို့ ကျွန်တော်တို့ သတ်မှတ်ပါတယ်။

```py
trainer.push_to_hub(tags="translation", commit_message="Training complete")
```

ဒီ command က သင်စစ်ဆေးကြည့်ချင်တယ်ဆိုရင် ဒါက လုပ်ဆောင်ခဲ့တဲ့ commit ရဲ့ URL ကို ပြန်ပေးပါတယ်-

```python out
'https://huggingface.co/sgugger/marian-finetuned-kde4-en-to-fr/commit/3601d621e3baae2bc63d3311452535f8f58f6ef3'
```

ဒီအဆင့်မှာ၊ Model Hub ပေါ်က inference widget ကို အသုံးပြုပြီး သင့် model ကို စမ်းသပ်နိုင်ပြီး သင့်သူငယ်ချင်းတွေနဲ့ မျှဝေနိုင်ပါပြီ။ သင်ဟာ translation task တစ်ခုပေါ်မှာ model တစ်ခုကို အောင်မြင်စွာ fine-tune လုပ်ခဲ့ပါပြီ -- ဂုဏ်ယူပါတယ်!

သင် training loop ကို နက်နက်နဲနဲ လေ့လာချင်တယ်ဆိုရင်၊ 🤗 Accelerate ကို အသုံးပြုပြီး အဲဒီအရာကို ဘယ်လိုလုပ်ရမလဲဆိုတာ အခု ကျွန်တော်တို့ ပြသပါမယ်။

{/if}

{#if fw === 'pt'}

## Custom Training Loop တစ်ခု[[a-custom-training-loop]]

အခု ပြည့်စုံတဲ့ training loop ကို ကြည့်ရအောင်၊ ဒါမှ သင်လိုအပ်တဲ့ အစိတ်အပိုင်းတွေကို အလွယ်တကူ customize လုပ်နိုင်ပါလိမ့်မယ်။ ဒါက [အပိုင်း ၂](/course/chapter7/2) နဲ့ [Chapter 3](/course/chapter3) မှာ ကျွန်တော်တို့ လုပ်ခဲ့တဲ့အရာတွေနဲ့ အတော်လေး တူပါလိမ့်မယ်။

### Training အတွက် အားလုံးကို ပြင်ဆင်ခြင်း[[preparing-everything-for-training]]

ဒါတွေအားလုံးကို အခုဆိုရင် သင်အကြိမ်အနည်းငယ် တွေ့ခဲ့ဖူးပြီးသားဖြစ်တဲ့အတွက်၊ code ကို အလွန်လျင်မြန်စွာပဲ ကြည့်သွားပါမယ်။ ပထမဆုံးအနေနဲ့ datasets တွေကို `"torch"` format ကို သတ်မှတ်ပြီး PyTorch tensors တွေ ရရှိအောင်လုပ်ပြီးနောက် datasets တွေကနေ `DataLoader` တွေကို တည်ဆောက်ပါမယ်။

```py
from torch.utils.data import DataLoader

tokenized_datasets.set_format("torch")
train_dataloader = DataLoader(
    tokenized_datasets["train"],
    shuffle=True,
    collate_fn=data_collator,
    batch_size=8,
)
eval_dataloader = DataLoader(
    tokenized_datasets["validation"], collate_fn=data_collator, batch_size=8
)
```

နောက်တစ်ဆင့်အနေနဲ့ ကျွန်တော်တို့ရဲ့ model ကို reinstantiate လုပ်ပါမယ်။ ဒါမှ ကျွန်တော်တို့ အရင်က fine-tuning ကို ဆက်မလုပ်ဘဲ pretrained model ကနေ ပြန်စတာ သေချာစေပါလိမ့်မယ်။

```py
model = AutoModelForSeq2SeqLM.from_pretrained(model_checkpoint)
```

ပြီးရင် optimizer တစ်ခု လိုအပ်ပါလိမ့်မယ်။

```py
from torch.optim import AdamW

optimizer = AdamW(model.parameters(), lr=2e-5)
```

ဒီ objects တွေအားလုံး ရရှိပြီဆိုတာနဲ့၊ ဒါတွေကို `accelerator.prepare()` method ဆီ ပေးပို့နိုင်ပါပြီ။ သင် Colab notebook မှာ TPUs ပေါ်မှာ train လုပ်ချင်တယ်ဆိုရင်၊ ဒီ code အားလုံးကို training function တစ်ခုထဲကို ရွှေ့ဖို့ လိုအပ်မယ်ဆိုတာနဲ့ `Accelerator` ကို instantiate လုပ်တဲ့ cell တစ်ခုကိုမှ မ run သင့်ဘူးဆိုတာ မှတ်ထားပါ။

```py
from accelerate import Accelerator

accelerator = Accelerator()
model, optimizer, train_dataloader, eval_dataloader = accelerator.prepare(
    model, optimizer, train_dataloader, eval_dataloader
)
```

ကျွန်တော်တို့ `train_dataloader` ကို `accelerator.prepare()` ဆီ ပေးပို့ပြီးတာနဲ့၊ ၎င်းရဲ့ length ကို အသုံးပြုပြီး training steps အရေအတွက်ကို တွက်ချက်နိုင်ပါပြီ။ အဲဒီ method က `DataLoader` ရဲ့ length ကို ပြောင်းလဲစေမှာဖြစ်တဲ့အတွက်၊ dataloader ကို ပြင်ဆင်ပြီးမှ ဒါကို အမြဲတမ်းလုပ်သင့်တယ်ဆိုတာ မှတ်ထားပါ။ learning rate ကနေ ၀ အထိ classic linear schedule ကို ကျွန်တော်တို့ အသုံးပြုပါတယ်။

```py
from transformers import get_scheduler

num_train_epochs = 3
num_update_steps_per_epoch = len(train_dataloader)
num_training_steps = num_train_epochs * num_update_steps_per_epoch

lr_scheduler = get_scheduler(
    "linear",
    optimizer=optimizer,
    num_warmup_steps=0,
    num_training_steps=num_training_steps,
)
```

နောက်ဆုံးအနေနဲ့၊ ကျွန်တော်တို့ model ကို Hub ကို push လုပ်ဖို့အတွက်၊ working folder တစ်ခုမှာ `Repository` object တစ်ခု ဖန်တီးဖို့ လိုအပ်ပါလိမ့်မယ်။ ပထမဆုံး Hugging Face Hub ကို log in ဝင်ပါ၊ သင်မဝင်ရသေးဘူးဆိုရင်ပေါ့။ ကျွန်တော်တို့ရဲ့ model ကို ပေးချင်တဲ့ model ID ကနေ repository နာမည်ကို ကျွန်တော်တို့ သတ်မှတ်ပါမယ် (သင် `repo_name` ကို သင့်စိတ်ကြိုက် နာမည်နဲ့ လွတ်လပ်စွာ အစားထိုးနိုင်ပါတယ်၊ ဒါက သင့် username ပါဝင်ဖို့ပဲ လိုအပ်ပါတယ်၊ အဲဒါက `get_full_repo_name()` function က လုပ်ဆောင်တာပါပဲ)။

```py
from huggingface_hub import Repository, get_full_repo_name

model_name = "marian-finetuned-kde4-en-to-fr-accelerate"
repo_name = get_full_repo_name(model_name)
repo_name
```

```python out
'sgugger/marian-finetuned-kde4-en-to-fr-accelerate'
```

ပြီးရင် အဲဒီ repository ကို local folder တစ်ခုမှာ clone လုပ်နိုင်ပါတယ်။ အကယ်၍ ဒါက ရှိပြီးသားဆိုရင်၊ ဒီ local folder က ကျွန်တော်တို့ အလုပ်လုပ်နေတဲ့ repository ရဲ့ clone တစ်ခု ဖြစ်ရပါလိမ့်မယ်။

```py
output_dir = "marian-finetuned-kde4-en-to-fr-accelerate"
repo = Repository(output_dir, clone_from=repo_name)
```

အခု ကျွန်တော်တို့ `output_dir` ထဲမှာ သိမ်းဆည်းထားတဲ့ ဘာမဆိုကို `repo.push_to_hub()` method ကို ခေါ်ခြင်းဖြင့် upload လုပ်နိုင်ပါပြီ။ ဒါက epoch တစ်ခုစီရဲ့ အဆုံးမှာ intermediate models တွေကို upload လုပ်ဖို့ ကျွန်တော်တို့ကို ကူညီပေးပါလိမ့်မယ်။

### Training Loop[[training-loop]]

အခုဆိုရင် ပြည့်စုံတဲ့ training loop ကို ရေးဖို့ ကျွန်တော်တို့ အဆင်သင့်ပါပဲ။ ၎င်းရဲ့ evaluation အပိုင်းကို ရိုးရှင်းစေဖို့အတွက်၊ predictions နဲ့ labels တွေကို ယူပြီး ကျွန်တော်တို့ရဲ့ `metric` object က မျှော်လင့်ထားတဲ့ strings စာရင်းတွေအဖြစ် ပြောင်းလဲပေးမယ့် `postprocess()` function တစ်ခုကို ကျွန်တော်တို့ သတ်မှတ်ပါတယ်။

```py
def postprocess(predictions, labels):
    predictions = predictions.cpu().numpy()
    labels = labels.cpu().numpy()

    decoded_preds = tokenizer.batch_decode(predictions, skip_special_tokens=True)

    # Replace -100 in the labels as we can't decode them.
    labels = np.where(labels != -100, labels, tokenizer.pad_token_id)
    decoded_labels = tokenizer.batch_decode(labels, skip_special_tokens=True)

    # Some simple post-processing
    decoded_preds = [pred.strip() for pred in decoded_preds]
    decoded_labels = [[label.strip()] for label in decoded_labels]
    return decoded_preds, decoded_labels
```

training loop က [အပိုင်း ၂](/course/chapter7/2) နဲ့ [Chapter 3](/course/chapter3) ထဲက loop တွေနဲ့ အတော်လေး တူပါတယ်၊ evaluation အပိုင်းမှာ အနည်းငယ်ကွာခြားချက်တွေ ရှိပါတယ်။ — ဒါကြောင့် အဲဒါကို အာရုံစိုက်ရအောင်!

ပထမဆုံး မှတ်သားရမယ့်အချက်ကတော့ predictions တွေကို တွက်ချက်ဖို့ `generate()` method ကို ကျွန်တော်တို့ အသုံးပြုတာပါ၊ ဒါပေမယ့် ဒါက ကျွန်တော်တို့ရဲ့ base model ပေါ်က method တစ်ခုဖြစ်ပြီး၊ 🤗 Accelerate က `prepare()` method မှာ ဖန်တီးခဲ့တဲ့ wrapped model မဟုတ်ပါဘူး။ ဒါကြောင့် model ကို အရင် unwrap လုပ်ပြီးမှ ဒီ method ကို ခေါ်တာပါ။

ဒုတိယအချက်ကတော့ [token classification](/course/chapter7/2) နဲ့ တူတူပါပဲ၊ process နှစ်ခုက inputs နဲ့ labels တွေကို မတူညီတဲ့ shapes တွေအထိ padding လုပ်ထားနိုင်ပါတယ်။ ဒါကြောင့် `accelerator.pad_across_processes()` ကို အသုံးပြုပြီး predictions နဲ့ labels တွေကို `gather()` method ကို မခေါ်ခင် shapes တူတူဖြစ်အောင် လုပ်ပါတယ်။ ဒါကို မလုပ်ရင် evaluation က error ဖြစ်မှာ ဒါမှမဟုတ် အမြဲတမ်း hang နေပါလိမ့်မယ်။

```py
from tqdm.auto import tqdm
import torch

progress_bar = tqdm(range(num_training_steps))

for epoch in range(num_train_epochs):
    # Training
    model.train()
    for batch in train_dataloader:
        outputs = model(**batch)
        loss = outputs.loss
        accelerator.backward(loss)

        optimizer.step()
        lr_scheduler.step()
        optimizer.zero_grad()
        progress_bar.update(1)

    # Evaluation
    model.eval()
    for batch in tqdm(eval_dataloader):
        with torch.no_grad():
            generated_tokens = accelerator.unwrap_model(model).generate(
                batch["input_ids"],
                attention_mask=batch["attention_mask"],
                max_length=128,
            )
        labels = batch["labels"]

        # Necessary to pad predictions and labels for being gathered
        generated_tokens = accelerator.pad_across_processes(
            generated_tokens, dim=1, pad_index=tokenizer.pad_token_id
        )
        labels = accelerator.pad_across_processes(labels, dim=1, pad_index=-100)

        predictions_gathered = accelerator.gather(generated_tokens)
        labels_gathered = accelerator.gather(labels)

        decoded_preds, decoded_labels = postprocess(predictions_gathered, labels_gathered)
        metric.add_batch(predictions=decoded_preds, references=decoded_labels)

    results = metric.compute()
    print(f"epoch {epoch}, BLEU score: {results['score']:.2f}")

    # Save and upload
    accelerator.wait_for_everyone()
    unwrapped_model = accelerator.unwrap_model(model)
    unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)
    if accelerator.is_main_process:
        tokenizer.save_pretrained(output_dir)
        repo.push_to_hub(
            commit_message=f"Training in progress epoch {epoch}", blocking=False
        )
```

```python out
epoch 0, BLEU score: 53.47
epoch 1, BLEU score: 54.24
epoch 2, BLEU score: 54.44
```

ဒါပြီးသွားတာနဲ့၊ သင် `Seq2SeqTrainer` နဲ့ train လုပ်ခဲ့တဲ့ model နဲ့ ရလဒ်တွေ အတော်လေး ဆင်တူတဲ့ model တစ်ခု ရရှိပါလိမ့်မယ်။ ဒီ code ကို အသုံးပြုပြီး ကျွန်တော်တို့ train လုပ်ခဲ့တဲ့ model ကို [*huggingface-course/marian-finetuned-kde4-en-to-fr-accelerate*](https://huggingface.co/huggingface-course/marian-finetuned-kde4-en-to-fr-accelerate) မှာ စစ်ဆေးနိုင်ပါတယ်။ ပြီးတော့ training loop မှာ ပြောင်းလဲမှုအချို့ကို စမ်းသပ်ချင်တယ်ဆိုရင်၊ အပေါ်မှာ ပြသထားတဲ့ code ကို တိုက်ရိုက် edit လုပ်ပြီး အကောင်အထည်ဖော်နိုင်ပါတယ်!

{/if}

## Fine-tuned Model ကို အသုံးပြုခြင်း[[using-the-fine-tuned-model]]

Model Hub ပေါ်က inference widget နဲ့ ကျွန်တော်တို့ fine-tune လုပ်ထားတဲ့ model ကို ဘယ်လိုအသုံးပြုနိုင်တယ်ဆိုတာ သင်ပြသခဲ့ပြီးပါပြီ။ `pipeline` ထဲမှာ ဒါကို locally အသုံးပြုဖို့အတွက်၊ သင့်လျော်တဲ့ model identifier ကိုပဲ ကျွန်တော်တို့ သတ်မှတ်ဖို့ လိုအပ်ပါတယ်။

```py
from transformers import pipeline

# Replace this with your own checkpoint
model_checkpoint = "huggingface-course/marian-finetuned-kde4-en-to-fr"
translator = pipeline("translation", model=model_checkpoint)
translator("Default to expanded threads")
```

```python out
[{'translation_text': 'Par défaut, développer les fils de discussion'}]
```

မျှော်လင့်ထားတဲ့အတိုင်း၊ ကျွန်တော်တို့ရဲ့ pretrained model က ကျွန်တော်တို့ fine-tune လုပ်ခဲ့တဲ့ corpus နဲ့ ၎င်းရဲ့ ဗဟုသုတကို လိုက်လျောညီထွေဖြစ်အောင် လုပ်ခဲ့ပြီး၊ English စကားလုံး "threads" ကို မူရင်းအတိုင်းထားခဲ့ခြင်းအစား၊ အခု French တရားဝင် version အဖြစ် ဘာသာပြန်ပေးပါတယ်။ "plugin" အတွက်လည်း အတူတူပါပဲ။

```py
translator(
    "Unable to import %1 using the OFX importer plugin. This file is not the correct format."
)
```

```python out
[{'translation_text': "Impossible d'importer %1 en utilisant le module externe d'importation OFX. Ce fichier n'est pas le bon format."}]
```

Domain adaptation ရဲ့ နောက်ထပ် ကောင်းမွန်တဲ့ ဥပမာတစ်ခုပါပဲ!

> [!TIP]
> ✏️ **သင့်အလှည့်!** သင်အရင်က ဖော်ထုတ်ခဲ့တဲ့ "email" စကားလုံးပါတဲ့ sample ပေါ်မှာ model က ဘာပြန်ပေးမလဲ။

## ဝေါဟာရ ရှင်းလင်းချက် (Glossary)

*   **Translation**: ဘာသာစကားတစ်ခုမှ အခြားဘာသာစကားတစ်ခုသို့ စာသားများကို ဘာသာပြန်ခြင်း။
*   **Sequence-to-Sequence Task**: input sequence တစ်ခုမှ output sequence တစ်ခုကို ထုတ်လုပ်သော machine learning လုပ်ငန်း။
*   **Summarization**: ရှည်လျားသော စာသားတစ်ခု၏ အနှစ်ချုပ်ကို ထုတ်လုပ်ခြင်း။
*   **Style Transfer**: စာသားတစ်ခု၏ အကြောင်းအရာကို မပြောင်းလဲဘဲ ၎င်း၏ ရေးသားဟန် (style) ကို ပြောင်းလဲခြင်း။
*   **Generative Question Answering**: ပေးထားသော context ကို အခြေခံ၍ မေးခွန်းတစ်ခုအတွက် အဖြေအသစ်တစ်ခုကို ထုတ်လုပ်ပေးခြင်း။
*   **Corpus**: စာသား (သို့မဟုတ် အခြားဒေတာ) အစုအဝေးကြီးတစ်ခု။
*   **From Scratch**: မော်ဒယ် (သို့မဟုတ် tokenizer) တစ်ခုကို မည်သည့် အစောပိုင်းလေ့ကျင့်မှုမျှ မရှိဘဲ လုံးဝအသစ်ကနေ စတင်တည်ဆောက်ခြင်းနှင့် လေ့ကျင့်ခြင်း။
*   **Causal Language Modeling Pretraining**: စာကြောင်းတစ်ခု၏ နောက်ဆက်တွဲ token (စကားလုံး) ကို ခန့်မှန်းခြင်းဖြင့် model ကို လေ့ကျင့်သော task (GPT-2 ကဲ့သို့)။
*   **Fine-tune**: ကြိုတင်လေ့ကျင့်ထားပြီးသား (pre-trained) မော်ဒယ်တစ်ခုကို သီးခြားလုပ်ငန်းတစ်ခု (specific task) အတွက် အနည်းငယ်သော ဒေတာနဲ့ ထပ်မံလေ့ကျင့်ပေးခြင်းကို ဆိုလိုပါတယ်။
*   **Multilingual Model**: ဘာသာစကားများစွာကို နားလည်ပြီး လုပ်ဆောင်နိုင်သော model (ဥပမာ- mT5, mBART)။
*   **Language Pair**: ဘာသာပြန်ခြင်းအတွက် အသုံးပြုသော ဘာသာစကားနှစ်ခုတွဲ (ဥပမာ- English-French)။
*   **Marian Model**: Efficient Neural Machine Translation (NMT) အတွက် ဒီဇိုင်းထုတ်ထားသော Transformer-based model။
*   **Pretrained**: Model တစ်ခုကို အကြီးစားဒေတာများဖြင့် အစောပိုင်းကတည်းက လေ့ကျင့်ထားခြင်း။
*   **KDE4 Dataset**: KDE apps များအတွက် localized files များပါဝင်သော dataset တစ်ခု။
*   **KDE Apps**: Linux desktop environment အတွက် ဖန်တီးထားသော open-source applications များ။
*   **Opus Dataset**: ဘာသာစကားမျိုးစုံပါဝင်သော အကြီးစား parallel corpora (စာသားအစုအဝေး)။
*   **Inference Widget**: Hugging Face Hub ပေါ်တွင် model တစ်ခုကို code ရေးစရာမလိုဘဲ တိုက်ရိုက်စမ်းသပ်နိုင်သော user interface။
*   **Model Hub**: Hugging Face Hub ကို ရည်ညွှန်းပြီး AI မော်ဒယ်များ ရှာဖွေ၊ မျှဝေ၊ အသုံးပြုနိုင်သော ဗဟို platform။
*   **`load_dataset()` Function**: Hugging Face Datasets library မှ dataset များကို download လုပ်ပြီး cache လုပ်ရန် အသုံးပြုသော function။
*   **`lang1="en", lang2="fr"`**: `load_dataset()` function တွင် source language နှင့် target language ကို သတ်မှတ်ရန် အသုံးပြုသော arguments များ (English နှင့် French)။
*   **Language Tags**: dataset card တွင် ဘာသာစကားများကို ဖော်ပြရန် အသုံးပြုသော tags များ။
*   **`DatasetDict` Object**: Training set, validation set, နှင့် test set ကဲ့သို့သော dataset အများအပြားကို dictionary ပုံစံဖြင့် သိမ်းဆည်းထားသော object။
*   **Split**: Dataset ကို training, validation, test စသည်ဖြင့် ခွဲခြားထားသော အပိုင်းများ။
*   **`train_test_split()` Method**: `Dataset` object မှာပါဝင်ပြီး dataset ကို training and testing (သို့မဟုတ် validation) splits များအဖြစ် ခွဲခြားရန် အသုံးပြုသည်။
*   **Seed**: ကျပန်းနံပါတ်ထုတ်လုပ်ခြင်းကို reproducibility အတွက် တူညီအောင် ထိန်းချုပ်သော တန်ဖိုး။
*   **Reproducibility**: သတ်မှတ်ထားသော code နှင့် data ကို အသုံးပြု၍ တူညီသော ရလဒ်များကို ပြန်လည်ထုတ်လုပ်နိုင်ခြင်း။
*   **Validation Set**: Training လုပ်နေစဉ် model ၏ စွမ်းဆောင်ရည်ကို အကဲဖြတ်ရန် အသုံးပြုသော dataset အပိုင်း။
*   **Target Language**: ဘာသာပြန်လိုသော ဘာသာစကား။
*   **`pipeline()` Function**: Hugging Face Transformers library မှာ ပါဝင်တဲ့ လုပ်ဆောင်ချက်တစ်ခုဖြစ်ပြီး မော်ဒယ်တွေကို သီးခြားလုပ်ငန်းတာဝန်များ (ဥပမာ- စာသားခွဲခြားသတ်မှတ်ခြင်း၊ စာသားထုတ်လုပ်ခြင်း) အတွက် အသုံးပြုရလွယ်ကူအောင် ပြုလုပ်ပေးပါတယ်။
*   **`AutoTokenizer`**: Hugging Face Transformers library မှာ ပါဝင်တဲ့ class တစ်ခုဖြစ်ပြီး မော်ဒယ်အမည်ကို အသုံးပြုပြီး သက်ဆိုင်ရာ tokenizer ကို အလိုအလျောက် load လုပ်ပေးသည်။
*   **`return_tensors="pt"`**: Tokenizer မှ output အဖြစ် PyTorch tensors များကို ပြန်ပေးရန် သတ်မှတ်ခြင်း။
*   **`tokenizer.src_lang`**: Multilingual tokenizer များအတွက် source language ကို သတ်မှတ်သော attribute။
*   **`tokenizer.tgt_lang`**: Multilingual tokenizer များအတွက် target language ကို သတ်မှတ်သော attribute။
*   **`__call__` Method**: Python class object များကို function တစ်ခုကဲ့သို့ ခေါ်ဆိုနိုင်စေသော special method။
*   **`text_targets` Argument**: Tokenizer ၏ `__call__` method တွင် target texts များကို ပေးပို့ရန် အသုံးပြုသော argument။
*   **Input IDs**: Tokenizer မှ ထုတ်ပေးသော tokens တစ်ခုစီ၏ ထူးခြားသော ဂဏန်းဆိုင်ရာ ID များ။
*   **Attention Mask**: မော်ဒယ်ကို အာရုံစိုက်သင့်သည့် tokens များနှင့် လျစ်လျူရှုသင့်သည့် (padding) tokens များကို ခွဲခြားပေးသည့် binary mask။
*   **`labels` Field**: Model training အတွက် အမှန်တကယ် target values များ သိမ်းဆည်းထားသော field။
*   **`convert_ids_to_tokens()` Method**: input IDs များကို tokens များအဖြစ် ပြန်ပြောင်းပေးသော tokenizer method။
*   **Prefix**: စာသားတစ်ခု၏ အစတွင် ပူးတွဲထားသော စကားလုံး သို့မဟုတ် စာကြောင်း။
*   **Padding Token**: စာကြောင်းများ၏ အရှည်ကို ညီမျှစေရန် ထပ်ဖြည့်ပေးသော special token။
*   **Loss Computation**: Model ၏ ခန့်မှန်းချက်များနှင့် အမှန်တကယ် labels များကြား ကွာခြားမှုကို တိုင်းတာသော တန်ဖိုး (loss) ကို တွက်ချက်ခြင်း။
*   **Dynamic Padding**: Batch တစ်ခုအတွင်းရှိ samples များကို အဲဒီ batch ထဲက အရှည်ဆုံး sample ရဲ့ အရှည်အထိသာ padding လုပ်တဲ့ နည်းလမ်း။
*   **`map()` Method**: 🤗 Datasets library မှာ ပါဝင်တဲ့ method တစ်ခုဖြစ်ပြီး dataset ရဲ့ element တစ်ခုစီ ဒါမှမဟုတ် batch တစ်ခုစီပေါ်မှာ function တစ်ခုကို အသုံးပြုနိုင်စေသည်။
*   **`batched=True`**: `map()` method မှာ အသုံးပြုသော argument တစ်ခုဖြစ်ပြီး function ကို dataset ရဲ့ element အများအပြားပေါ်မှာ တစ်ပြိုင်နက်တည်း အသုံးပြုစေသည်။
*   **`remove_columns` Argument**: `map()` method တွင် မလိုအပ်သော columns များကို dataset မှ ဖယ်ရှားရန် အသုံးပြုသော argument။
*   **`AutoModelForSeq2SeqLM`**: Sequence-to-sequence language modeling task များအတွက် သက်ဆိုင်ရာ model class ကို အလိုအလျောက် load လုပ်ပေးသော Hugging Face Transformers class။
*   **`Seq2SeqTrainer`**: Hugging Face Transformers library မှ sequence-to-sequence models များကို လေ့ကျင့်ရန်အတွက် အထူးပြု Trainer subclass။
*   **`generate()` Method**: model တစ်ခုမှ text sequence အသစ်များကို ထုတ်လုပ်ရန်အတွက် method။
*   **`AutoModel` API**: Hugging Face Transformers library မှ model class များကို အလိုအလျောက် load လုပ်ရန်အတွက် API။
*   **`TFAutoModelForSeq2SeqLM`**: TensorFlow framework အတွက် `AutoModelForSeq2SeqLM` ၏ version။
*   **`from_pt=True`**: TensorFlow model ကို load လုပ်ရာတွင် PyTorch weights များကို convert လုပ်ပြီး အသုံးပြုရန် သတ်မှတ်ခြင်း။
*   **PyTorch Weights**: PyTorch framework ဖြင့် လေ့ကျင့်ထားသော model ၏ parameters များ။
*   **Data Collator**: batch တစ်ခုအတွင်းရှိ data samples များကို model input အတွက် သင့်လျော်သောပုံစံသို့ ပြောင်းလဲပေးသော function သို့မဟုတ် class။
*   **`DataCollatorWithPadding`**: input IDs, attention masks စသည်တို့ကို padding လုပ်ပေးသော data collator။
*   **`DataCollatorForSeq2Seq`**: Sequence-to-sequence models များအတွက် inputs နှင့် labels နှစ်ခုလုံးကို padding လုပ်ပေးပြီး decoder input IDs များကို ပြင်ဆင်ပေးသော data collator။
*   **Decoder Input IDs**: decoder အတွက် input အဖြစ် အသုံးပြုသော shifted labels များ။
*   **`tensor`**: PyTorch မှာ data များကို သိမ်းဆည်းရန် အသုံးပြုတဲ့ multi-dimensional array။
*   **`prepare_tf_dataset()` Method**: Keras API ဖြင့် training လုပ်ရန်အတွက် `tf.data.Dataset` object တစ်ခုကို ပြင်ဆင်ပေးသော method။
*   **`collate_fn` Argument**: `DataLoader` သို့မဟုတ် `prepare_tf_dataset()` တွင် data samples များကို batch တစ်ခုအဖြစ် စုစည်းရန် အသုံးပြုသော function။
*   **`shuffle=True/False`**: dataset ကို training အတွက် ရောနှောခြင်းရှိမရှိ သတ်မှတ်ခြင်း။
*   **`batch_size`**: training သို့မဟုတ် evaluation လုပ်ငန်းစဉ်တစ်ခုစီတွင် model သို့ ပေးပို့သော input samples အရေအတွက်။
*   **BLEU Score (Bilingual Evaluation Understudy)**: ဘာသာပြန်ထားသော စာသားတစ်ခု၏ အရည်အသွေးကို တိုင်းတာရန် အသုံးပြုသော metric။
*   **`evaluate.load("sacrebleu")`**: `sacrebleu` metric ကို load လုပ်ရန် evaluate library မှ function။
*   **`metric.compute()` Method**: metric object ဖြင့် predictions များနှင့် references များအပေါ် အခြေခံ၍ score ကို တွက်ချက်သော method။
*   **`tokenizer.batch_decode()` Method**: token IDs များကို စာသားများအဖြစ် ပြန်လည်ပြောင်းလဲရန် အသုံးပြုသော tokenizer method။
*   **`-100`**: Padding values များ loss computation တွင် လျစ်လျူရှုခံရစေရန် labels တွင် အသုံးပြုသော special value။
*   **XLA (Accelerated Linear Algebra)**: TensorFlow ၏ accelerated linear algebra compiler ဖြစ်ပြီး model computation graph များကို optimizations လုပ်ဆောင်၍ speed နှင့် memory usage ကို တိုးတက်စေသည်။
*   **`@tf.function(jit_compile=True)` Decorator**: TensorFlow function တစ်ခုကို XLA ဖြင့် JIT (Just-In-Time) compile လုပ်ရန် မှတ်သားပေးသော decorator။
*   **`tqdm`**: Python library တစ်ခုဖြစ်ပြီး loops များအတွက် progress bars များကို ဖန်တီးပေးသည်။
*   **`model.generate()` Method**: model မှ text sequence အသစ်များကို ထုတ်လုပ်ရန်အတွက် method။
*   **`decoded_preds`**: model မှ ထုတ်ပေးပြီး decode လုပ်ထားသော predictions များ။
*   **`decoded_labels`**: decode လုပ်ထားသော အမှန်တကယ် labels များ။
*   **`strip()` Method**: string တစ်ခု၏ အစ သို့မဟုတ် အဆုံးရှိ whitespace များကို ဖယ်ရှားသော Python string method။
*   **`notebook_login()`**: Jupyter/Colab Notebooks များတွင် Hugging Face Hub သို့ login ဝင်ရန် အသုံးပြုသော function။
*   **`huggingface-cli login`**: Hugging Face CLI (Command Line Interface) မှ Hugging Face Hub သို့ login ဝင်ရန် အသုံးပြုသော command။
*   **GPUT (Graphics Processing Unit)**: ဂရပ်ဖစ်လုပ်ဆောင်မှုအတွက် အထူးဒီဇိုင်းထုတ်ထားသော processor တစ်မျိုးဖြစ်သော်လည်း AI/ML လုပ်ငန်းများတွင် အရှိန်မြှင့်ရန် အသုံးများသည်။
*   **`create_optimizer()` Function**: Hugging Face Transformers library မှ optimizer နှင့် learning rate scheduler ကို ဖန်တီးပေးသော function။
*   **`PushToHubCallback`**: Keras models များအတွက် training လုပ်နေစဉ်အတွင်း model ကို Hugging Face Hub သို့ upload လုပ်ရန် ကူညီပေးသော callback။
*   **`model.compile()` Method**: Keras model ကို training အတွက် ပြင်ဆင်သော method (optimizer, loss function, metrics သတ်မှတ်ခြင်း)။
*   **`model.fit()` Method**: Keras model ကို training data ဖြင့် လေ့ကျင့်သော method။
*   **`validation_data`**: training လုပ်နေစဉ်အတွင်း model ၏ စွမ်းဆောင်ရည်ကို အကဲဖြတ်ရန် အသုံးပြုသော validation dataset။
*   **`Seq2SeqTrainingArguments`**: Hugging Face Transformers library မှ sequence-to-sequence models များအတွက် training arguments များကို သတ်မှတ်သော class။
*   **`evaluation_strategy="no"`**: evaluation ကို မလုပ်ဆောင်ရန် သတ်မှတ်ခြင်း။
*   **`save_strategy="epoch"`**: model ကို epoch တိုင်း သိမ်းဆည်းရန် သတ်မှတ်ခြင်း။
*   **`learning_rate`**: training လုပ်ငန်းစဉ်အတွင်း model ၏ parameters များကို မည်မျှပြောင်းလဲရမည်ကို ထိန်းချုပ်သော hyperparameter။
*   **`per_device_train_batch_size`**: GPU/TPU တစ်ခုစီအတွက် training batch size။
*   **`per_device_eval_batch_size`**: GPU/TPU တစ်ခုစီအတွက် evaluation batch size။
*   **`weight_decay`**: overfitting ကို လျှော့ချရန်အတွက် regularization technique တစ်ခု။
*   **`save_total_limit`**: သိမ်းဆည်းထားမည့် model checkpoints အရေအတွက်ကို ကန့်သတ်ခြင်း။
*   **`num_train_epochs`**: model ကို training dataset တစ်ခုလုံးဖြင့် လေ့ကျင့်မည့် အကြိမ်အရေအတွက်။
*   **`fp16=True`**: Float16 precision ဖြင့် training လုပ်ရန် သတ်မှတ်ခြင်း။
*   **`push_to_hub=True`**: training ပြီးဆုံးပြီးနောက် model ကို Hugging Face Hub သို့ အလိုအလျောက် upload လုပ်ရန် သတ်မှတ်ခြင်း။
*   **`hub_model_id` Argument**: `Seq2SeqTrainingArguments` တွင် Hugging Face Hub ပေါ်ရှိ model repository ၏ အမည်ကို သတ်မှတ်ရန် အသုံးပြုသော argument။
*   **Namespace**: Hugging Face Hub တွင် သုံးစွဲသူအကောင့် သို့မဟုတ် organization အမည်။
*   **Output Directory**: model, tokenizer နှင့် training logs များကို သိမ်းဆည်းမည့် local folder။
*   **`Seq2SeqTrainer`**: Hugging Face Transformers library မှ sequence-to-sequence models များကို လေ့ကျင့်ရန်အတွက် အထူးပြု Trainer subclass။
*   **`trainer.evaluate()` Method**: `Trainer` object ဖြင့် model ၏ စွမ်းဆောင်ရည်ကို evaluation dataset ပေါ်တွင် အကဲဖြတ်သော method။
*   **`max_length`**: sequence များ၏ အမြင့်ဆုံးအရှည်။
*   **`eval_loss`**: Evaluation dataset ပေါ်တွင် model ၏ loss တန်ဖိုး။
*   **`eval_bleu`**: Evaluation dataset ပေါ်တွင် model ၏ BLEU score။
*   **`eval_runtime`**: Evaluation လုပ်ဆောင်ရန် ကြာမြင့်သော အချိန်။
*   **`eval_samples_per_second`**: Evaluation လုပ်နေစဉ် တစ်စက္ကန့်လျှင် လုပ်ဆောင်သော samples အရေအတွက်။
*   **`eval_steps_per_second`**: Evaluation လုပ်နေစဉ် တစ်စက္ကန့်လျှင် လုပ်ဆောင်သော steps အရေအတွက်။
*   **`epoch`**: Model ကို training dataset တစ်ခုလုံးဖြင့် လေ့ကျင့်သည့် အကြိမ်အရေအတွက်။
*   **`trainer.train()` Method**: `Trainer` object ဖြင့် model ကို train လုပ်သော method။
*   **`trainer.push_to_hub()` Method**: `Trainer` object ဖြင့် model ကို Hugging Face Hub သို့ upload လုပ်သော method။
*   **`tags="translation"`**: Model card တွင် translation task အတွက် tag ကို ထည့်သွင်းခြင်း။
*   **`commit_message`**: Git commit အတွက် မက်ဆေ့ချ်။
*   **URL**: web ပေါ်ရှိ အရင်းအမြစ်တစ်ခု၏ လိပ်စာ။
*   **Custom Training Loop**: `Trainer` API ကို အသုံးပြုမည့်အစား developer ကိုယ်တိုင် အသေးစိတ် ထိန်းချုပ်နိုင်သော training loop။
*   **`DataLoader`**: Dataset ကနေ data တွေကို batch အလိုက် load လုပ်ပေးတဲ့ PyTorch utility class။
*   **`tokenized_datasets.set_format("torch")`**: dataset ၏ output format ကို PyTorch tensors အဖြစ် သတ်မှတ်ခြင်း။
*   **PyTorch Tensors**: PyTorch framework မှာ data တွေကို ကိုယ်စားပြုသော multi-dimensional array များ။
*   **`AdamW`**: PyTorch မှာ အသုံးပြုတဲ့ AdamW optimizer။
*   **`model.parameters()`**: model ၏ လေ့ကျင့်နိုင်သော parameters များကို ပြန်ပေးသော method။
*   **`Accelerator`**: Hugging Face Accelerate library မှ distributed training (multiple GPUs, TPUs) ကို လွယ်ကူစေသော class။
*   **`accelerator.prepare()` Method**: models, optimizers, dataloaders များကို distributed training အတွက် ပြင်ဆင်ပေးသော method။
*   **TPUs (Tensor Processing Units)**: Google မှ AI/ML workloads များအတွက် အထူးဒီဇိုင်းထုတ်ထားသော processor တစ်မျိုး။
*   **`get_scheduler()` Function**: Hugging Face Transformers library မှ learning rate scheduler ကို ရယူသော function။
*   **`num_warmup_steps`**: learning rate ကို ဖြည်းဖြည်းချင်း တိုးမြှင့်မည့် training steps အရေအတွက်။
*   **`num_training_steps`**: စုစုပေါင်း training steps အရေအတွက်။
*   **`lr_scheduler`**: learning rate ကို training လုပ်နေစဉ်အတွင်း ပြောင်းလဲပေးသော scheduler။
*   **`Repository` Object**: `huggingface_hub` library မှ Git repository များကို ကိုင်တွယ်ရန်အတွက် object။
*   **Working Folder**: project files များကို သိမ်းဆည်းထားသော directory။
*   **`get_full_repo_name()` Function**: Hugging Face Hub repository ၏ နာမည်အပြည့်အစုံကို ပြန်ပေးသော function (username ပါဝင်သည်)။
*   **`repo.push_to_hub()` Method**: `Repository` object ဖြင့် Git repository ကို Hugging Face Hub သို့ push လုပ်သော method။
*   **`commit_message`**: Git commit အတွက် မက်ဆေ့ချ်။
*   **`blocking=False`**: `push_to_hub()` method ကို non-blocking mode ဖြင့် လုပ်ဆောင်စေပြီး code execution ကို ဆက်လက်လုပ်ဆောင်စေသည်။
*   **`tqdm.auto`**: `tqdm` library ၏ auto-detection version။
*   **`torch.no_grad()`**: PyTorch တွင် gradient computation ကို disable လုပ်ရန်အတွက် context manager။
*   **`accelerator.unwrap_model(model).generate()`**: `Accelerator` ဖြင့် wrap လုပ်ထားသော model မှ underlying base model ကို ရယူပြီး `generate()` method ကို ခေါ်ခြင်း။
*   **`accelerator.pad_across_processes()`**: Distributed training တွင် မတူညီသော processes များမှ tensors များကို တူညီသော shape ဖြစ်အောင် padding လုပ်ပေးသော method။
*   **`dim=1`**: padding လုပ်မည့် dimension ကို သတ်မှတ်ခြင်း။
*   **`pad_index`**: padding လုပ်ရန် အသုံးပြုမည့် index (တန်ဖိုး)။
*   **`accelerator.gather()`**: Distributed training တွင် မတူညီသော processes များမှ tensors များကို စုစည်းပေးသော method။
*   **`metric.add_batch()` Method**: metric object တွင် predictions များနှင့် references များကို batch အလိုက် ထည့်သွင်းသော method။
*   **`accelerator.wait_for_everyone()`**: Distributed training တွင် processes အားလုံး အလုပ်ပြီးဆုံးရန် စောင့်ဆိုင်းသော method။
*   **`unwrapped_model.save_pretrained()`**: pretrained model ကို local folder သို့ သိမ်းဆည်းသော method။
*   **`save_function=accelerator.save`**: Distributed training တွင် model ကို သိမ်းဆည်းရန်အတွက် `accelerator.save` ကို အသုံးပြုရန် သတ်မှတ်ခြင်း။
*   **`accelerator.is_main_process`**: လက်ရှိ process သည် main process ဖြစ်ခြင်းရှိမရှိ စစ်ဆေးသော property။
*   **`tokenizer.save_pretrained()`**: tokenizer ကို local folder သို့ သိမ်းဆည်းသော method။
*   **Domain Adaptation**: Model တစ်ခုကို မူရင်း train လုပ်ခဲ့သော domain မှ ကွဲပြားခြားနားသော domain အသစ်တစ်ခုတွင် ကောင်းမွန်စွာ စွမ်းဆောင်နိုင်စေရန် ချိန်ညှိခြင်း။