<FrameworkSwitchCourse {fw} />

# Pipeline နောက်ကွယ်မှ အကြောင်းအရာများ[[behind-the-pipeline]]

<CourseFloatingBanner chapter={2}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter2/section2_pt.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter2/section2_pt.ipynb"},
]} />

<Youtube id="1pedAIvTWXk"/>

[Chapter 1](/course/chapter1) မှာ အောက်ပါ code ကို run တဲ့အခါ ဘာတွေဖြစ်ပျက်သွားလဲဆိုတာကို ကြည့်ခြင်းဖြင့် ဥပမာတစ်ခုနဲ့ စလိုက်ရအောင်...။

```python
from transformers import pipeline

classifier = pipeline("sentiment-analysis")
classifier(
    [
        "I've been waiting for a HuggingFace course my whole life.",
        "I hate this so much!",
    ]
)
```

အောက်ပါရလဒ်ကို ရရှိခဲ့ပါတယ်။

```python out
[{'label': 'POSITIVE', 'score': 0.9598047137260437},
 {'label': 'NEGATIVE', 'score': 0.9994558095932007}]
```

[Chapter 1](/course/chapter1) မှာ ကျွန်တော်တို့ တွေ့ခဲ့ရသလို၊ ဒီ pipeline ဟာ အဆင့်သုံးဆင့်ကို ပေါင်းစပ်ထားပါတယ်၊ preprocessing လုပ်ခြင်း၊ model ကနေတဆင့် inputs တွေကို ပေးပို့ခြင်း၊ နဲ့ postprocessing လုပ်ခြင်းတို့ ဖြစ်ပါတယ်။

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/full_nlp_pipeline.svg" alt="The full NLP pipeline: tokenization of text, conversion to IDs, and inference through the Transformer model and the model head."/>
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/full_nlp_pipeline-dark.svg" alt="The full NLP pipeline: tokenization of text, conversion to IDs, and inference through the Transformer model and the model head."/>
</div>

ဒါတွေကို အမြန်ဆုံး တစ်ခုချင်းစီ လေ့လာကြည့်ရအောင်။

## Tokenizer ဖြင့် Preprocessing ပြုလုပ်ခြင်း[[preprocessing-with-a-tokenizer]]

အခြား neural network များကဲ့သို့ Transformer မော်ဒယ်များသည် raw text များကို တိုက်ရိုက်လုပ်ဆောင်၍ မရပါ။ ထို့ကြောင့် ကျွန်တော်တို့ pipeline ၏ ပထမအဆင့်မှာ text inputs များကို မော်ဒယ်နားလည်နိုင်သော ဂဏန်းများအဖြစ် ပြောင်းလဲခြင်းဖြစ်သည်။ ၎င်းကို ပြုလုပ်ရန် ကျွန်တော်တို့သည် *tokenizer* ကို အသုံးပြုပါသည်။ ၎င်းသည် အောက်ပါတို့ကို လုပ်ဆောင်ရန် တာဝန်ရှိသည်-

- input ကို *tokens* ဟုခေါ်သော စကားလုံးများ၊ subwords များ သို့မဟုတ် သင်္ကေတများ (ဥပမာ- ပုဒ်ဖြတ်သံ) အဖြစ် ပိုင်းခြားခြင်း
- token တစ်ခုစီကို integer တစ်ခုသို့ တွဲချိတ်ခြင်း
- မော်ဒယ်အတွက် အသုံးဝင်နိုင်သော အပို inputs များကို ထည့်သွင်းခြင်း

ဒီ preprocessing အားလုံးကို မော်ဒယ်ကို pre-trained လုပ်ခဲ့စဉ်က အတိအကျလုပ်ခဲ့တဲ့ နည်းလမ်းအတိုင်း ပြုလုပ်ဖို့ လိုအပ်ပါတယ်။ ဒါကြောင့် ကျွန်တော်တို့ အရင်ဆုံး [Model Hub](https://huggingface.co/models) ကနေ အဲဒီအချက်အလက်တွေကို download လုပ်ဖို့ လိုပါတယ်။ ဒါကို လုပ်ဖို့အတွက် `AutoTokenizer` class နဲ့ သူ့ရဲ့ `from_pretrained()` method ကို ကျွန်တော်တို့ အသုံးပြုပါတယ်။ ကျွန်တော်တို့ model ရဲ့ checkpoint name ကို အသုံးပြုပြီး၊ ၎င်းသည် model ရဲ့ tokenizer နဲ့ ဆက်စပ်နေတဲ့ ဒေတာတွေကို အလိုအလျောက် ရယူပြီး cache လုပ်ပါလိမ့်မယ် (ဒါကြောင့် အောက်က code ကို ပထမဆုံးအကြိမ် run မှသာ download လုပ်ပါလိမ့်မယ်)။

`sentiment-analysis` pipeline ရဲ့ default checkpoint က `distilbert-base-uncased-finetuned-sst-2-english` ဖြစ်တာကြောင့် (၎င်းရဲ့ model card ကို [ဒီနေရာမှာ](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) ကြည့်နိုင်ပါတယ်)၊ အောက်ပါ code ကို ကျွန်တော်တို့ run ပြုလုပ်ပေးပါတယ်။

```python
from transformers import AutoTokenizer

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
```

tokenizer ကို ရရှိပြီဆိုတာနဲ့၊ ကျွန်တော်တို့ရဲ့ စာကြောင်းတွေကို တိုက်ရိုက် ပေးပို့နိုင်ပြီး model ကို ထည့်သွင်းဖို့ အဆင်သင့်ဖြစ်နေတဲ့ dictionary တစ်ခု ပြန်ရပါလိမ့်မယ်။ လုပ်ဆောင်ဖို့ ကျန်ရှိတာကတော့ input IDs တွေရဲ့ list ကို tensors တွေအဖြစ် ပြောင်းလဲဖို့ပါပဲ။

သင်ဟာ backend မှာ ဘယ် ML framework ကို အသုံးပြုလဲဆိုတာ စိုးရိမ်စရာမလိုဘဲ 🤗 Transformers ကို အသုံးပြုနိုင်ပါတယ်။ အချို့မော်ဒယ်တွေအတွက် PyTorch ဒါမှမဟုတ် Flax ဖြစ်နိုင်ပါတယ်။ သို့သော် Transformer မော်ဒယ်တွေက *tensors* တွေကိုပဲ input အဖြစ် လက်ခံပါတယ်။ tensors တွေအကြောင်းကို အခုမှ စကြားဖူးတာဆိုရင်၊ ၎င်းတို့ကို NumPy arrays တွေအဖြစ် တွေးကြည့်နိုင်ပါတယ်။ NumPy array တစ်ခုက scalar (0D)၊ vector (1D)၊ matrix (2D) သို့မဟုတ် dimension များစွာရှိနိုင်ပါတယ်။ ဒါက တကယ်တော့ tensor တစ်ခုပါပဲ။ အခြား ML frameworks တွေရဲ့ tensors တွေလည်း အလားတူပဲ အလုပ်လုပ်ပြီး၊ NumPy arrays တွေလိုပဲ လွယ်ကူစွာ instantiate လုပ်နိုင်ပါတယ်။

ကျွန်တော်တို့ ပြန်လိုချင်တဲ့ tensors (PyTorch သို့မဟုတ် plain NumPy) အမျိုးအစားကို သတ်မှတ်ဖို့အတွက် `return_tensors` argument ကို အသုံးပြုနိုင်ပါတယ်။

```python
raw_inputs = [
    "I've been waiting for a HuggingFace course my whole life.",
    "I hate this so much!",
]
inputs = tokenizer(raw_inputs, padding=True, truncation=True, return_tensors="pt")
print(inputs)
```

padding နဲ့ truncation အကြောင်းကို အခုထိ စိတ်ပူမနေပါနဲ့၊ ဒါတွေကို နောက်မှ ရှင်းပြပါမယ်။ ဒီနေရာမှာ မှတ်ထားရမယ့် အဓိကအချက်တွေကတော့ သင်ဟာ စာကြောင်းတစ်ကြောင်း ဒါမှမဟုတ် စာကြောင်းများစွာပါတဲ့ list ကို ပေးပို့နိုင်သလို၊ သင်ပြန်လိုချင်တဲ့ tensors အမျိုးအစားကိုလည်း သတ်မှတ်နိုင်ပါတယ် (မည်သည့် type ကိုမျှ မပေးပို့ရင် list of lists အဖြစ် ရလဒ်ရပါလိမ့်မယ်)။

PyTorch tensors အဖြစ် ရလဒ်တွေက အောက်ပါအတိုင်း ဖြစ်ပါတယ်။

```python out
{
    'input_ids': tensor([
        [  101,  1045,  1005,  2310,  2042,  3403,  2005,  1037, 17662, 12172, 2607,  2026,  2878,  2166,  1012,   102],
        [  101,  1045,  5223,  2023,  2061,  2172,   999,   102,     0,     0,     0,     0,     0,     0,     0,     0]
    ]), 
    'attention_mask': tensor([
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]
    ])
}
```

output ကိုယ်တိုင်က `input_ids` နဲ့ `attention_mask` ဆိုတဲ့ key နှစ်ခုပါဝင်တဲ့ dictionary တစ်ခု ဖြစ်ပါတယ်။ `input_ids` မှာ integer row နှစ်ခု (စာကြောင်းတစ်ကြောင်းစီအတွက် တစ်ခု) ပါဝင်ပြီး ၎င်းတို့ဟာ စာကြောင်းတစ်ကြောင်းစီရှိ tokens တွေရဲ့ ထူးခြားတဲ့ identifiers တွေ ဖြစ်ပါတယ်။ `attention_mask` ဆိုတာ ဘာလဲဆိုတာကို ဒီအခန်းရဲ့ နောက်ပိုင်းမှာ ကျွန်တော်တို့ ရှင်းပြပါမယ်။

## Model ကို ဖြတ်သန်းခြင်း[[going-through-the-model]]

ကျွန်တော်တို့ tokenizer ကို လုပ်ခဲ့သလိုပဲ pre-trained model ကို download လုပ်နိုင်ပါတယ်။ 🤗 Transformers က `from_pretrained()` method ပါဝင်တဲ့ `AutoModel` class ကို ပံ့ပိုးပေးပါတယ်။

```python
from transformers import AutoModel

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
model = AutoModel.from_pretrained(checkpoint)
```

ဒီ code snippet မှာ ကျွန်တော်တို့ဟာ ယခင်က pipeline မှာ အသုံးပြုခဲ့တဲ့ checkpoint အတူတူကို download လုပ်ပြီး model တစ်ခုကို instantiate လုပ်ခဲ့ပါတယ်။ (ဒါကို အမှန်တကယ်တော့ cache လုပ်ထားပြီးသား ဖြစ်သင့်ပါတယ်)။

ဒီ architecture မှာ base Transformer module သာ ပါဝင်ပါတယ်- inputs အချို့ကို ပေးလိုက်တဲ့အခါ ၎င်းသည် *hidden states* ဟုခေါ်သော အရာများကို ထုတ်ပေးပါတယ်။ ၎င်းတို့ကို *features* ဟုလည်း ခေါ်ပါတယ်။ model input တစ်ခုစီအတွက် **Transformer model က အဲဒီ input ကို အကြောင်းအရာအရ နားလည်ထားမှုကို ကိုယ်စားပြုတဲ့ high-dimensional vector တစ်ခုကို** ကျွန်တော်တို့ ပြန်ရပါလိမ့်မယ်။

ဒါကို နားမလည်ရင် စိတ်မပူပါနဲ့။ ဒါတွေကို နောက်မှ အားလုံးရှင်းပြပါမယ်။

ဒီ hidden states တွေက သူ့ဘာသာသူ အသုံးဝင်နိုင်ပေမယ့်၊ ၎င်းတို့ဟာ များသောအားဖြင့် *head* လို့ခေါ်တဲ့ model ရဲ့ နောက်ထပ်အစိတ်အပိုင်းတစ်ခုရဲ့ inputs တွေ ဖြစ်ပါတယ်။ [Chapter 1](/course/chapter1) မှာ မတူညီတဲ့ လုပ်ငန်းတာဝန်တွေကို architecture တူတူနဲ့ လုပ်ဆောင်နိုင်ခဲ့ပေမယ့်၊ ဒီလုပ်ငန်းတာဝန်တစ်ခုစီမှာ ၎င်းနဲ့ ဆက်စပ်နေတဲ့ head တစ်ခုစီ ရှိပါတယ်။

### High-dimensional vector တစ်ခုလား။[[a-high-dimensional-vector]]

Transformer module ကနေ ထုတ်ပေးတဲ့ vector ဟာ များသောအားဖြင့် ကြီးမားပါတယ်။ ဒါက အများအားဖြင့် dimensions သုံးခု ရှိပါတယ်-

-   **Batch size**: တစ်ကြိမ်တည်း လုပ်ဆောင်တဲ့ sequence အရေအတွက် (ကျွန်တော်တို့ ဥပမာမှာ ၂ ခု)။
-   **Sequence length**: sequence ရဲ့ ဂဏန်းဆိုင်ရာ ကိုယ်စားပြုမှုရဲ့ အရှည် (ကျွန်တော်တို့ ဥပမာမှာ ၁၆ ခု)။
-   **Hidden size**: model input တစ်ခုစီရဲ့ vector dimension။

နောက်ဆုံးတန်ဖိုးကြောင့် "high dimensional" လို့ ခေါ်တာ ဖြစ်ပါတယ်။ hidden size က အလွန်ကြီးမားနိုင်ပါတယ် (768 က ပိုသေးငယ်တဲ့ မော်ဒယ်တွေအတွက် အများအားဖြင့်ဖြစ်ပြီး၊ ပိုကြီးတဲ့ မော်ဒယ်တွေမှာ ဒါက 3072 ဒါမှမဟုတ် ပိုများနိုင်ပါတယ်)။

ကျွန်တော်တို့ preprocessing လုပ်ထားတဲ့ inputs တွေကို model ကို ပေးပို့ကြည့်ရင် ဒါကို တွေ့နိုင်ပါတယ်။ 

```python
outputs = model(**inputs)
print(outputs.last_hidden_state.shape)
```

```python out
torch.Size([2, 16, 768])
```

🤗 Transformers မော်ဒယ်တွေရဲ့ outputs တွေဟာ `namedtuple` တွေ ဒါမှမဟုတ် dictionaries တွေလို အလုပ်လုပ်တယ်ဆိုတာကို သတိပြုပါ။ attribute တွေ (ကျွန်တော်တို့ လုပ်ခဲ့သလို) ဒါမှမဟုတ် key ( `outputs["last_hidden_state"]` ) နဲ့ ဒါမှမဟုတ် သင်ရှာနေတဲ့အရာ ဘယ်နေရာမှာရှိတယ်ဆိုတာ အတိအကျသိရင် index ( `outputs[0]` ) နဲ့ပါ ဝင်ရောက်ကြည့်ရှုနိုင်ပါတယ်။

### Model heads: ဂဏန်းတွေကနေ အဓိပ္ပာယ်ထုတ်ယူခြင်း[[model-heads-making-sense-out-of-numbers]]

Model heads တွေက hidden states တွေရဲ့ high-dimensional vector ကို input အဖြစ် ယူပြီး ၎င်းတို့ကို မတူညီတဲ့ dimension တစ်ခုပေါ်သို့ project လုပ်ပါတယ်။ ၎င်းတို့ဟာ များသောအားဖြင့် linear layers တစ်ခု ဒါမှမဟုတ် အနည်းငယ်နဲ့ ဖွဲ့စည်းထားပါတယ်-

<div class="flex justify-center">
<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/transformer_and_head.svg" alt="A Transformer network alongside its head."/>
<img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/transformer_and_head-dark.svg" alt="A Transformer network alongside its head."/>
</div>

Transformer model ရဲ့ output ကို model head ကို တိုက်ရိုက်ပို့ပြီး လုပ်ဆောင်ပါတယ်။

ဒီပုံမှာ မော်ဒယ်ကို embeddings layer နဲ့ နောက်ဆက်တွဲ layers တွေနဲ့ ကိုယ်စားပြုထားပါတယ်။ embeddings layer က tokenized input ထဲက input ID တစ်ခုစီကို ၎င်းနဲ့ ဆက်စပ်နေတဲ့ token ကို ကိုယ်စားပြုတဲ့ vector တစ်ခုအဖြစ် ပြောင်းလဲပေးပါတယ်။ နောက်ဆက်တွဲ layers တွေက attention mechanism ကို အသုံးပြုပြီး အဲဒီ vectors တွေကို စီမံခန့်ခွဲကာ စာကြောင်းတွေရဲ့ နောက်ဆုံးကိုယ်စားပြုမှုကို ထုတ်ပေးပါတယ်။

🤗 Transformers မှာ မတူညီတဲ့ architecture များစွာ ရရှိနိုင်ပြီး၊ တစ်ခုချင်းစီကို သီးခြားလုပ်ငန်းတစ်ခုကို ဖြေရှင်းဖို့ ဒီဇိုင်းထုတ်ထားပါတယ်။ အောက်ပါတို့ကတော့ မပြည့်စုံသေးသော စာရင်းတစ်ခု ဖြစ်ပါတယ်-

-   `*Model` (hidden states များကို ပြန်ရယူခြင်း)
-   `*ForCausalLM`
-   `*ForMaskedLM`
-   `*ForMultipleChoice`
-   `*ForQuestionAnswering`
-   `*ForSequenceClassification`
-   `*ForTokenClassification`
-   နဲ့ အခြားအရာများ 🤗

ကျွန်တော်တို့ရဲ့ ဥပမာအတွက်၊ sequence classification head ပါဝင်တဲ့ မော်ဒယ်တစ်ခု လိုအပ်ပါလိမ့်မယ် (စာကြောင်းတွေကို positive သို့မဟုတ် negative အဖြစ် ခွဲခြားသတ်မှတ်နိုင်ဖို့)။ ဒါကြောင့် ကျွန်တော်တို့ဟာ `AutoModel` class ကို အမှန်တကယ် အသုံးပြုမှာ မဟုတ်ဘဲ `AutoModelForSequenceClassification` ကို အသုံးပြုပါမယ်။

```python
from transformers import AutoModelForSequenceClassification

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
model = AutoModelForSequenceClassification.from_pretrained(checkpoint)
outputs = model(**inputs)
```

အခု outputs တွေရဲ့ shape ကို ကြည့်လိုက်ရင်၊ dimensionality က အများကြီး နိမ့်သွားပါလိမ့်မယ်၊ model head က ယခင်က ကျွန်တော်တို့ တွေ့ခဲ့တဲ့ high-dimensional vectors တွေကို input အဖြစ် ယူပြီး၊ တန်ဖိုးနှစ်ခု (label တစ်ခုစီအတွက် တစ်ခု) ပါဝင်တဲ့ vectors တွေကို ထုတ်ပေးပါတယ်။

```python
print(outputs.logits.shape)
```

```python out
torch.Size([2, 2])
```

ကျွန်တော်တို့မှာ စာကြောင်းနှစ်ကြောင်းနဲ့ label နှစ်ခုပဲ ရှိတာကြောင့်၊ ကျွန်တော်တို့ model ကနေ ရရှိတဲ့ ရလဒ်ဟာ 2 x 2 shape ဖြစ်ပါတယ်။

## Output ကို Postprocessing ပြုလုပ်ခြင်း[[postprocessing-the-output]]

ကျွန်တော်တို့ model ကနေ output အဖြစ် ရရှိတဲ့ တန်ဖိုးတွေက သူ့ဘာသာသူ အဓိပ္ပာယ်ရှိတာ မဟုတ်ပါဘူး။ ကြည့်ကြည့်ရအောင်။

```python
print(outputs.logits)
```

```python out
tensor([[-1.5607,  1.6123],
        [ 4.1692, -3.3464]], grad_fn=<AddmmBackward>)
```

ကျွန်တော်တို့ရဲ့ model က ပထမစာကြောင်းအတွက် `[-1.5607, 1.6123]` ကို ခန့်မှန်းခဲ့ပြီး၊ ဒုတိယစာကြောင်းအတွက် `[ 4.1692, -3.3464]` ကို ခန့်မှန်းခဲ့ပါတယ်။ ဒါတွေက ဖြစ်နိုင်ခြေတွေ မဟုတ်ဘဲ *logits* တွေ ဖြစ်ပါတယ်။ ၎င်းတို့က model ရဲ့ နောက်ဆုံး layer ကနေ ထုတ်ပေးတဲ့ raw, unnormalized scores တွေပါ။ ဖြစ်နိုင်ခြေတွေအဖြစ် ပြောင်းလဲဖို့အတွက် [SoftMax](https://en.wikipedia.org/wiki/Softmax_function) layer ကို ဖြတ်သန်းဖို့ လိုအပ်ပါတယ် (🤗 Transformers model အားလုံးက logits တွေကို ထုတ်ပေးပါတယ်၊ ဘာလို့လဲဆိုတော့ training အတွက် loss function က SoftMax လိုမျိုး နောက်ဆုံး activation function နဲ့ cross entropy လိုမျိုး loss function အမှန်တကယ်ကို ပေါင်းစပ်ထားတာ ဖြစ်လေ့ရှိပါတယ်)။

```py
import torch

predictions = torch.nn.functional.softmax(outputs.logits, dim=-1)
print(predictions)
```

```python out
tensor([[4.0195e-02, 9.5980e-01],
        [9.9946e-01, 5.4418e-04]], grad_fn=<SoftmaxBackward>)
```

အခု ကျွန်တော်တို့ model က ပထမစာကြောင်းအတွက် `[0.0402, 0.9598]` ကို ခန့်မှန်းခဲ့ပြီး၊ ဒုတိယစာကြောင်းအတွက် `[0.9995, 0.0005]` ကို ခန့်မှန်းခဲ့တယ်ဆိုတာ တွေ့ရပါပြီ။ ဒါတွေက အသိအမှတ်ပြုနိုင်တဲ့ ဖြစ်နိုင်ခြေ scores တွေ ဖြစ်ပါတယ်။

position တစ်ခုစီနဲ့ ကိုက်ညီတဲ့ labels တွေကို ရယူဖို့အတွက် model config ရဲ့ `id2label` attribute ကို စစ်ဆေးနိုင်ပါတယ် (ဒီအကြောင်းကို နောက်အပိုင်းမှာ ပိုမိုသိရှိရပါလိမ့်မယ်)။

```python
model.config.id2label
```

```python out
{0: 'NEGATIVE', 1: 'POSITIVE'}
```

Nအခု ကျွန်တော်တို့ model က အောက်ပါအတိုင်း ခန့်မှန်းခဲ့တယ်လို့ ကောက်ချက်ချနိုင်ပါပြီ-
 
- ပထမစာကြောင်း - NEGATIVE: 0.0402, POSITIVE: 0.9598
- ဒုတိယစာကြောင်း - NEGATIVE: 0.9995, POSITIVE: 0.0005

ကျွန်တော်တို့ pipeline ရဲ့ အဆင့်သုံးဆင့်လုံးကို အောင်မြင်စွာ ပြန်လည်ဖန်တီးနိုင်ခဲ့ပါပြီ- tokenizers တွေနဲ့ preprocessing လုပ်ခြင်း၊ model ကနေတဆင့် inputs တွေကို ပေးပို့ခြင်း၊ နဲ့ postprocessing လုပ်ခြင်းတို့ ဖြစ်ပါတယ်။ အခုတော့ ဒီအဆင့်တစ်ခုချင်းစီကို ပိုပြီး နက်နက်နဲနဲ လေ့လာကြည့်ရအောင်။

> [!TIP]
> ✏️ **စမ်းသပ်ကြည့်ပါ။** သင်ကိုယ်တိုင် စာသား (၂) ခု (သို့မဟုတ် ပိုမိုများပြား) ရွေးချယ်ပြီး `sentiment-analysis` pipeline ကနေတဆင့် run ပါ။ ထို့နောက် ဒီနေရာမှာ သင်တွေ့ခဲ့ရတဲ့ အဆင့်တွေကို ကိုယ်တိုင်ပြန်လုပ်ပြီး တူညီတဲ့ ရလဒ်တွေ ရရှိမရရှိ စစ်ဆေးပါ။

## ဝေါဟာရ ရှင်းလင်းချက် (Glossary)

*   **Pipeline**: Hugging Face Transformers library မှာ ပါဝင်တဲ့ လုပ်ဆောင်ချက်တစ်ခုဖြစ်ပြီး မော်ဒယ်တွေကို သီးခြားလုပ်ငန်းတာဝန်များ (ဥပမာ- စာသားခွဲခြားသတ်မှတ်ခြင်း၊ စာသားထုတ်လုပ်ခြင်း) အတွက် အသုံးပြုရလွယ်ကူအောင် ပြုလုပ်ပေးပါတယ်။
*   **Preprocessing**: Machine Learning မော်ဒယ်တစ်ခုကို မထည့်သွင်းမီ raw data များကို လုပ်ဆောင်ရန် အသင့်ဖြစ်အောင် ပြင်ဆင်ခြင်း။
*   **Postprocessing**: Machine Learning မော်ဒယ်တစ်ခု၏ output များကို ပိုမိုနားလည်လွယ်သော သို့မဟုတ် အသုံးဝင်သော ပုံစံသို့ ပြောင်းလဲခြင်း။
*   **Neural Networks**: လူသားဦးနှောက်၏ လုပ်ဆောင်မှုပုံစံကို အတုယူထားသော ကွန်ပျူတာစနစ်များ။
*   **Transformer Models**: Natural Language Processing (NLP) မှာ အောင်မြင်မှုများစွာရရှိခဲ့တဲ့ deep learning architecture တစ်မျိုးပါ။ ၎င်းတို့ဟာ စာသားတွေထဲက စကားလုံးတွေရဲ့ ဆက်နွယ်မှုတွေကို "attention mechanism" သုံးပြီး နားလည်အောင် သင်ကြားပေးပါတယ်။
*   **Raw Text**: မည်သည့်လုပ်ဆောင်မှုမျှ မပြုလုပ်ရသေးသော သို့မဟုတ် ပုံစံမချရသေးသော မူရင်းစာသား။
*   **Tokenizer**: စာသား (သို့မဟုတ် အခြားဒေတာ) ကို AI မော်ဒယ်များ စီမံဆောင်ရွက်နိုင်ရန် tokens တွေအဖြစ် ပိုင်းခြားပေးသည့် ကိရိယာ သို့မဟုတ် လုပ်ငန်းစဉ်။
*   **Tokens**: စာသားကို ခွဲခြမ်းစိတ်ဖြာရာတွင် အသုံးပြုသော အသေးငယ်ဆုံးယူနစ်များ (ဥပမာ- စကားလုံးများ၊ subwords များ သို့မဟုတ် ပုဒ်ဖြတ်သံများ)။
*   **Integer**: အပြည့်အစုံ ကိန်းဂဏန်း။
*   **Pretrained**: ဒေတာအမြောက်အမြားပေါ်တွင် ကြိုတင်လေ့ကျင့်ထားပြီးသား Artificial Intelligence (AI) မော်ဒယ်တစ်ခု။
*   **Model Hub**: Hugging Face ပေါ်ရှိ pre-trained model များနှင့် datasets များကို ရှာဖွေ၊ မျှဝေပြီး အသုံးပြုနိုင်သော online platform။
*   **`AutoTokenizer` Class**: Hugging Face Transformers library မှာ ပါဝင်တဲ့ class တစ်ခုဖြစ်ပြီး မော်ဒယ်အမည်ကို အသုံးပြုပြီး သက်ဆိုင်ရာ tokenizer ကို အလိုအလျောက် load လုပ်ပေးသည်။
*   **`from_pretrained()` Method**: Pre-trained model သို့မဟုတ် tokenizer ကို load လုပ်ရန် အသုံးပြုသော method။
*   **Checkpoint Name**: အင်တာနက်ပေါ်ရှိ Hugging Face Hub မှ pre-trained model သို့မဟုတ် tokenizer ကို ဖော်ထုတ်ရန် အသုံးပြုသော အမည်။
*   **Cache**: မကြာခဏ အသုံးပြုရသော ဒေတာများကို အမြန်ဆုံး ဝင်ရောက်ရယူနိုင်ရန် ယာယီသိုလှောင်ထားသော နေရာ။
*   **`sentiment-analysis` pipeline**: စာသားတစ်ခု၏ စိတ်ခံစားမှု (အပြုသဘော သို့မဟုတ် အနုတ်သဘော) ကို ခွဲခြမ်းစိတ်ဖြာပေးသော pipeline။
*   **`distilbert-base-uncased-finetuned-sst-2-english`**: `sentiment-analysis` pipeline ၏ default checkpoint အဖြစ် အသုံးပြုသော DistilBERT မော်ဒယ်၏ အမည်။ `base` သည် မော်ဒယ်၏ အရွယ်အစားကို ဖော်ပြပြီး `uncased` သည် စာလုံးအကြီးအသေး ခွဲခြားခြင်းမရှိဘဲ လေ့ကျင့်ထားကြောင်း ဖော်ပြသည်။ `finetuned-sst-2-english` က SST-2 dataset တွင် English ဘာသာစကားအတွက် fine-tune လုပ်ထားသည်ကို ဆိုလိုသည်။
*   **Model Card**: Hugging Face Hub ပေါ်ရှိ မော်ဒယ်တစ်ခု၏ အချက်အလက်များ၊ အသုံးပြုပုံနှင့် စွမ်းဆောင်ရည်များကို အကျဉ်းချုပ်ဖော်ပြထားသော စာမျက်နှာ။
*   **Dictionary**: key-value pair များဖြင့် ဒေတာများကို သိုလှောင်သော ဒေတာဖွဲ့စည်းပုံ။
*   **Tensors**: Machine Learning frameworks (PyTorch, TensorFlow) များတွင် ဒေတာများကို ကိုယ်စားပြုသော multi-dimensional array များ။
*   **NumPy Arrays**: Python တွင် ဂဏန်းတွက်ချက်မှုများအတွက် အသုံးပြုသော multi-dimensional array များအတွက် library။
*   **Scalar (0D)**: Dimension မရှိသော တစ်ခုတည်းသော ကိန်းဂဏန်းတန်ဖိုး။
*   **Vector (1D)**: ကိန်းဂဏန်းတန်ဖိုးများ၏ တစ်ကြောင်းတည်းသော sequence။
*   **Matrix (2D)**: ကိန်းဂဏန်းတန်ဖိုးများ၏ နှစ်ကြောင်းအတန်းလိုက် စီစဉ်ထားသော အစုအဝေး။
*   **`return_tensors` Argument**: tokenizer ကို ခေါ်ဆိုသောအခါ ပြန်လိုချင်သော tensor အမျိုးအစားကို သတ်မှတ်ရန် အသုံးပြုသော argument။
*   **`padding`**: မတူညီသော အရှည်ရှိသည့် input sequence များကို အရှည်တူညီအောင် သတ်မှတ်ထားသော တန်ဖိုးများဖြင့် ဖြည့်စွက်ခြင်း။
*   **`truncation`**: အရှည်ကန့်သတ်ချက်ထက် ပိုနေသော input sequence များကို ဖြတ်တောက်ခြင်း။
*   **`input_ids`**: Tokenizer မှ ထုတ်ပေးသော tokens တစ်ခုစီ၏ ထူးခြားသော ဂဏန်းဆိုင်ရာ ID များ။
*   **`attention_mask`**: မော်ဒယ်ကို အာရုံစိုက်သင့်သည့် tokens များနှင့် လျစ်လျူရှုသင့်သည့် (padding) tokens များကို ခွဲခြားပေးသည့် binary mask။
*   **`AutoModel` Class**: Hugging Face Transformers library မှာ ပါဝင်တဲ့ class တစ်ခုဖြစ်ပြီး မော်ဒယ်အမည်ကို အသုံးပြုပြီး Transformer model ကို အလိုအလျောက် load လုပ်ပေးသည်။
*   **Hidden States**: Transformer model ၏ အလယ်အလတ် layers များမှ ထုတ်ပေးသော output များ။ ၎င်းတို့သည် input ၏ အကြောင်းအရာဆိုင်ရာ ကိုယ်စားပြုမှုများကို ဖမ်းယူထားသည်။
*   **Features**: Hidden states များကို ရည်ညွှန်းသော အခြားအသုံးအနှုန်းတစ်ခု။
*   **High-dimensional Vector**: dimension များစွာရှိသော vector တစ်ခု။
*   **Batch Size**: မော်ဒယ်က တစ်ပြိုင်နက်တည်း လုပ်ဆောင်သော input sequence အရေအတွက်။
*   **Sequence Length**: input sequence ၏ token အရေအတွက်။
*   **Hidden Size**: hidden states vector တစ်ခု၏ dimension အရွယ်အစား။
*   **`namedtuple`s**: Python တွင် tuple ကဲ့သို့ အလုပ်လုပ်သော်လည်း attribute name များဖြင့် elements များကို ဝင်ရောက်ကြည့်ရှုနိုင်သော data type။
*   **Model Heads**: Transformer model ၏ hidden states များကို သီးခြားလုပ်ငန်းတစ်ခုအတွက် လိုအပ်သော output များအဖြစ် ပြောင်းလဲပေးသော အစိတ်အပိုင်း။ များသောအားဖြင့် linear layers များဖြင့် ဖွဲ့စည်းထားသည်။
*   **Embeddings Layer**: input IDs များကို vector representations များအဖြစ် ပြောင်းလဲပေးသော model layer။
*   **`*Model`**: base Transformer model (hidden states များကို ပြန်ရယူရန်) ကို ကိုယ်စားပြုသော Hugging Face model class family။
*   **`*ForCausalLM`**: Causal Language Modeling (နောက်ထပ် token ကို ခန့်မှန်းခြင်း) အတွက် ဒီဇိုင်းထုတ်ထားသော model class family။
*   **`*ForMaskedLM`**: Masked Language Modeling (ပျောက်ဆုံးနေသော token များကို ဖြည့်စွက်ခြင်း) အတွက် ဒီဇိုင်းထုတ်ထားသော model class family။
*   **`*ForMultipleChoice`**: Multiple Choice question answering အတွက် ဒီဇိုင်းထုတ်ထားသော model class family။
*   **`*ForQuestionAnswering`**: Question Answering လုပ်ငန်းတာဝန်များအတွက် ဒီဇိုင်းထုတ်ထားသော model class family။
*   **`*ForSequenceClassification`**: Sequence Classification လုပ်ငန်းတာဝန်များ (ဥပမာ- sentiment analysis) အတွက် ဒီဇိုင်းထုတ်ထားသော model class family။
*   **`*ForTokenClassification`**: Token Classification လုပ်ငန်းတာဝန်များ (ဥပမာ- Named Entity Recognition) အတွက် ဒီဇိုင်းထုတ်ထားသော model class family။
*   **`AutoModelForSequenceClassification`**: Hugging Face Transformers library မှာ ပါဝင်တဲ့ class တစ်ခုဖြစ်ပြီး sequence classification အတွက် pre-trained model ကို အလိုအလျောက် load လုပ်ပေးသည်။
*   **`outputs.logits`**: မော်ဒယ်၏ နောက်ဆုံး layer မှ ထုတ်ပေးသော raw, unnormalized scores များ။
*   **Logits**: မော်ဒယ်၏ နောက်ဆုံး layer မှ ထုတ်ပေးသော raw, unnormalized scores များ။ ၎င်းတို့သည် ဖြစ်နိုင်ခြေများအဖြစ်သို့ ပြောင်းလဲခြင်းမရှိသေးပါ။
*   **SoftMax Layer**: input numbers များကို 0 နှင့် 1 ကြားရှိ ဖြစ်နိုင်ခြေများအဖြစ်သို့ ပြောင်းလဲပေးသော activation function တစ်ခု။ ၎င်းတို့၏ စုစုပေါင်းသည် 1 ဖြစ်သည်။
*   **Loss Function**: မော်ဒယ်၏ ခန့်မှန်းချက်များနှင့် အမှန်တကယ်တန်ဖိုးများကြား ကွာခြားမှုကို တိုင်းတာသော function တစ်ခု။
*   **Cross Entropy**: Classification လုပ်ငန်းများတွင် အသုံးများသော loss function တစ်ခု။
*   **`torch.nn.functional.softmax(outputs.logits, dim=-1)`**: PyTorch တွင် softmax function ကို `outputs.logits` ပေါ်တွင် နောက်ဆုံး dimension (dim=-1) အတိုင်း အသုံးပြုခြင်း။
*   **`model.config.id2label`**: Model configuration ထဲတွင် `id` (ဂဏန်း) မှ `label` (စာသား) သို့ တွဲချိတ်ပေးသော dictionary တစ်ခု။