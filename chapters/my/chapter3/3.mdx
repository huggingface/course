<FrameworkSwitchCourse {fw} />

# Trainer API ဖြင့် မော်ဒယ်တစ်ခုကို Fine-tuning လုပ်ခြင်း[[fine-tuning-a-model-with-the-trainer-api]]

<CourseFloatingBanner chapter={3}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter3/section3.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter3/section3.ipynb"},
]} />

<Youtube id="nvBXf7s7vTI"/>

🤗 Transformers က ပံ့ပိုးပေးထားတဲ့ pretrained models တွေကို သင်ရဲ့ dataset ပေါ်မှာ ခေတ်မီ အကောင်းဆုံးနည်းလမ်းများနဲ့ fine-tune လုပ်ဖို့ `Trainer` class တစ်ခုကို ပေးစွမ်းပါတယ်။ ယခင်အပိုင်းမှာ ဒေတာ preprocessing လုပ်ငန်းအားလုံးကို လုပ်ဆောင်ပြီးသွားရင်၊ `Trainer` ကို သတ်မှတ်ဖို့ အနည်းငယ်သော အဆင့်များသာ ကျန်တော့မှာပါ။ `Trainer.train()` ကို run ဖို့ ပတ်ဝန်းကျင်ကို ပြင်ဆင်တာက အခက်ခဲဆုံး အပိုင်းဖြစ်နိုင်ပါတယ်၊ ဘာလို့လဲဆိုတော့ ဒါက CPU ပေါ်မှာ အလွန်နှေးကွေးစွာ run မှာဖြစ်လို့ပါ။ သင့်မှာ GPU မရှိဘူးဆိုရင် [Google Colab](https://colab.research.google.com/) မှာ အခမဲ့ GPUs ဒါမှမဟုတ် TPUs ကို ရယူနိုင်ပါတယ်။

> [!TIP]
> 📚 **Training အရင်းအမြစ်များ**: Training ထဲကို မဝင်ခင်၊ ပြည့်စုံသော [🤗 Transformers training guide](https://huggingface.co/docs/transformers/main/en/training) ကို လေ့လာပြီး [fine-tuning cookbook](https://huggingface.co/learn/cookbook/en/fine_tuning_code_llm_on_single_gpu) မှာပါတဲ့ လက်တွေ့ဥပမာတွေကို ရှာဖွေပါ။

အောက်ပါ code ဥပမာတွေက ယခင်အပိုင်းက ဥပမာတွေကို သင်ပြီးသားလို့ ယူဆထားပါတယ်။ သင်လိုအပ်တာတွေကို အကျဉ်းချုပ် ပြန်ဖော်ပြထားပါတယ်။

```py
from datasets import load_dataset
from transformers import AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset("glue", "mrpc")
checkpoint = "bert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


def tokenize_function(example):
    return tokenizer(example["sentence1"], example["sentence2"], truncation=True)


tokenized_datasets = raw_datasets.map(tokenize_function, batched=True)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)
```

### Training[[training]]

ကျွန်တော်တို့ရဲ့ `Trainer` ကို သတ်မှတ်ခြင်းမပြုမီ ပထမအဆင့်ကတော့ `Trainer` က training နဲ့ evaluation အတွက် အသုံးပြုမယ့် hyperparameters အားလုံးပါဝင်တဲ့ `TrainingArguments` class တစ်ခုကို သတ်မှတ်ဖို့ပါပဲ။ သင် ပေးဆောင်ရမယ့် တစ်ခုတည်းသော argument ကတော့ လေ့ကျင့်ပြီးသား model ကို သိမ်းဆည်းမယ့် directory ဖြစ်သလို၊ လမ်းတစ်လျှောက်မှာရှိတဲ့ checkpoints တွေကိုလည်း သိမ်းဆည်းမယ့် directory ပါပဲ။ ကျန်တာတွေအားလုံးအတွက်တော့ default တွေကို ချန်ထားခဲ့နိုင်ပါတယ်၊ ဒါတွေက အခြေခံ fine-tuning အတွက် ကောင်းကောင်းအလုပ်လုပ်ပါလိမ့်မယ်။

```py
from transformers import TrainingArguments

training_args = TrainingArguments("test-trainer")
```

training လုပ်နေစဉ်မှာ သင်ရဲ့ model ကို Hub ကို အလိုအလျောက် upload လုပ်ချင်တယ်ဆိုရင် `TrainingArguments` မှာ `push_to_hub=True` ကို ထည့်သွင်းပေးပါ။ ဒီအကြောင်းကို [Chapter 4](/course/chapter4/3) မှာ ပိုမိုလေ့လာပါမယ်။

> [!TIP]
> 🚀 **Advanced Configuration**: ရရှိနိုင်သော training arguments အားလုံးနှင့် optimization strategies များအကြောင်း အသေးစိတ်အချက်အလက်များအတွက် [TrainingArguments documentation](https://huggingface.co/docs/transformers/main/en/main_classes/trainer#transformers.TrainingArguments) နှင့် [training configuration cookbook](https://huggingface.co/learn/cookbook/en/fine_tuning_code_llm_on_single_gpu) ကို ကြည့်ရှုပါ။

ဒုတိယအဆင့်ကတော့ ကျွန်တော်တို့ရဲ့ model ကို သတ်မှတ်ဖို့ပါပဲ။ [ယခင်အခန်း](/course/chapter2) မှာလိုပဲ၊ label နှစ်ခုပါတဲ့ `AutoModelForSequenceClassification` class ကို ကျွန်တော်တို့ အသုံးပြုပါမယ်။

```py
from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)
```

ဒီ pretrained model ကို instantiate လုပ်ပြီးနောက် သတိပေးချက်တစ်ခု ရရှိတာကို သင်သတိပြုမိပါလိမ့်မယ်။ ဒါက BERT ကို sentence pair တွေကို classify လုပ်ဖို့ pretrain လုပ်မထားလို့ပါပဲ၊ ဒါကြောင့် pretrained model ရဲ့ head ကို ဖယ်ရှားပြီး sequence classification အတွက် သင့်လျော်တဲ့ head အသစ်တစ်ခုကို ထည့်သွင်းထားပါတယ်။ သတိပေးချက်တွေက အချို့ weights တွေကို အသုံးမပြုခဲ့ဘူး (ဖယ်ရှားလိုက်တဲ့ pretraining head နဲ့ ကိုက်ညီတဲ့ weights တွေ) နဲ့ အချို့ကိုတော့ ကျပန်း (randomly) initialize လုပ်ခဲ့တယ် (head အသစ်အတွက် weights တွေ) ဆိုတာကို ဖော်ပြပါတယ်။ ဒါက model ကို train လုပ်ဖို့ သင့်ကို အားပေးနေတာဖြစ်ပြီး၊ ဒါဟာ ကျွန်တော်တို့ အခုလုပ်မယ့်အရာပါပဲ။

ကျွန်တော်တို့မှာ model ရှိပြီးတာနဲ့၊ အခုအထိ တည်ဆောက်ခဲ့တဲ့ objects အားလုံးကို `model`၊ `training_args`၊ training နဲ့ validation datasets တွေ၊ ကျွန်တော်တို့ရဲ့ `data_collator` နဲ့ ကျွန်တော်တို့ရဲ့ `processing_class` တွေကို ပေးပို့ခြင်းဖြင့် `Trainer` တစ်ခုကို သတ်မှတ်နိုင်ပါပြီ။ `processing_class` parameter က Trainer ကို processing အတွက် ဘယ် tokenizer ကို အသုံးပြုရမယ်ဆိုတာကို ပြောပြပေးတဲ့ ပိုမိုအသစ်သော ထပ်တိုးမှုတစ်ခုပါ။

```py
from transformers import Trainer

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    processing_class=tokenizer,
)
```

သင်က tokenizer တစ်ခုကို `processing_class` အဖြစ် ပေးပို့တဲ့အခါ၊ `Trainer` က အသုံးပြုမယ့် default `data_collator` က `DataCollatorWithPadding` ဖြစ်ပါလိမ့်မယ်။ ဒီအခြေအနေမှာတော့ သင် `data_collator=data_collator` လိုင်းကို ချန်လှပ်ထားနိုင်ပါတယ်၊ ဒါပေမယ့် processing pipeline ရဲ့ ဒီအရေးကြီးတဲ့ အစိတ်အပိုင်းကို သင့်ကို ပြသဖို့ ဒီနေရာမှာ ထည့်သွင်းထားပါတယ်။

> [!TIP]
> 📖 **ပိုမိုလေ့လာရန်**: Trainer class နှင့် ၎င်း၏ parameters များအကြောင်း ပြည့်စုံသောအသေးစိတ်အချက်အလက်များအတွက် [Trainer API documentation](https://huggingface.co/docs/transformers/main/en/main_classes/trainer) ကို ကြည့်ရှုပြီး [training cookbook recipes](https://huggingface.co/learn/cookbook/en/fine_tuning_code_llm_on_single_gpu) တွင် အဆင့်မြင့် အသုံးပြုပုံများကို လေ့လာပါ။

ကျွန်တော်တို့ရဲ့ dataset ပေါ်မှာ model ကို fine-tune လုပ်ဖို့အတွက်၊ ကျွန်တော်တို့ရဲ့ `Trainer` ရဲ့ `train()` method ကို ခေါ်ဆိုရုံပါပဲ-

```py
trainer.train()
```

ဒါက fine-tuning ကို စတင်ပါလိမ့်မယ် (GPU ပေါ်မှာ မိနစ်အနည်းငယ် ကြာမြင့်ပါလိမ့်မယ်) ပြီးတော့ training loss ကို step ၅၀၀ တိုင်းမှာ အစီရင်ခံပါလိမ့်မယ်။ ဒါပေမယ့် သင့် model ဘယ်လောက် ကောင်းကောင်း (ဒါမှမဟုတ် ဆိုးဆိုး) အလုပ်လုပ်နေတယ်ဆိုတာကိုတော့ ပြောပြမှာ မဟုတ်ပါဘူး။ ဒါက အောက်ပါအချက်တွေကြောင့်ပါ 

1.  `TrainingArguments` မှာ `eval_strategy` ကို `"steps"` (eval_steps တိုင်းမှာ evaluate လုပ်ပါ) ဒါမှမဟုတ် `"epoch"` (epoch တစ်ခုစီရဲ့ အဆုံးမှာ evaluate လုပ်ပါ) အဖြစ် သတ်မှတ်ခြင်းဖြင့် training လုပ်နေစဉ် evaluate လုပ်ဖို့ ကျွန်တော်တို့ `Trainer` ကို မပြောခဲ့ပါဘူး။
2.  အဲဒီ evaluation လုပ်နေစဉ် metric တွက်ချက်ဖို့ `compute_metrics()` function တစ်ခုကို ကျွန်တော်တို့ `Trainer` ကို မပေးခဲ့ပါဘူး (မဟုတ်ရင် evaluation က loss ကိုသာ print လုပ်မှာဖြစ်ပြီး၊ ဒါက အလိုလိုနားလည်ရခက်တဲ့ နံပါတ်တစ်ခုပါ)။

### Evaluation[[evaluation]]

အသုံးဝင်တဲ့ `compute_metrics()` function တစ်ခုကို ဘယ်လိုတည်ဆောက်ရမလဲ၊ နောက်တစ်ကြိမ် train လုပ်တဲ့အခါ ဘယ်လိုအသုံးပြုရမလဲဆိုတာ ကြည့်ရအောင်။ function က `EvalPrediction` object (အမည်ပါတဲ့ tuple တစ်ခုဖြစ်ပြီး `predictions` field နဲ့ `label_ids` field တွေ ပါဝင်ပါတယ်) ကို ယူရပါမယ်၊ ပြီးတော့ strings တွေကို floats တွေနဲ့ map လုပ်ထားတဲ့ dictionary တစ်ခုကို ပြန်ပို့ပါလိမ့်မယ် (strings တွေက ပြန်ပို့တဲ့ metrics တွေရဲ့ နာမည်တွေဖြစ်ပြီး၊ floats တွေက ၎င်းတို့ရဲ့ values တွေပါ)။ ကျွန်တော်တို့ရဲ့ model ကနေ predictions တွေရဖို့၊ `Trainer.predict()` command ကို အသုံးပြုနိုင်ပါတယ်။

```py
predictions = trainer.predict(tokenized_datasets["validation"])
print(predictions.predictions.shape, predictions.label_ids.shape)
```

```python out
(408, 2) (408,)
```

`predict()` method ရဲ့ output က `predictions`, `label_ids`, နဲ့ `metrics` ဆိုတဲ့ fields သုံးခုပါတဲ့ အခြားအမည်ပါတဲ့ tuple တစ်ခုပါပဲ။ `metrics` field ကတော့ ပေးပို့ထားတဲ့ dataset ပေါ်က loss ကိုသာမက အချိန် metrics အချို့ (စုစုပေါင်းနဲ့ ပျမ်းမျှအားဖြင့် ခန့်မှန်းဖို့ ဘယ်လောက်ကြာသလဲ) ကိုလည်း ပါဝင်ပါလိမ့်မယ်။ ကျွန်တော်တို့ `compute_metrics()` function ကို ဖြည့်စွက်ပြီး `Trainer` ကို ပေးပို့လိုက်တာနဲ့၊ အဲဒီ field က `compute_metrics()` ကနေ ပြန်ပို့တဲ့ metrics တွေကိုလည်း ပါဝင်ပါလိမ့်မယ်။

သင်တွေ့ရတဲ့အတိုင်း၊ `predictions` က 408 x 2 shape ရှိတဲ့ two-dimensional array တစ်ခုပါ (408 က ကျွန်တော်တို့ `predict()` ကို ပေးပို့ခဲ့တဲ့ dataset ထဲက element အရေအတွက်ပါ)။ ဒါတွေက ကျွန်တော်တို့ `predict()` ကို ပေးပို့ခဲ့တဲ့ dataset ရဲ့ element တစ်ခုစီအတွက် logits တွေပါ (သင် [ယခင်အခန်း](/course/chapter2) မှာ တွေ့ခဲ့တဲ့အတိုင်း၊ Transformer model တွေအားလုံးက logits တွေကို ပြန်ပို့ပါတယ်)။ ၎င်းတို့ကို ကျွန်တော်တို့ရဲ့ labels တွေနဲ့ နှိုင်းယှဉ်နိုင်တဲ့ predictions တွေအဖြစ် ပြောင်းလဲဖို့အတွက်၊ ဒုတိယ axis မှာ အများဆုံး value ရှိတဲ့ index ကို ယူဖို့ လိုအပ်ပါတယ်။

```py
import numpy as np

preds = np.argmax(predictions.predictions, axis=-1)
```

အခု ကျွန်တော်တို့ ဒီ `preds` တွေကို labels တွေနဲ့ နှိုင်းယှဉ်နိုင်ပါပြီ။ ကျွန်တော်တို့ရဲ့ `compute_metric()` function ကို တည်ဆောက်ဖို့အတွက် 🤗 [Evaluate](https://github.com/huggingface/evaluate/) library က metrics တွေကို အားကိုးပါမယ်။ `evaluate.load()` function ကို အသုံးပြုပြီး dataset ကို loading လုပ်သလိုပဲ MRPC dataset နဲ့ သက်ဆိုင်တဲ့ metrics တွေကို အလွယ်တကူ load လုပ်နိုင်ပါတယ်။ ပြန်ပို့တဲ့ object မှာ metric တွက်ချက်မှုကို လုပ်ဆောင်ဖို့ အသုံးပြုနိုင်တဲ့ `compute()` method တစ်ခု ပါရှိပါတယ်။

```py
import evaluate

metric = evaluate.load("glue", "mrpc")
metric.compute(predictions=preds, references=predictions.label_ids)
```

```python out
{'accuracy': 0.8578431372549019, 'f1': 0.8996539792387542}
```

> [!TIP]
> [🤗 Evaluate documentation](https://huggingface.co/docs/evaluate/) တွင် မတူညီသော evaluation metrics များနှင့် strategies များအကြောင်း လေ့လာပါ။

သင်ရရှိမယ့် တိကျတဲ့ရလဒ်တွေက မော်ဒယ် head ရဲ့ ကျပန်း (random) initialization ကြောင့် ပြောင်းလဲနိုင်ပါတယ်၊ ဒါပေမယ့် ဒီနေရာမှာ ကျွန်တော်တို့ရဲ့ မော်ဒယ်က validation set မှာ 85.78% accuracy နဲ့ 89.97% F1 score ရရှိတာကို တွေ့ရပါတယ်။ ဒါတွေက GLUE benchmark အတွက် MRPC dataset မှာ ရလဒ်တွေကို အကဲဖြတ်ဖို့ အသုံးပြုတဲ့ metrics နှစ်ခုပါပဲ။ [BERT paper](https://arxiv.org/pdf/1810.04805.pdf) မှာပါတဲ့ ဇယားက base model အတွက် F1 score 88.9 လို့ ဖော်ပြထားပါတယ်။ ကျွန်တော်တို့ အခု အသုံးပြုနေတာက `cased` model ဖြစ်ပြီး၊ အဲဒါက ပိုကောင်းတဲ့ရလဒ်ကို ရှင်းပြပါတယ်။

အားလုံးကို ပေါင်းစပ်လိုက်ရင်၊ ကျွန်တော်တို့ `compute_metrics()` function ကို ရရှိပါတယ်။

```py
def compute_metrics(eval_preds):
    metric = evaluate.load("glue", "mrpc")
    logits, labels = eval_preds
    predictions = np.argmax(logits, axis=-1)
    return metric.compute(predictions=predictions, references=labels)
```

ပြီးတော့ epoch တစ်ခုစီရဲ့ အဆုံးမှာ metrics တွေ အစီရင်ခံတာကို လက်တွေ့အသုံးပြုတာကို ကြည့်ဖို့အတွက်၊ ဒီ `compute_metrics()` function နဲ့ `Trainer` အသစ်တစ်ခုကို ဘယ်လိုသတ်မှတ်ရမလဲဆိုတာ ဤတွင် ဖော်ပြထားပါတယ်-

```py
training_args = TrainingArguments("test-trainer", eval_strategy="epoch")
model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    processing_class=tokenizer,
    compute_metrics=compute_metrics,
)
```

၎င်း၏ `eval_strategy` ကို `"epoch"` အဖြစ် သတ်မှတ်ထားသော `TrainingArguments` အသစ်တစ်ခုနှင့် model အသစ်တစ်ခုကို ဖန်တီးထားတာကို သတိပြုပါ။ မဟုတ်ရင်၊ ကျွန်တော်တို့ အရင်က train ထားပြီးသား model ကိုပဲ ဆက်လက် training လုပ်နေမှာ ဖြစ်ပါတယ်။ training run အသစ်တစ်ခု စတင်ရန်၊ ကျွန်တော်တို့ အောက်ပါအတိုင်း execute လုပ်ပါ။

```py
trainer.train()
```

ဒီတစ်ခါတော့ training loss အပြင် epoch တစ်ခုစီရဲ့ အဆုံးမှာ validation loss နဲ့ metrics တွေကိုပါ အစီရင်ခံပါလိမ့်မယ်။ ထပ်မံပြောရရင်၊ model ရဲ့ random head initialization ကြောင့် သင်ရရှိမယ့် တိကျတဲ့ accuracy/F1 score က ကျွန်တော်တို့ ရှာဖွေတွေ့ရှိတာနဲ့ အနည်းငယ် ကွာခြားနိုင်ပေမယ့်၊ အနီးစပ်ဆုံး တူညီသင့်ပါတယ်။

### Advanced Training Features[[advanced-training-features]]

`Trainer` မှာ ခေတ်မီ deep learning အကောင်းဆုံးနည်းလမ်းတွေကို လက်လှမ်းမီစေတဲ့ built-in features များစွာ ပါဝင်ပါတယ်-

**Mixed Precision Training**: ပိုမိုမြန်ဆန်သော training နှင့် memory အသုံးပြုမှု လျှော့ချရန်အတွက် သင်၏ training arguments တွင် `fp16=True` ကို အသုံးပြုပါ။

```py
training_args = TrainingArguments(
    "test-trainer",
    eval_strategy="epoch",
    fp16=True,  # Mixed precision ကို ဖွင့်ပါ
)
```

**Gradient Accumulation**: GPU memory နည်းပါးတဲ့အခါ ပိုကြီးမားတဲ့ batch sizes တွေကို ထိထိရောက်ရောက် အသုံးပြုနိုင်ဖို့-

```py
training_args = TrainingArguments(
    "test-trainer",
    eval_strategy="epoch",
    per_device_train_batch_size=4,
    gradient_accumulation_steps=4,  # ထိရောက်သော batch size = 4 * 4 = 16
)
```

**Learning Rate Scheduling**: Trainer က default အားဖြင့် linear decay ကို အသုံးပြုပါတယ်၊ ဒါပေမယ့် ဒါကို သင် စိတ်ကြိုက်ပြင်ဆင်နိုင်ပါတယ်။

```py
training_args = TrainingArguments(
    "test-trainer",
    eval_strategy="epoch",
    learning_rate=2e-5,
    lr_scheduler_type="cosine",  # မတူညီသော schedulers များကို စမ်းသပ်ကြည့်ပါ
)
```

> [!TIP]
> 🎯 **စွမ်းဆောင်ရည် မြှင့်တင်ရေး**: distributed training၊ memory optimization နှင့် hardware-specific optimizations အပါအဝင် ပိုမိုအဆင့်မြင့်သော training နည်းလမ်းများအတွက် [🤗 Transformers performance guide](https://huggingface.co/docs/transformers/main/en/performance) ကို လေ့လာပါ။

`Trainer` က GPUs များစွာ ဒါမှမဟုတ် TPUs တွေပေါ်မှာ အလိုအလျောက် အလုပ်လုပ်နိုင်ပြီး distributed training အတွက် options များစွာကို ပေးစွမ်းပါတယ်။ ဒါတွေအားလုံးကို Chapter 10 မှာ ကျွန်တော်တို့ ဆွေးနွေးသွားပါမယ်။

ဒါက `Trainer` API ကို အသုံးပြုပြီး fine-tuning လုပ်ခြင်းနိဒါန်းကို နိဂုံးချုပ်လိုက်ပါပြီ။ အဖြစ်များဆုံး NLP လုပ်ငန်းအများစုအတွက် ဒါကို ဘယ်လိုလုပ်ဆောင်ရမယ်ဆိုတဲ့ ဥပမာတစ်ခုကို [Chapter 7](/course/chapter7) မှာ ပေးထားပါလိမ့်မယ်၊ ဒါပေမယ့် အခုတော့ pure PyTorch training loop နဲ့ ဒီအရာတွေကို ဘယ်လိုလုပ်ဆောင်ရမလဲဆိုတာ ကြည့်ရအောင်။

> [!TIP]
> 📝 **ဥပမာများ ထပ်မံကြည့်ရှုရန်**: ပြည့်စုံသော [🤗 Transformers notebooks](https://huggingface.co/docs/transformers/main/en/notebooks) စုစည်းမှုကို ကြည့်ရှုပါ။

## အခန်း၏ ဗဟုသုတစစ်ဆေးခြင်း[[section-quiz]]

Trainer API နှင့် fine-tuning concepts များအကြောင်း သင့်နားလည်မှုကို စမ်းသပ်ပါ။

### 1. Trainer မှာပါတဲ့ `processing_class` parameter ရဲ့ ရည်ရွယ်ချက်က ဘာလဲ။

<Question
	choices={[
		{
			text: "၎င်းသည် မည်သည့် model architecture ကို အသုံးပြုရမည်ကို သတ်မှတ်သည်။",
			explain: "Model architecture ကို model ကို load လုပ်တဲ့အခါ သတ်မှတ်တာဖြစ်ပြီး Trainer မှာ မဟုတ်ပါဘူး။"
		},
		{
			text: "၎င်းသည် ဒေတာများကို စီမံဆောင်ရွက်ရန် မည်သည့် tokenizer ကို အသုံးပြုရမည်ကို Trainer ကို ပြောပြသည်။",
			explain: "processing_class parameter သည် Trainer ကို မည်သည့် tokenizer ကို အသုံးပြုရမည်ကို သိရှိစေရန် ကူညီပေးသည့် ခေတ်မီထပ်တိုးမှုတစ်ခုဖြစ်သည်။",
            correct: true
		},
		{
			text: "၎င်းသည် training အတွက် batch size ကို ဆုံးဖြတ်သည်။",
			explain: "Batch size ကို TrainingArguments မှာ သတ်မှတ်တာဖြစ်ပြီး processing_class မှတစ်ဆင့် မဟုတ်ပါဘူး။"
		},
        {
			text: "၎င်းသည် evaluation frequency ကို ထိန်းချုပ်သည်။",
			explain: "Evaluation frequency ကို TrainingArguments မှာရှိတဲ့ eval_strategy က ထိန်းချုပ်ပါတယ်။"
		}
	]}
/>

### 2. TrainingArguments parameter က training လုပ်နေစဉ် evaluation ကို ဘယ်လောက်ကြာကြာ လုပ်ရမယ်ဆိုတာကို ဘယ်လိုထိန်းချုပ်သလဲ။

<Question
	choices={[
		{
			text: "eval_frequency",
			explain: "TrainingArguments မှာ eval_frequency parameter မရှိပါဘူး။"
		},
		{
			text: "eval_strategy",
			explain: "eval_strategy ကို 'epoch', 'steps', ဒါမှမဟုတ် 'no' အဖြစ် သတ်မှတ်ခြင်းဖြင့် evaluation အချိန်ကို ထိန်းချုပ်နိုင်ပါတယ်။",
            correct: true
		},
		{
			text: "evaluation_steps",
			explain: "eval_steps က evaluation တွေကြားက steps အရေအတွက်ကို သတ်မှတ်တာဖြစ်ပေမယ့် eval_strategy က evaluation လုပ်ရင် လုပ်မလုပ်/ဘယ်တော့လုပ်မယ်ဆိုတာကို ဆုံးဖြတ်ပါတယ်။"
		},
        {
			text: "do_eval",
			explain: "ခေတ်မီ TrainingArguments တွေမှာ do_eval parameter မရှိပါဘူး။"
		}
	]}
/>

### 3. TrainingArguments မှာ `fp16=True` က ဘာကို ဖွင့်ပေးသလဲ။

<Question
	choices={[
		{
			text: "ပိုမိုမြန်ဆန်သော training အတွက် 16-bit integer precision။",
			explain: "fp16 က floating-point precision ကို ရည်ညွှန်းတာဖြစ်ပြီး integer precision မဟုတ်ပါဘူး။"
		},
		{
			text: "ပိုမိုမြန်ဆန်သော training နှင့် memory အသုံးပြုမှု လျှော့ချရန်အတွက် 16-bit floating-point numbers ဖြင့် mixed precision training။",
			explain: "Mixed precision training သည် forward pass အတွက် 16-bit floats များကို အသုံးပြုပြီး gradients အတွက် 32-bit များကို အသုံးပြု၍ အမြန်နှုန်းကို တိုးတက်စေကာ memory အသုံးပြုမှုကို လျှော့ချပေးသည်။",
            correct: true
		},
		{
			text: "အတိအကျ 16 epochs အတွက် training လုပ်ခြင်း။",
			explain: "fp16 နဲ့ epochs အရေအတွက်နဲ့ ဘာမှမဆိုင်ပါဘူး။"
		},
        {
			text: "distributed training အတွက် GPUs ၁၆ ခု အသုံးပြုခြင်း။",
			explain: "GPUs အရေအတွက်ကို fp16 parameter က ထိန်းချုပ်တာ မဟုတ်ပါဘူး။"
		}
	]}
/>

### 4. Trainer မှာပါတဲ့ `compute_metrics` function ရဲ့ အခန်းကဏ္ဍက ဘာလဲ။

<Question
	choices={[
		{
			text: "၎င်းသည် training လုပ်နေစဉ် loss ကို တွက်ချက်သည်။",
			explain: "Loss တွက်ချက်မှုကို model က အလိုအလျောက် ကိုင်တွယ်တာဖြစ်ပြီး compute_metrics က မဟုတ်ပါဘူး။"
		},
		{
			text: "၎င်းသည် logits များကို predictions များအဖြစ် ပြောင်းလဲပြီး accuracy နှင့် F1 ကဲ့သို့သော evaluation metrics များကို တွက်ချက်သည်။",
			explain: "compute_metrics သည် predictions နှင့် labels များကို ယူပြီး evaluation အတွက် metrics များကို ပြန်ပေးသည်။",
            correct: true
		},
		{
			text: "၎င်းသည် မည်သည့် optimizer ကို အသုံးပြုရမည်ကို ဆုံးဖြတ်သည်။",
			explain: "Optimizer ရွေးချယ်မှုကို compute_metrics က ကိုင်တွယ်တာ မဟုတ်ပါဘူး။"
		},
        {
			text: "၎င်းသည် training data ကို preprocessing လုပ်သည်။",
			explain: "ဒေတာ preprocessing ကို training မလုပ်ခင် လုပ်ဆောင်တာဖြစ်ပြီး evaluation လုပ်နေစဉ် compute_metrics က မဟုတ်ပါဘူး။"
		}
	]}
/>

### 5. Trainer ကို `eval_dataset` မပေးတဲ့အခါ ဘာဖြစ်မလဲ။

<Question
	choices={[
		{
			text: "Training က error နဲ့ fail ဖြစ်သွားပါလိမ့်မယ်။",
			explain: "eval_dataset မရှိဘဲ training ကို ဆက်လုပ်နိုင်ပါတယ်၊ ဒါပေမယ့် evaluation metrics တွေ ရရှိမှာ မဟုတ်ပါဘူး။"
		},
		{
			text: "Trainer က training data ကို evaluation အတွက် အလိုအလျောက် ခွဲထုတ်ပါလိမ့်မယ်။",
			explain: "Trainer က validation splits တွေကို အလိုအလျောက် ဖန်တီးပေးတာ မဟုတ်ပါဘူး။"
		},
		{
			text: "Training လုပ်နေစဉ် evaluation metrics တွေ မရရှိနိုင်ပေမယ့် training ကတော့ အလုပ်လုပ်နေပါလိမ့်မယ်။",
			explain: "Evaluation က optional ဖြစ်ပါတယ် - ဒါမရှိဘဲ train လုပ်နိုင်ပေမယ့် validation metrics တွေ မြင်ရမှာ မဟုတ်ပါဘူး။",
            correct: true
		},
        {
			text: "Model က training data ကို evaluation အတွက် အသုံးပြုပါလိမ့်မယ်။",
			explain: "Trainer က training data ကို evaluation အတွက် အလိုအလျောက် အသုံးပြုမှာ မဟုတ်ပါဘူး - ၎င်းသည် ရိုးရှင်းစွာ evaluation မလုပ်ဆောင်ပါဘူး။"
		}
	]}
/>

### 6. Gradient accumulation ဆိုတာ ဘာလဲ၊ ဘယ်လို ဖွင့်ရမလဲ။

<Question
	choices={[
		{
			text: "၎င်းသည် gradients များကို disk ထဲသို့ သိမ်းဆည်းခြင်းဖြစ်ပြီး save_gradients=True ဖြင့် ဖွင့်သည်။",
			explain: "Gradient accumulation ဟာ gradients တွေကို disk ထဲသို့ သိမ်းဆည်းခြင်း မပါဝင်ပါဘူး။"
		},
		{
			text: "၎င်းသည် updating မလုပ်မီ batches အများအပြားပေါ်မှာ gradients များကို စုဆောင်းခြင်းဖြစ်ပြီး gradient_accumulation_steps ဖြင့် ဖွင့်သည်။",
			explain: "ဒါက forward passes များစွာပေါ်မှာ gradients များကို စုဆောင်းခြင်းဖြင့် ပိုကြီးမားသော batch sizes များကို အတုယူနိုင်စေသည်။",
            correct: true
		},
		{
			text: "၎င်းသည် gradient တွက်ချက်မှုကို အရှိန်မြှင့်ပေးပြီး fp16 ဖြင့် အလိုအလျောက် ဖွင့်သည်။",
			explain: "fp16 က training ကို အရှိန်မြှင့်နိုင်သော်လည်း၊ gradient accumulation က သီးခြားနည်းလမ်းတစ်ခုပါ။"
		},
        {
			text: "၎င်းသည် gradient overflow ကို ကာကွယ်ပေးပြီး gradient_clipping=True ဖြင့် ဖွင့်သည်။",
			explain: "ဒါက gradient clipping ကို ဖော်ပြတာဖြစ်ပြီး gradient accumulation မဟုတ်ပါဘူး။"
		}
	]}
/>

> [!TIP]
> 💡 **အဓိက အချက်များ:**
> - `Trainer` API သည် training ၏ ရှုပ်ထွေးမှုအများစုကို ကိုင်တွယ်ပေးသည့် အဆင့်မြင့် interface တစ်ခုဖြစ်သည်။
> - သင့်ဒေတာကို မှန်ကန်စွာ ကိုင်တွယ်ရန် `processing_class` ကို အသုံးပြု၍ tokenizer ကို သတ်မှတ်ပါ။
> - `TrainingArguments` သည် training ၏ ကဏ္ဍအားလုံးကို ထိန်းချုပ်သည်- learning rate, batch size, evaluation strategy နှင့် optimizations များ။
> - `compute_metrics` သည် training loss အပြင် စိတ်ကြိုက် evaluation metrics များကို ဖွင့်ပေးသည်။
> - Mixed precision (`fp16=True`) နှင့် gradient accumulation ကဲ့သို့သော ခေတ်မီ features များသည် training ထိရောက်မှုကို သိသိသာသာ တိုးတက်စေနိုင်သည်။

## ဝေါဟာရ ရှင်းလင်းချက် (Glossary)

*   **Fine-tuning**: ကြိုတင်လေ့ကျင့်ထားပြီးသား (pre-trained) မော်ဒယ်တစ်ခုကို သီးခြားလုပ်ငန်းတစ်ခု (specific task) အတွက် အနည်းငယ်သော ဒေတာနဲ့ ထပ်မံလေ့ကျင့်ပေးခြင်းကို ဆိုလိုပါတယ်။
*   **Trainer API**: Hugging Face Transformers library မှ model များကို ထိရောက်စွာ လေ့ကျင့်ရန်အတွက် ဒီဇိုင်းထုတ်ထားသော မြင့်မားသောအဆင့် (high-level) API (Application Programming Interface)။
*   **Pretrained Models**: အကြီးစား ဒေတာအမြောက်အမြားဖြင့် ကြိုတင်လေ့ကျင့်ထားပြီးဖြစ်သော AI (Artificial Intelligence) မော်ဒယ်များ။
*   **Dataset**: AI မော်ဒယ်တွေ လေ့ကျင့်ဖို့အတွက် အသုံးပြုတဲ့ ဒေတာအစုအဝေးတစ်ခုပါ။
*   **Preprocessing**: ဒေတာများကို model က နားလည်ပြီး လုပ်ဆောင်နိုင်တဲ့ ပုံစံအဖြစ် ပြောင်းလဲပြင်ဆင်ခြင်း လုပ်ငန်းစဉ်။
*   **GPU (Graphics Processing Unit)**: ဂရပ်ဖစ်လုပ်ဆောင်မှုအတွက် အထူးဒီဇိုင်းထုတ်ထားသော processor တစ်မျိုးဖြစ်သော်လည်း AI/ML (Artificial Intelligence/Machine Learning) လုပ်ငန်းများတွင် အရှိန်မြှင့်ရန် အသုံးများသည်။
*   **CPU (Central Processing Unit)**: ကွန်ပျူတာ၏ ပင်မ processor ဖြစ်ပြီး အထွေထွေလုပ်ငန်းများကို လုပ်ဆောင်သည်။
*   **TPU (Tensor Processing Unit)**: Google မှ AI/ML (Artificial Intelligence/Machine Learning) workloads များအတွက် အထူးဒီဇိုင်းထုတ်ထားသော processor တစ်မျိုး။
*   **Google Colab**: Google မှ ပံ့ပိုးပေးထားသော cloud-based Jupyter Notebook environment တစ်ခုဖြစ်ပြီး Python code များကို web browser မှတစ်ဆင့် run နိုင်စေသည်။ အခမဲ့ GPU/TPU အသုံးပြုခွင့်ပေးသည်။
*   **`datasets` (Library)**: Hugging Face က ထုတ်လုပ်ထားတဲ့ library တစ်ခုဖြစ်ပြီး AI မော်ဒယ်တွေ လေ့ကျင့်ဖို့အတွက် ဒေတာအစုအဝေး (datasets) တွေကို လွယ်လွယ်ကူကူ ဝင်ရောက်ရယူ၊ စီမံခန့်ခွဲပြီး အသုံးပြုနိုင်စေပါတယ်။
*   **`transformers` (Library)**: Hugging Face က ထုတ်လုပ်ထားတဲ့ library တစ်ခုဖြစ်ပြီး Transformer မော်ဒယ်တွေကို အသုံးပြုပြီး Natural Language Processing (NLP), computer vision, audio processing စတဲ့ နယ်ပယ်တွေမှာ အဆင့်မြင့် AI မော်ဒယ်တွေကို တည်ဆောက်ပြီး အသုံးပြုနိုင်စေပါတယ်။
*   **`AutoTokenizer`**: Hugging Face Transformers library မှာ ပါဝင်တဲ့ class တစ်ခုဖြစ်ပြီး မော်ဒယ်အမည်ကို အသုံးပြုပြီး သက်ဆိုင်ရာ tokenizer ကို အလိုအလျောက် load လုပ်ပေးသည်။
*   **`DataCollatorWithPadding`**: Hugging Face Transformers library မှ ပံ့ပိုးပေးသော class တစ်ခုဖြစ်ပြီး dynamic padding ကို အသုံးပြု၍ batch တစ်ခုအတွင်း samples များကို စုစည်းပေးသည်။
*   **`load_dataset()` Function**: Hugging Face Datasets library မှ dataset များကို download လုပ်ပြီး cache လုပ်ရန် အသုံးပြုသော function။
*   **Checkpoint**: မော်ဒယ်၏ weights များနှင့် အခြားဖွဲ့စည်းပုံများ (configuration) ကို သတ်မှတ်ထားသော အချိန်တစ်ခုတွင် သိမ်းဆည်းထားခြင်း။
*   **`tokenize_function()`**: စာသားများကို tokens အဖြစ် ပြောင်းလဲပေးသည့် function။
*   **`raw_datasets`**: Preprocessing မလုပ်ရသေးသော dataset များ ပါဝင်သော object။
*   **`tokenized_datasets`**: Tokenization ပြုလုပ်ပြီးသော dataset များ ပါဝင်သော object။
*   **`batched=True`**: `map()` method တွင် အသုံးပြုသော argument တစ်ခုဖြစ်ပြီး function ကို dataset ၏ element အများအပြားပေါ်တွင် တစ်ပြိုင်နက်တည်း အသုံးပြုစေသည်။
*   **Hyperparameters**: AI မော်ဒယ်တစ်ခုကို လေ့ကျင့်ရာတွင် အသုံးပြုသူက သတ်မှတ်ပေးရသော parameters များ (ဥပမာ- learning rate, batch size)။
*   **TrainingArguments Class**: Trainer ကို အသုံးပြု၍ မော်ဒယ်လေ့ကျင့်ရာတွင် လိုအပ်သော hyperparameters များနှင့် အခြားအခြေအနေများကို သတ်မှတ်ရန် အသုံးပြုသည့် class။
*   **Evaluation**: မော်ဒယ်၏ စွမ်းဆောင်ရည်ကို တိုင်းတာခြင်း။
*   **`test-trainer`**: လေ့ကျင့်ပြီးသား model နှင့် checkpoints များကို သိမ်းဆည်းမည့် directory အမည်။
*   **`push_to_hub=True`**: training လုပ်နေစဉ် model ကို Hugging Face Hub သို့ အလိုအလျောက် upload လုပ်ရန် သတ်မှတ်သော argument။
*   **Hugging Face Hub**: AI မော်ဒယ်တွေ၊ datasets တွေနဲ့ demo တွေကို အခြားသူတွေနဲ့ မျှဝေဖို့၊ ရှာဖွေဖို့နဲ့ ပြန်လည်အသုံးပြုဖို့အတွက် အွန်လိုင်း platform တစ်ခု ဖြစ်ပါတယ်။
*   **`AutoModelForSequenceClassification` Class**: Hugging Face Transformers library မှာ ပါဝင်တဲ့ class တစ်ခုဖြစ်ပြီး sequence classification အတွက် pre-trained model ကို အလိုအလျောက် load လုပ်ပေးသည်။
*   **`num_labels`**: Classification လုပ်ငန်းအတွက် label (အမျိုးအစား) အရေအတွက်။
*   **Head (Model Head)**: Transformer မော်ဒယ်၏ အဓိကကိုယ်ထည် (body) အပေါ်တွင် ထည့်သွင်းထားသော အပိုအစိတ်အပိုင်း (layer တစ်ခု သို့မဟုတ် နှစ်ခု) ဖြစ်ပြီး သီးခြားလုပ်ငန်း (task) တစ်ခုအတွက် မော်ဒယ်၏ output များကို ချိန်ညှိပေးသည်။ ဥပမာ- sequence classification အတွက် head သည် logits ကို ထုတ်ပေးသည်။
*   **Randomly Initialized**: မော်ဒယ်၏ parameters (weights) များကို စတင်ချိန်တွင် ကျပန်းတန်ဖိုးများ ပေးခြင်း။
*   **`Trainer` Class**: 🤗 Transformers library မှ model များကို လေ့ကျင့်ရန်နှင့် အကဲဖြတ်ရန်အတွက် အသုံးပြုသော class။
*   **`train_dataset`**: Trainer ကို ပေးအပ်သော training set။
*   **`eval_dataset`**: Trainer ကို ပေးအပ်သော validation set။
*   **`data_collator`**: batch တစ်ခုအတွင်း samples များကို စုစည်းပေးသော function။
*   **`processing_class`**: Trainer ကို ဒေတာ processing အတွက် မည်သည့် tokenizer ကို အသုံးပြုရမည်ကို ပြောပြပေးသော parameter။
*   **`trainer.train()` Method**: Model ကို fine-tune လုပ်ရန် Trainer class ၏ method။
*   **Training Loss**: Training လုပ်နေစဉ် model ၏ ခန့်မှန်းချက်များနှင့် အမှန်တကယ် labels များကြား ကွာခြားမှုကို တိုင်းတာသော တန်ဖိုး။
*   **`eval_strategy`**: TrainingArguments တွင် evaluation လုပ်ဆောင်မည့် အချိန်နှင့် ကြိမ်နှုန်းကို သတ်မှတ်သော parameter (ဥပမာ- `"epoch"` သို့မဟုတ် `"steps"`)။
*   **`eval_steps`**: evaluation လုပ်ငန်းကို ပြန်လုပ်မည့် training steps အရေအတွက်။
*   **`epoch`**: dataset တစ်ခုလုံးကို model တစ်ခုက အစအဆုံး တစ်ကြိမ် လေ့ကျင့်မှု ပြီးဆုံးခြင်း။
*   **`compute_metrics()` Function**: evaluation လုပ်ငန်းစဉ်အတွင်း metrics (ဥပမာ- accuracy, F1 score) များကို တွက်ချက်ရန်အတွက် Trainer ကို ပေးအပ်သော function။
*   **`Trainer.predict()` Method**: Trainer class ၏ method ဖြစ်ပြီး dataset တစ်ခုပေါ်တွင် model ၏ predictions များကို ရရှိစေသည်။
*   **`EvalPrediction` Object**: `Trainer.predict()` မှ ပြန်ပို့သော named tuple တစ်ခုဖြစ်ပြီး `predictions` field နှင့် `label_ids` field များကို ပါဝင်သည်။
*   **`predictions` Field**: `EvalPrediction` object တွင် မော်ဒယ်၏ ခန့်မှန်းချက်များ ပါဝင်သော field။
*   **`label_ids` Field**: `EvalPrediction` object တွင် အမှန်တကယ် label ID များ ပါဝင်သော field။
*   **`metrics` Field**: `EvalPrediction` object တွင် တွက်ချက်ထားသော evaluation metrics များ ပါဝင်သော field။
*   **Validation Loss**: Validation set ပေါ်တွင် model ၏ ခန့်မှန်းချက်များနှင့် အမှန်တကယ် labels များကြား ကွာခြားမှုကို တိုင်းတာသော တန်ဖိုး။
*   **Logits**: မော်ဒယ်၏ နောက်ဆုံး layer မှ ထုတ်ပေးသော raw, unnormalized scores များ။ ၎င်းတို့ကို SoftMax function ကဲ့သို့သော activation function တစ်ခုဖြင့် probabilistic values များအဖြစ် ပြောင်းလဲနိုင်သည်။
*   **`numpy` (np)**: Python အတွက် ကိန်းဂဏန်းတွက်ချက်မှုများ ပြုလုပ်ရန် အသုံးပြုသော library။
*   **`np.argmax()`**: NumPy function တစ်ခုဖြစ်ပြီး array တစ်ခု၏ သတ်မှတ်ထားသော axis ပေါ်ရှိ အများဆုံးတန်ဖိုး၏ index ကို ပြန်ပေးသည်။
*   **🤗 Evaluate Library**: Hugging Face က ထုတ်လုပ်ထားတဲ့ library တစ်ခုဖြစ်ပြီး machine learning မော်ဒယ်တွေရဲ့ စွမ်းဆောင်ရည်ကို တိုင်းတာဖို့အတွက် metrics မျိုးစုံကို ထောက်ပံ့ပေးသည်။
*   **`evaluate.load()` Function**: 🤗 Evaluate library မှ evaluation metric တစ်ခုကို load လုပ်ရန် အသုံးပြုသော function။
*   **`metric.compute()` Method**: Load လုပ်ထားသော metric object ၏ method ဖြစ်ပြီး predictions နှင့် references (အမှန်တကယ် labels) များကို အသုံးပြု၍ metric value ကို တွက်ချက်သည်။
*   **Accuracy**: မှန်ကန်စွာ ခန့်မှန်းနိုင်သော samples ရာခိုင်နှုန်းကို တိုင်းတာသော metric။
*   **F1 Score**: Precision (တိကျမှု) နှင့် Recall (ပြန်လည်သိမ်းဆည်းမှု) တို့၏ harmonic mean ကို တွက်ချက်သော metric။
    *   **Precision**: model မှ အပြုသဘောဟု ခန့်မှန်းခဲ့သော samples များအနက် တကယ့်တကယ် အပြုသဘောဖြစ်သော samples များ၏ အချိုး။
    *   **Recall**: တကယ့်တကယ် အပြုသဘောဖြစ်သော samples များအနက် model မှ မှန်ကန်စွာ အပြုသဘောဟု ခန့်မှန်းခဲ့သော samples များ၏ အချိုး။
    *   **Harmonic Mean**: ဂဏန်းအစုအဝေးတစ်ခု၏ အပြန်အလှန်တန်ဖိုးများ၏ ပျမ်းမျှကို တွက်ချက်ခြင်း။
*   **Random Initialization**: မော်ဒယ်၏ weights များကို စတင်ချိန်တွင် ကျပန်းတန်ဖိုးများ ပေးခြင်း။
*   **Validation Loss**: Model ကို လေ့ကျင့်နေစဉ် validation set ပေါ်တွင် တွက်ချက်သော loss။
*   **Mixed Precision Training**: မော်ဒယ်ကို လေ့ကျင့်ရာတွင် 16-bit floating-point numbers (fp16) နှင့် 32-bit floating-point numbers (fp32) နှစ်မျိုးလုံးကို ရောစပ်အသုံးပြုခြင်း။ ၎င်းသည် training ကို မြန်ဆန်စေပြီး memory အသုံးပြုမှုကို လျှော့ချသည်။
*   **`fp16=True`**: Mixed precision training ကို ဖွင့်ရန် TrainingArguments တွင် သတ်မှတ်သော parameter။
*   **Gradient Accumulation**: GPU memory ကန့်သတ်ချက်ရှိသောအခါ ပိုကြီးမားသော batch sizes များကို အတုယူရန် batches အများအပြားပေါ်တွင် gradients များကို စုဆောင်းပြီးမှ update လုပ်ခြင်း။
*   **`per_device_train_batch_size`**: device တစ်ခုစီ (ဥပမာ- GPU တစ်ခုစီ) အတွက် training batch size။
*   **`gradient_accumulation_steps`**: Gradient များကို update မလုပ်မီ စုဆောင်းမည့် steps အရေအတွက်။
*   **Learning Rate Scheduling**: Training လုပ်နေစဉ် learning rate ကို အချိန်ကြာလာသည်နှင့်အမျှ ပြောင်းလဲသွားစေရန် နည်းလမ်း။
*   **Linear Decay**: Learning rate ကို အချိန်ကြာလာသည်နှင့်အမျှ လိုင်းဖြောင့်အတိုင်း (linearly) လျှော့ချသွားသော scheduling နည်းလမ်း။
*   **`learning_rate`**: Training လုပ်နေစဉ် model ၏ weights များကို update လုပ်ရာတွင် အသုံးပြုသော step size။
*   **`lr_scheduler_type="cosine"`**: Cosine decay ကဲ့သို့သော learning rate scheduler အမျိုးအစားကို သတ်မှတ်ခြင်း။
*   **Distributed Training**: Model တစ်ခုကို ကွန်ပျူတာများစွာ သို့မဟုတ် devices များစွာပေါ်တွင် တစ်ပြိုင်နက်တည်း လေ့ကျင့်ခြင်း။
*   **Pure PyTorch Training Loop**: Trainer API ကို အသုံးမပြုဘဲ PyTorch library ၏ အခြေခံလုပ်ဆောင်ချက်များဖြင့် model ကို လေ့ကျင့်ရန် code ကို ကိုယ်တိုင်ရေးသားခြင်း။