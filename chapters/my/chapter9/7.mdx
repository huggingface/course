# Gradio Blocks နိဒါန်း[[introduction-to-gradio-blocks]]

<CourseFloatingBanner chapter={9}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter9/section7.ipynb"},
    {label: "Aws Studio", value: "https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter9/section7.ipynb"},
]} />

ယခင်အပိုင်းတွေမှာ `Interface` class ကို အသုံးပြုပြီး demos တွေကို လေ့လာပြီး ဖန်တီးခဲ့ကြပါတယ်။ ဒီအပိုင်းမှာ ကျွန်တော်တို့ **အသစ်တီထွင်ထားတဲ့** `gradio.Blocks` လို့ခေါ်တဲ့ low-level API ကို မိတ်ဆက်ပေးပါမယ်။

`Interface` နဲ့ `Blocks` ဘာကွာလဲ။

-   ⚡ `Interface`: input နဲ့ output list ကို ရိုးရှင်းစွာ ပေးခြင်းဖြင့် အပြည့်အစုံသော machine learning demo တစ်ခုကို ဖန်တီးနိုင်တဲ့ high-level API။

-   🧱 `Blocks`: သင်ရဲ့ application ရဲ့ data flows နဲ့ layout အပေါ် အပြည့်အဝ ထိန်းချုပ်နိုင်တဲ့ low-level API။ `Blocks` (building blocks လိုမျိုး) ကို အသုံးပြုပြီး အလွန်ရှုပ်ထွေးတဲ့၊ multi-step applications တွေကို တည်ဆောက်နိုင်ပါတယ်။

### ဘာကြောင့် Blocks 🧱?[[why-blocks-]]

ယခင်အပိုင်းတွေမှာ ကျွန်တော်တို့ တွေ့ခဲ့ရတဲ့အတိုင်း၊ `Interface` class က code လိုင်းအနည်းငယ်နဲ့ အပြည့်အစုံသော machine learning demos တွေကို အလွယ်တကူ ဖန်တီးနိုင်စေပါတယ်။ `Interface` API က အသုံးပြုရတာ အလွန်လွယ်ကူပေမယ့် `Blocks` API က ပံ့ပိုးပေးတဲ့ flexibility ကိုတော့ အားနည်းပါတယ်။ ဥပမာ၊ သင်က အောက်ပါတို့ကို လုပ်ချင်နိုင်ပါတယ်။

-   web application တစ်ခုတည်းမှာ ဆက်စပ် demos တွေကို multiple tabs အဖြစ် အုပ်စုဖွဲ့ချင်တာမျိုး။
-   သင့် demo ရဲ့ layout ကို ပြောင်းချင်တာမျိုး (ဥပမာ- inputs နဲ့ outputs တွေ ဘယ်နေရာမှာ ရှိမယ်ဆိုတာ သတ်မှတ်တာမျိုး)။
-   multi-step interfaces တွေ ရှိချင်တာမျိုး (model တစ်ခုရဲ့ output က နောက် model တစ်ခုရဲ့ input ဖြစ်လာတာမျိုး ဒါမှမဟုတ် ပိုမိုပြောင်းလွယ်ပြင်လွယ်ရှိတဲ့ data flows တွေ ရှိတာမျိုး)။
-   component တစ်ခုရဲ့ properties တွေကို ပြောင်းလဲချင်တာမျိုး (ဥပမာ- dropdown ထဲက choices တွေ) ဒါမှမဟုတ် user input ပေါ်မူတည်ပြီး ၎င်းရဲ့ visibility ကို ပြောင်းလဲချင်တာမျိုး။

ဒီ concept တွေအားလုံးကို အောက်မှာ ကျွန်တော်တို့ လေ့လာသွားပါမယ်။

### Blocks ကို အသုံးပြုပြီး ရိုးရှင်းတဲ့ Demo တစ်ခု ဖန်တီးခြင်း[[creating-a-simple-demo-using-blocks]]

Gradio ကို install လုပ်ပြီးနောက်၊ အောက်ပါ code ကို Python script၊ Jupyter notebook ဒါမှမဟုတ် Colab notebook အဖြစ် run ပါ။

```py
import gradio as gr


def flip_text(x):
    return x[::-1]


demo = gr.Blocks()

with demo:
    gr.Markdown(
        """
    # စာသားကို ပြောင်းပြန်လှန်ပါ။
    အောက်မှာ စတင်ရိုက်ထည့်ပြီး output ကို ကြည့်ပါ။
    """
    )
    input = gr.Textbox(placeholder="ဒီစာသားကို ပြောင်းပြန်လှန်ပါ")
    output = gr.Textbox()

    input.change(fn=flip_text, inputs=input, outputs=output)

demo.launch()
```

<iframe src="https://course-demos-flip-text.hf.space" frameBorder="0" height="400" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

အထက်ပါ ရိုးရှင်းတဲ့ ဥပမာက Blocks ရဲ့ အခြေခံ concept ၄ ခုကို မိတ်ဆက်ပေးထားပါတယ်။

၁။ Blocks တွေက markdown, HTML, buttons တွေနဲ့ interactive components တွေကို `with gradio.Blocks` context အတွင်းမှာ Python object တွေကို instantiate လုပ်ရုံနဲ့ ပေါင်းစပ်ထားတဲ့ web applications တွေကို တည်ဆောက်နိုင်စေပါတယ်။
> [!TIP]
> 🙋 Python မှာ `with` statement နဲ့ သင်မရင်းနှီးသေးဘူးဆိုရင် Real Python က အလွန်ကောင်းမွန်တဲ့ [tutorial](https://realpython.com/python-with-statement/) ကို ကြည့်ရှုဖို့ ကျွန်တော်တို့ အကြံပြုပါတယ်။ အဲဒါကို ဖတ်ပြီးမှ ဒီကို ပြန်လာပါ။ 🤗
သင် components တွေကို instantiate လုပ်တဲ့ အစီအစဉ်က အရေးကြီးပါတယ်။ ဘာလို့လဲဆိုတော့ element တစ်ခုစီကို web app ထဲမှာ ဖန်တီးခဲ့တဲ့ အစီအစဉ်အတိုင်း render လုပ်တာကြောင့်ပါ။ (ပိုမိုရှုပ်ထွေးတဲ့ layouts တွေအကြောင်းကို အောက်မှာ ဆွေးနွေးထားပါတယ်)။

၂။ သင် ပုံမှန် Python functions တွေကို သင့် code ထဲက ဘယ်နေရာမှာမဆို သတ်မှတ်နိုင်ပြီး `Blocks` ကို အသုံးပြုပြီး user input နဲ့ run နိုင်ပါတယ်။ ကျွန်တော်တို့ရဲ့ ဥပမာမှာ၊ input text ကို "flips" လုပ်တဲ့ ရိုးရှင်းတဲ့ function တစ်ခုရှိပေမယ့်၊ သင်ဟာ ရိုးရှင်းတဲ့ တွက်ချက်မှုကနေ machine learning model က predictions တွေကို process လုပ်တာအထိ ဘယ် Python function ကိုမဆို ရေးနိုင်ပါတယ်။

၃။ သင်ဟာ `Blocks` component တိုင်းကို events တွေ assign လုပ်နိုင်ပါတယ်။ ဒါက component ကို click လုပ်တာ၊ change လုပ်တာ စတဲ့အခါ သင့် function ကို run စေပါလိမ့်မယ်။ event တစ်ခု assign လုပ်တဲ့အခါ၊ parameters သုံးခုကို သင်ပေးရပါတယ်- `fn`: ခေါ်ဆိုသင့်တဲ့ function၊ `inputs`: input component(s) ရဲ့ (list)၊ နဲ့ `outputs`: ခေါ်ဆိုသင့်တဲ့ output components တွေရဲ့ (list)။

   အထက်ပါ ဥပမာမှာ၊ input လို့ နာမည်ပေးထားတဲ့ `Textbox` ထဲက value ပြောင်းတဲ့အခါ `flip_text()` function ကို ကျွန်တော်တို့ run ပါတယ်။ event က `input` ထဲက value ကို ဖတ်ပြီး `flip_text()` ရဲ့ name parameter အဖြစ် ပေးပို့ပါတယ်။ အဲဒီနောက် value ကို ပြန်ပေးပြီး ကျွန်တော်တို့ရဲ့ ဒုတိယ `Textbox` ဖြစ်တဲ့ `output` ကို assign လုပ်ပါတယ်။

   component တစ်ခုစီက ထောက်ပံ့ပေးတဲ့ events တွေရဲ့ list ကို Gradio [documentation](https://www.gradio.app/docs/) မှာ ကြည့်နိုင်ပါတယ်။

၄။ Blocks က component တစ်ခုဟာ interactive ဖြစ်သင့်မဖြစ်သင့် (user input ကို လက်ခံမလား) ကို သင်သတ်မှတ်ထားတဲ့ event triggers တွေအပေါ် အခြေခံပြီး အလိုအလျောက် ဆုံးဖြတ်ပါတယ်။ ကျွန်တော်တို့ရဲ့ ဥပမာမှာ၊ ပထမ textbox က interactive ဖြစ်ပါတယ်၊ ဘာလို့လဲဆိုတော့ ၎င်းရဲ့ value ကို `flip_text()` function က အသုံးပြုလို့ပါ။ ဒုတိယ textbox က interactive မဟုတ်ပါဘူး၊ ဘာလို့လဲဆိုတော့ ၎င်းရဲ့ value ကို input အဖြစ် ဘယ်တော့မှ အသုံးပြုတာ မရှိလို့ပါ။ တချို့အခြေအနေတွေမှာ သင်ဒီလို override လုပ်ချင်နိုင်ပါတယ်၊ အဲဒါကို component ရဲ့ `interactive` parameter ကို boolean တစ်ခု ပေးခြင်းဖြင့် လုပ်ဆောင်နိုင်ပါတယ် (ဥပမာ- `gr.Textbox(placeholder="Flip this text", interactive=True)`)။

### သင့် Demo ရဲ့ Layout ကို စိတ်ကြိုက်ပြင်ဆင်ခြင်း[[customizing-the-layout-of-your-demo]]

ကျွန်တော်တို့ရဲ့ demo ရဲ့ layout ကို စိတ်ကြိုက်ပြင်ဆင်ဖို့ `Blocks` ကို ဘယ်လိုအသုံးပြုရမလဲ။ default အားဖြင့်၊ `Blocks` က သင်ဖန်တီးတဲ့ components တွေကို column တစ်ခုတည်းမှာ ဒေါင်လိုက် render လုပ်ပါတယ်။ `with gradio.Column():` ဒါမှမဟုတ် `with gradio.Row():` လို additional columns ဒါမှမဟုတ် rows တွေကို ဖန်တီးပြီး၊ အဲဒီ contexts တွေထဲမှာ components တွေကို ဖန်တီးခြင်းဖြင့် အဲဒါကို ပြောင်းလဲနိုင်ပါတယ်။

သင်မှတ်သားထားသင့်တဲ့အရာတွေကတော့- `Column` အောက်မှာ ဖန်တီးတဲ့ component တိုင်းကို ဒေါင်လိုက်စီစဉ်ပါလိမ့်မယ် (ဒါက default လည်းဖြစ်ပါတယ်)။ `Row` အောက်မှာ ဖန်တီးတဲ့ component တိုင်းကို အလျားလိုက် စီစဉ်ပါလိမ့်မယ်၊ [web development က flexbox model](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox) နဲ့ ဆင်တူပါတယ်။

နောက်ဆုံးအနေနဲ့၊ `with gradio.Tabs()` context manager ကို အသုံးပြုပြီး သင့် demo အတွက် tabs တွေကိုလည်း ဖန်တီးနိုင်ပါတယ်။ ဒီ context ထဲမှာ၊ `with gradio.TabItem(name_of_tab):` children တွေကို သတ်မှတ်ခြင်းဖြင့် multiple tabs တွေ ဖန်တီးနိုင်ပါတယ်။ `with gradio.TabItem(name_of_tab):` context အတွင်းမှာ ဖန်တီးတဲ့ component တိုင်းက အဲဒီ tab ထဲမှာ ပေါ်လာပါလိမ့်မယ်။

အခု ကျွန်တော်တို့ရဲ့ demo မှာ `flip_image()` function တစ်ခု ထည့်ပြီး images တွေကို flip လုပ်တဲ့ tab အသစ်တစ်ခု ထည့်ကြရအောင်။ အောက်မှာ tabs ၂ ခု ပါဝင်ပြီး Row ကိုလည်း အသုံးပြုထားတဲ့ ဥပမာတစ်ခုပါ။

```py
import numpy as np
import gradio as gr

demo = gr.Blocks()


def flip_text(x):
    return x[::-1]


def flip_image(x):
    return np.fliplr(x)


with demo:
    gr.Markdown("ဒီ demo ကို အသုံးပြုပြီး စာသား ဒါမှမဟုတ် ပုံများကို ပြောင်းပြန်လှန်ပါ။")
    with gr.Tabs():
        with gr.TabItem("စာသား ပြောင်းပြန်လှန်ခြင်း"):
            with gr.Row():
                text_input = gr.Textbox()
                text_output = gr.Textbox()
            text_button = gr.Button("ပြောင်းပြန်လှန်ပါ")
        with gr.TabItem("ပုံ ပြောင်းပြန်လှန်ခြင်း"):
            with gr.Row():
                image_input = gr.Image()
                image_output = gr.Image()
            image_button = gr.Button("ပြောင်းပြန်လှန်ပါ")

    text_button.click(flip_text, inputs=text_input, outputs=text_output)
    image_button.click(flip_image, inputs=image_input, outputs=image_output)

demo.launch()
```

<iframe src="https://course-demos-flip-text-image.hf.space" frameBorder="0" height="450" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

ဒီဥပမာမှာ၊ tab တစ်ခုစီမှာ `Button` component တစ်ခုစီကိုလည်း ဖန်တီးခဲ့တာကို သင်သတိထားမိပါလိမ့်မယ်။ ပြီးတော့ function ကို တကယ် run စေတဲ့ click event တစ်ခုစီကို button တစ်ခုစီကို assign လုပ်ခဲ့ပါတယ်။

### Events များနှင့် State များကို လေ့လာခြင်း[[exploring-events-and-state]]

layout ကို ထိန်းချုပ်နိုင်သလိုပဲ၊ `Blocks` က function calls တွေကို trigger လုပ်တဲ့ events တွေအပေါ်မှာ fine-grained control ကို ပေးပါတယ်။ component တိုင်းနဲ့ layout အများအပြားမှာ ၎င်းတို့ ထောက်ပံ့ပေးတဲ့ သီးခြား events တွေ ရှိပါတယ်။

ဥပမာ၊ `Textbox` component မှာ events ၂ ခု ရှိပါတယ်- `change()` (textbox ထဲက value ပြောင်းတဲ့အခါ) နဲ့ `submit()` (user က textbox ပေါ်မှာ focus လုပ်နေစဉ် enter key ကို နှိပ်တဲ့အခါ)။ ပိုမိုရှုပ်ထွေးတဲ့ components တွေမှာ ပိုပြီးတော့ events တွေ ရှိနိုင်ပါတယ်- ဥပမာ၊ `Audio` component မှာ audio file ကို play လုပ်တဲ့အခါ၊ clear လုပ်တဲ့အခါ၊ pause လုပ်တဲ့အခါ စတဲ့ သီးခြား events တွေလည်း ရှိပါတယ်။ component တစ်ခုစီက ထောက်ပံ့ပေးတဲ့ events တွေအတွက် documentation ကို ကြည့်ပါ။

သင်ဟာ ဒီ events တွေထဲက ဘယ်တစ်ခု၊ တစ်ခု၊ ဒါမှမဟုတ် တစ်ခုထက်ပိုတာတွေကို event trigger attach လုပ်နိုင်ပါတယ်။ event trigger တစ်ခုကို component instance ပေါ်မှာ event ရဲ့ နာမည်ကို function တစ်ခုအဖြစ် ခေါ်ခြင်းဖြင့် ဖန်တီးပါတယ် — ဥပမာ- `textbox.change(...)` ဒါမှမဟုတ် `btn.click(...)`။ function က အပေါ်မှာ ဆွေးနွေးခဲ့တဲ့ parameters သုံးခုကို ယူပါတယ်-

-   `fn`: run ရမယ့် function။
-   `inputs`: function ရဲ့ input parameters အဖြစ် ထောက်ပံ့သင့်တဲ့ component(s) ရဲ့ (list)။ component တစ်ခုစီရဲ့ value က သက်ဆိုင်ရာ function parameter နဲ့ အစီအစဉ်အတိုင်း ကိုက်ညီပါတယ်။ function က parameters တွေ မယူဘူးဆိုရင် ဒီ parameter က `None` ဖြစ်နိုင်ပါတယ်။
-   `outputs`: function က ပြန်ပေးတဲ့ values တွေအပေါ် အခြေခံပြီး update လုပ်သင့်တဲ့ component(s) ရဲ့ (list)။ return value တစ်ခုစီက သက်ဆိုင်ရာ component ရဲ့ value ကို အစီအစဉ်အတိုင်း သတ်မှတ်ပါတယ်။ function က ဘာမှ ပြန်မပေးဘူးဆိုရင် ဒီ parameter က `None` ဖြစ်နိုင်ပါတယ်။

input နဲ့ output component ကို တူညီတဲ့ component ဖြစ်အောင်တောင် လုပ်နိုင်ပါတယ်၊ text completion လုပ်ဖို့ GPT model ကို အသုံးပြုတဲ့ ဒီဥပမာမှာ ကျွန်တော်တို့ လုပ်ခဲ့သလိုပေါ့-

```py
import gradio as gr

api = gr.Interface.load("huggingface/EleutherAI/gpt-j-6B")


def complete_with_gpt(text):
    # စာသားရဲ့ နောက်ဆုံး စာလုံး ၅၀ ကို context အဖြစ် အသုံးပြုပါ
    return text[:-50] + api(text[-50:])


with gr.Blocks() as demo:
    textbox = gr.Textbox(placeholder="ဒီနေရာမှာ ရိုက်ပြီး enter နှိပ်ပါ...", lines=4)
    btn = gr.Button("Generate")

    btn.click(complete_with_gpt, textbox, textbox)

demo.launch()
```

<iframe src="https://course-demos-blocks-gpt.hf.space" frameBorder="0" height="300" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

### Multi-step Demos များကို ဖန်တီးခြင်း[[creating-multi-step-demos]]

တချို့အခြေအနေတွေမှာ၊ သင်က _multi-step demo_ တစ်ခုကို လိုချင်နိုင်ပါတယ်။ အဲဒီမှာ function တစ်ခုရဲ့ output ကို နောက်တစ်ခုရဲ့ input အဖြစ် ပြန်လည်အသုံးပြုတာမျိုးပါ။ ဒါက `Blocks` နဲ့ လုပ်ရတာ အလွန်လွယ်ကူပါတယ်၊ ဘာလို့လဲဆိုတော့ component တစ်ခုကို event trigger တစ်ခုရဲ့ input အဖြစ် ဒါပေမယ့် နောက်တစ်ခုရဲ့ output အဖြစ် အသုံးပြုနိုင်လို့ပါပဲ။ အောက်ပါဥပမာမှာရှိတဲ့ text component ကို ကြည့်ပါ၊ ၎င်းရဲ့ value က speech-to-text model ရဲ့ ရလဒ်ဖြစ်ပေမယ့် sentiment analysis model ထဲကိုလည်း ပေးပို့လိုက်ပါတယ်။

```py
from transformers import pipeline

import gradio as gr

asr = pipeline("automatic-speech-recognition", "facebook/wav2vec2-base-960h")
classifier = pipeline("text-classification")


def speech_to_text(speech):
    text = asr(speech)["text"]
    return text


def text_to_sentiment(text):
    return classifier(text)[0]["label"]


demo = gr.Blocks()

with demo:
    audio_file = gr.Audio(type="filepath")
    text = gr.Textbox()
    label = gr.Label()

    b1 = gr.Button("စကားကို အသိအမှတ်ပြုပါ")
    b2 = gr.Button("စိတ်ခံစားမှုကို ခွဲခြားပါ")

    b1.click(speech_to_text, inputs=audio_file, outputs=text)
    b2.click(text_to_sentiment, inputs=text, outputs=label)

demo.launch()
```

<iframe src="https://course-demos-blocks-multi-step.hf.space" frameBorder="0" height="600" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

### Component Properties များကို Update လုပ်ခြင်း[[updating-component-properties]]

ဒီအထိတော့ ကျွန်တော်တို့ component တစ်ခုရဲ့ value ကို update လုပ်ဖို့ events တွေကို ဘယ်လိုဖန်တီးရမယ်ဆိုတာ တွေ့ခဲ့ရပါတယ်။ ဒါပေမယ့် textbox ရဲ့ visibility ဒါမှမဟုတ် radio button group ထဲက choices တွေလိုမျိုး component တစ်ခုရဲ့ တခြား properties တွေကို ပြောင်းချင်ရင် ဘာလုပ်ရမလဲ။ သင့် function ကနေ ပုံမှန် return value ကို ပြန်ပေးမယ့်အစား component class ရဲ့ `update()` method ကို ပြန်ပေးခြင်းဖြင့် ဒါကို လုပ်ဆောင်နိုင်ပါတယ်။

ဒါကို ဥပမာတစ်ခုနဲ့ အလွယ်တကူ သရုပ်ဖော်ပြနိုင်ပါတယ်။

```py
import gradio as gr


def change_textbox(choice):
    if choice == "short":
        return gr.Textbox.update(lines=2, visible=True)
    elif choice == "long":
        return gr.Textbox.update(lines=8, visible=True)
    else:
        return gr.Textbox.update(visible=False)


with gr.Blocks() as block:
    radio = gr.Radio(["short", "long", "none"], label="ဘယ်လို စာစီစာကုံးမျိုး ရေးချင်ပါသလဲ။")
    text = gr.Textbox(lines=2, interactive=True)

    radio.change(fn=change_textbox, inputs=radio, outputs=text)
    block.launch()
```

<iframe src="https://course-demos-blocks-update-component-properties.hf.space" frameBorder="0" height="300" title="Gradio app" class="container p-0 flex-grow space-iframe" allow="accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"></iframe>

ကျွန်တော်တို့ `Blocks` ရဲ့ core concepts အားလုံးကို လေ့လာခဲ့ပြီးပါပြီ! `Interfaces` တွေနဲ့ တူတူပါပဲ၊ `launch()` method မှာ `share=True` ကို အသုံးပြုပြီး မျှဝေနိုင်တဲ့ ဒါမှမဟုတ် [Hugging Face Spaces](https://huggingface.co/spaces) မှာ deploy လုပ်နိုင်တဲ့ ခေတ်မီ demos တွေကို ဖန်တီးနိုင်ပါတယ်။

## ဝေါဟာရ ရှင်းလင်းချက် (Glossary)

*   **`gradio.Blocks`**: Gradio library ၏ low-level API ဖြစ်ပြီး အသုံးပြုသူအား demo ၏ layout, data flows, နှင့် events များကို ပိုမိုပြည့်စုံစွာ ထိန်းချုပ်နိုင်စေသည်။
*   **Low-level API**: ဆော့ဖ်ဝဲလ်တစ်ခု၏ အခြေခံလုပ်ဆောင်ချက်များကို တိုက်ရိုက်ထိန်းချုပ်နိုင်သော programming interface။
*   **`Interface` Class**: Gradio library ၏ high-level API ဖြစ်ပြီး Machine Learning model များအတွက် web-based demo များကို လွယ်ကူလျင်မြန်စွာ ဖန်တီးရန် အသုံးပြုသည်။
*   **High-level API**: အသေးစိတ်အချက်အလက်များကို ဝှက်ထားပြီး အသုံးပြုရလွယ်ကူသော programming interface။
*   **Data Flows**: application တစ်ခုအတွင်း ဒေတာများ မည်သို့ စီးဆင်းပြီး ပြောင်းလဲပုံ။
*   **Layout**: application ၏ UI elements များ စီစဉ်ထားပုံ။
*   **Multi-step Applications**: လုပ်ငန်းစဉ်အဆင့်များစွာ ပါဝင်သော application များ။
*   **Tabs**: web application တစ်ခုတွင် မတူညီသော content များကို ပြောင်းလဲပြသနိုင်သော UI element များ။
*   **Visibility**: component တစ်ခုကို ပြသမည်လား သို့မဟုတ် ဝှက်ထားမည်လား။
*   **User Input**: အသုံးပြုသူမှ ထည့်သွင်းသော အချက်အလက်များ။
*   **Python Script**: Python programming language ဖြင့် ရေးသားထားသော executable code file။
*   **Jupyter Notebook**: code, text, images, နှင့် mathematical equations တို့ကို ပေါင်းစပ်နိုင်သော interactive computing environment။
*   **Colab Notebook (Google Colab)**: Google မှ ပံ့ပိုးပေးထားသော cloud-based Jupyter Notebook environment တစ်ခု။
*   **`gr.Blocks()`**: `Blocks` object တစ်ခုကို ဖန်တီးခြင်း။
*   **`with demo:` (Context Manager)**: Python ၏ `with` statement ကို အသုံးပြု၍ `Blocks` object အတွင်း UI components များကို ဖန်တီးရန် context ကို သတ်မှတ်သည်။
*   **`gr.Markdown()`**: Markdown format ဖြင့် စာသားကို ပြသရန် Gradio component။
*   **`gr.Textbox()`**: Gradio ၏ input သို့မဟုတ် output component တစ်မျိုးဖြစ်ပြီး စာသားများ ရိုက်ထည့်ရန် သို့မဟုတ် ပြသရန် အသုံးပြုသည်။
*   **`placeholder` Parameter**: input field တွင် အသုံးပြုသူ ရိုက်ထည့်ခြင်းမပြုမီ ပြသထားသော ဥပမာစာသား။
*   **`input.change()`**: `input` Textbox ၏ value ပြောင်းလဲသည့်အခါ အစပျိုးသော event trigger။
*   **`fn` Parameter**: event trigger မှ ခေါ်ဆိုမည့် function။
*   **`inputs` Parameter**: function သို့ input အဖြစ် ပေးမည့် Gradio components များ၏ list။
*   **`outputs` Parameter**: function ၏ return value ဖြင့် update လုပ်မည့် Gradio components များ၏ list။
*   **`demo.launch()`**: Gradio demo ကို web server တစ်ခုအဖြစ် စတင်လုပ်ဆောင်သည်။
*   **`x[::-1]`**: Python slice syntax ဖြစ်ပြီး string သို့မဟုတ် list တစ်ခုကို ပြောင်းပြန်လှန်ရန်။
*   **Real Python**: Python tutorial များနှင့် resources များ ပံ့ပိုးပေးသော website။
*   **Render**: code မှ UI elements များကို ဖန်တီးပြီး ပြသခြင်း။
*   **Interactive**: အသုံးပြုသူ၏ လုပ်ဆောင်မှုများ (ဥပမာ- click, type) ကို တုံ့ပြန်နိုင်ခြင်း။
*   **`interactive` Parameter**: component တစ်ခု interactive ဖြစ်သင့် မဖြစ်သင့်ကို boolean value ဖြင့် သတ်မှတ်သည်။
*   **`gradio.Column()`**: Components များကို ဒေါင်လိုက်စီစဉ်ရန် context manager။
*   **`gradio.Row()`**: Components များကို အလျားလိုက်စီစဉ်ရန် context manager။
*   **Flexbox Model**: CSS ၏ layout model တစ်ခုဖြစ်ပြီး UI elements များကို နေရာချထားရန်။
*   **`gradio.Tabs()`**: Tabs များပါဝင်သော UI element ကို ဖန်တီးရန် context manager။
*   **`gradio.TabItem(name_of_tab)`**: Tabs container အတွင်းရှိ သီးခြား tab တစ်ခုကို ဖန်တီးရန် context manager။
*   **`flip_image()` Function**: ပုံရိပ်တစ်ခုကို အလျားလိုက် ပြောင်းပြန်လှန်ပေးသော function။
*   **`np.fliplr()`**: NumPy function တစ်ခုဖြစ်ပြီး array တစ်ခုကို အလျားလိုက် ပြောင်းပြန်လှန်ပေးသည်။
*   **`gr.Image()`**: Gradio ၏ input သို့မဟုတ် output component တစ်မျိုးဖြစ်ပြီး ပုံရိပ်များကို ကိုင်တွယ်ရန်။
*   **`gr.Button()`**: Gradio ၏ button component။
*   **`button.click()`**: `button` ကို click လုပ်သည့်အခါ အစပျိုးသော event trigger။
*   **State**: application ၏ အခြေအနေ သို့မဟုတ် ဒေတာများ။
*   **`Textbox.change()`**: Textbox ၏ value ပြောင်းလဲသည့်အခါ အစပျိုးသော event။
*   **`Textbox.submit()`**: Textbox ပေါ်တွင် focus လုပ်ထားစဉ် Enter key နှိပ်သည့်အခါ အစပျိုးသော event။
*   **`Audio` Component Events**: Audio file ကို play, clear, pause စသည်တို့ လုပ်သည့်အခါ အစပျိုးသော events များ။
*   **Component Instance**: class မှ ဖန်တီးထားသော သီးခြား object။
*   **GPT Model (Generative Pre-trained Transformer)**: Google မှ ထုတ်လုပ်ထားသော Large Language Model တစ်မျိုး။
*   **Text Completion**: ပေးထားသော စာသားကို ဆက်လက်ဖြည့်စွက်ပေးခြင်း။
*   **Context**: စာသားတစ်ခု၏ ပတ်ဝန်းကျင်အကြောင်းအရာ။
*   **Multi-step Demo**: အဆင့်များစွာပါဝင်သော demo ဖြစ်ပြီး function တစ်ခု၏ output က နောက် function ၏ input ဖြစ်လာနိုင်သည်။
*   **Speech-to-text Model**: အသံကို စာသားအဖြစ် ပြောင်းလဲပေးသော model။
*   **Sentiment Analysis Model**: စာသား၏ စိတ်ခံစားမှု (အပြုသဘော၊ အနုတ်သဘော) ကို ခွဲခြားသတ်မှတ်ပေးသော model။
*   **`asr` Pipeline (Automatic Speech Recognition)**: Speech-to-text အတွက် Hugging Face pipeline။
*   **`classifier` Pipeline (Text Classification)**: Sentiment analysis အတွက် Hugging Face pipeline။
*   **`gr.Audio()`**: Gradio ၏ input/output component တစ်မျိုးဖြစ်ပြီး အသံဖိုင်များ သို့မဟုတ် microphone input များနှင့် အလုပ်လုပ်ရန်။
*   **`gr.Label()`**: Gradio ၏ output component တစ်မျိုးဖြစ်ပြီး categorical label များကို ပြသရန်။
*   **`gr.Textbox.update()`**: Textbox component ၏ properties များကို dynamicly update လုပ်ရန် method။
*   **`lines` (for `Textbox.update()`)**: update လုပ်မည့် Textbox ၏ `lines` property။
*   **`visible` (for `Textbox.update()`)**: update လုပ်မည့် Textbox ၏ `visible` property။
*   **`gr.Radio()`**: Gradio ၏ input component တစ်မျိုးဖြစ်ပြီး အသုံးပြုသူအား ရွေးချယ်စရာများထဲမှ တစ်ခုကို ရွေးချယ်စေသည်။
*   **Deploy**: application တစ်ခုကို server ပေါ်တွင် run နိုင်အောင် ပြင်ဆင်ပြီး အသုံးပြုနိုင်အောင် လုပ်ဆောင်ခြင်း။