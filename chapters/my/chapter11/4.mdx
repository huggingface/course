<CourseFloatingBanner chapter={2}
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/github/huggingface/notebooks/blob/main/course/en/chapter11/section4.ipynb"},
]} />

# LoRA (Low-Rank Adaptation)

Large language models တွေကို fine-tuning လုပ်တာဟာ အရင်းအမြစ် (resource) အများကြီး လိုအပ်တဲ့ လုပ်ငန်းစဉ်တစ်ခု ဖြစ်ပါတယ်။ LoRA ဟာ large language models တွေကို parameters နည်းနည်းလေးနဲ့ fine-tune လုပ်နိုင်စေတဲ့ နည်းပညာတစ်ခု ဖြစ်ပါတယ်။ ၎င်းက attention weights တွေမှာ ပိုသေးငယ်တဲ့ matrices တွေကို ထည့်သွင်းပြီး optimization လုပ်ခြင်းဖြင့် အလုပ်လုပ်ပါတယ်၊ ဒါက သင်ယူရမယ့် parameters တွေကို ၉၀% လောက် လျှော့ချပေးနိုင်ပါတယ်။

## LoRA ကို နားလည်ခြင်း

LoRA (Low-Rank Adaptation) ဟာ parameter-efficient fine-tuning နည်းပညာတစ်ခု ဖြစ်ပါတယ်။ ဒါက pre-trained model weights တွေကို freeze လုပ်ပြီး၊ trainable rank decomposition matrices တွေကို model ရဲ့ layers တွေထဲကို ထည့်သွင်းပါတယ်။ fine-tuning လုပ်စဉ်မှာ model parameters အားလုံးကို train လုပ်မယ့်အစား၊ LoRA က weight updates တွေကို low-rank decomposition မှတစ်ဆင့် ပိုသေးငယ်တဲ့ matrices တွေအဖြစ် ခွဲထုတ်လိုက်ပါတယ်။ ဒါက model ရဲ့ စွမ်းဆောင်ရည်ကို ထိန်းသိမ်းထားရင်း trainable parameters အရေအတွက်ကို သိသိသာသာ လျှော့ချပေးပါတယ်။ ဥပမာ၊ GPT-3 175B မှာ အသုံးပြုတဲ့အခါ၊ LoRA ဟာ trainable parameters ကို 10,000 ဆ လျှော့ချပေးခဲ့ပြီး GPU memory လိုအပ်ချက်ကို full fine-tuning နဲ့ နှိုင်းယှဉ်ပါက ၃ ဆ လျှော့ချပေးခဲ့ပါတယ်။ LoRA အကြောင်းကို [LoRA paper](https://arxiv.org/pdf/2106.09685) မှာ ပိုမိုဖတ်ရှုနိုင်ပါတယ်။

LoRA က transformer layers တွေမှာ rank decomposition matrices အတွဲတွေကို ထည့်သွင်းခြင်းဖြင့် အလုပ်လုပ်ပါတယ်။ အများအားဖြင့် attention weights တွေကို အာရုံစိုက်ပါတယ်။ Inference လုပ်တဲ့အခါ၊ ဒီ adapter weights တွေကို base model နဲ့ ပေါင်းစပ်နိုင်တာကြောင့် latency overhead လုံးဝ မရှိပါဘူး။ LoRA ဟာ large language models တွေကို သီးခြား tasks တွေ ဒါမှမဟုတ် domains တွေနဲ့ လိုက်လျောညီထွေဖြစ်အောင် ပြုလုပ်ရာမှာ အရင်းအမြစ်လိုအပ်ချက်တွေကို စီမံခန့်ခွဲနိုင်အောင် ကူညီပေးတာကြောင့် အထူးအသုံးဝင်ပါတယ်။

## LoRA ရဲ့ အဓိက အကျိုးကျေးဇူးများ

၁။ **Memory ထိရောက်မှု (Memory Efficiency)**:
   - GPU memory ထဲမှာ adapter parameters တွေကိုသာ သိမ်းဆည်းပါတယ်။
   - Base model weights တွေဟာ freeze လုပ်ထားပြီး lower precision နဲ့ load လုပ်နိုင်ပါတယ်။
   - Consumer GPUs တွေမှာတောင် large models တွေကို fine-tune လုပ်နိုင်စေပါတယ်။

၂။ **Training Features များ**:
   - PEFT/LoRA ကို minimal setup နဲ့ တိုက်ရိုက်ပေါင်းစပ်ထားပါတယ်။
   - Memory ထိရောက်မှု ပိုကောင်းအောင် QLoRA (Quantized LoRA) ကို ထောက်ပံ့ပေးပါတယ်။

၃။ **Adapter စီမံခန့်ခွဲမှု (Adapter Management)**:
   - Checkpoints လုပ်စဉ် adapter weight တွေကို သိမ်းဆည်းပါတယ်။
   - Adapters တွေကို base model ထဲသို့ ပြန်လည်ပေါင်းစပ်နိုင်တဲ့ features တွေ ပါဝင်ပါတယ်။

## PEFT ဖြင့် LoRA Adapters များကို Loading လုပ်ခြင်း

[PEFT](https://github.com/huggingface/peft) ဟာ LoRA အပါအဝင် PEFT နည်းလမ်းတွေကို loading လုပ်ပြီး စီမံခန့်ခွဲဖို့အတွက် ပေါင်းစည်းထားတဲ့ interface တစ်ခုကို ပံ့ပိုးပေးတဲ့ library တစ်ခု ဖြစ်ပါတယ်။ ၎င်းက မတူညီတဲ့ PEFT နည်းလမ်းတွေကြား အလွယ်တကူ load လုပ်ပြီး ပြောင်းလဲနိုင်စေတာကြောင့် မတူညီတဲ့ fine-tuning နည်းပညာတွေကို စမ်းသပ်ဖို့ ပိုမိုလွယ်ကူစေပါတယ်။

Adapters တွေကို pretrained model တစ်ခုပေါ်မှာ `load_adapter()` နဲ့ load လုပ်နိုင်ပါတယ်။ ဒါက weights တွေ ပေါင်းစပ်မထားတဲ့ မတူညီတဲ့ adapters တွေကို စမ်းသပ်ဖို့ အသုံးဝင်ပါတယ်။ `set_adapter()` function နဲ့ active adapter weights တွေကို သတ်မှတ်ပါ။ base model ကို ပြန်လိုချင်ရင် LoRA modules အားလုံးကို unload လုပ်ဖို့ `unload()` ကို အသုံးပြုနိုင်ပါတယ်။ ဒါက မတူညီတဲ့ task-specific weights တွေကြား ပြောင်းလဲဖို့ လွယ်ကူစေပါတယ်။

```python
from peft import PeftModel, PeftConfig

config = PeftConfig.from_pretrained("ybelkada/opt-350m-lora")
model = AutoModelForCausalLM.from_pretrained(config.base_model_name_or_path)
lora_model = PeftModel.from_pretrained(model, "ybelkada/opt-350m-lora")
```

![lora_load_adapter](https://github.com/huggingface/smol-course/raw/main/3_parameter_efficient_finetuning/images/lora_adapter.png)

## `trl` နှင့် `SFTTrainer` ကို LoRA ဖြင့် အသုံးပြု၍ LLM ကို Fine-tune လုပ်ခြင်း

`trl` မှ [SFTTrainer](https://huggingface.co/docs/trl/sft_trainer) ဟာ [PEFT](https://huggingface.co/docs/peft/en/index) library မှတစ်ဆင့် LoRA adapters တွေနဲ့ ပေါင်းစပ်ထားပါတယ်။ ဒါက SFT နဲ့ လုပ်ခဲ့သလိုပဲ model ကို fine-tune လုပ်နိုင်တယ်လို့ ဆိုလိုတာပါ။ ဒါပေမယ့် train လုပ်ဖို့ လိုအပ်တဲ့ parameters အရေအတွက်ကို လျှော့ချဖို့ LoRA ကို အသုံးပြုတာပါ။

ကျွန်တော်တို့ရဲ့ ဥပမာမှာ PEFT က `LoRAConfig` class ကို အသုံးပြုပါမယ်။ တည်ဆောက်မှုမှာ configuration steps အနည်းငယ်သာ လိုအပ်ပါတယ်။

၁။ LoRA configuration (rank, alpha, dropout) ကို သတ်မှတ်ပါ။
၂။ PEFT config နဲ့ SFTTrainer ကို ဖန်တီးပါ။
၃။ Adapter weights တွေကို train လုပ်ပြီး သိမ်းဆည်းပါ။

## LoRA Configuration

LoRA configuration နဲ့ အဓိက parameters တွေကို တစ်ဆင့်ချင်းစီ လေ့လာကြည့်ရအောင်။

| Parameter      | ဖော်ပြချက်                                                                                                        |
|----------------|--------------------------------------------------------------------------------------------------------------------|
| `r` (rank)         | Weight updates အတွက် အသုံးပြုသော low-rank matrices ၏ dimension။ အများအားဖြင့် ၄-၃၂ ကြား။ တန်ဖိုးနည်းလေ compression ပိုကောင်းလေ၊ သို့သော် expressiveness နည်းပါးနိုင်ခြေရှိလေ။ |
| `lora_alpha`   | LoRA layers များအတွက် scaling factor။ ပုံမှန်အားဖြင့် rank တန်ဖိုး၏ ၂ ဆ။ တန်ဖိုးများလေ adaptation effects ပိုအားကောင်းလေ။        |
| `lora_dropout` | LoRA layers များအတွက် dropout probability။ ပုံမှန်အားဖြင့် ၀.၀၅-၀.၁။ တန်ဖိုးများလေ training လုပ်စဉ် overfitting ကို ကာကွယ်ရန် ပိုမိုအထောက်အကူပြုလေ။ |
| `bias`         | bias terms များကို training လုပ်ခြင်းကို ထိန်းချုပ်သည်။ "none", "all", သို့မဟုတ် "lora_only" တို့ ဖြစ်နိုင်သည်။ memory efficiency အတွက် "none" က အသုံးအများဆုံး။ |
| `target_modules` | LoRA ကို မည်သည့် model modules များတွင် အသုံးပြုမည်ကို သတ်မှတ်သည်။ "all-linear" သို့မဟုတ် "q_proj,v_proj" ကဲ့သို့ သီးခြား modules များ ဖြစ်နိုင်သည်။ modules များလေ adaptability ပိုများလေ၊ သို့သော် memory အသုံးပြုမှု ပိုများလေ။ |

> [!TIP]
> PEFT နည်းလမ်းတွေကို အကောင်အထည်ဖော်တဲ့အခါ၊ LoRA အတွက် small rank values (၄-၈) ကနေ စတင်ပြီး training loss ကို စောင့်ကြည့်ပါ။ overfitting ကို ကာကွယ်ဖို့ validation sets တွေကို အသုံးပြုပြီး၊ ဖြစ်နိုင်ရင် full fine-tuning baselines တွေနဲ့ ရလဒ်တွေကို နှိုင်းယှဉ်ပါ။ နည်းလမ်းအမျိုးမျိုးရဲ့ ထိရောက်မှုက task အလိုက် ကွာခြားနိုင်တာကြောင့် စမ်းသပ်လေ့လာခြင်းက အဓိကပါပဲ။

## PEFT ဖြင့် TRL ကို အသုံးပြုခြင်း

Memory လိုအပ်ချက်များကို လျှော့ချရန်အတွက် PEFT နည်းလမ်းများကို TRL နှင့် ပေါင်းစပ်ပြီး fine-tuning လုပ်နိုင်ပါတယ်။ Model ကို load လုပ်တဲ့အခါ `LoraConfig` ကို ပေးနိုင်ပါတယ်။

```python
from peft import LoraConfig

# TODO: LoRA parameters များကို Configure လုပ်ပါ။
# r: LoRA update matrices အတွက် rank dimension (သေးငယ်လေ compression ပိုကောင်းလေ)
rank_dimension = 6
# lora_alpha: LoRA layers များအတွက် scaling factor (များလေ adaptation ပိုအားကောင်းလေ)
lora_alpha = 8
# lora_dropout: LoRA layers များအတွက် dropout probability (overfitting ကို ကာကွယ်ရန် ကူညီ)
lora_dropout = 0.05

peft_config = LoraConfig(
    r=rank_dimension,  # Rank dimension - ပုံမှန်အားဖြင့် 4-32 ကြား
    lora_alpha=lora_alpha,  # LoRA scaling factor - ပုံမှန်အားဖြင့် rank ၏ 2 ဆ
    lora_dropout=lora_dropout,  # LoRA layers များအတွက် dropout probability
    bias="none",  # LoRA အတွက် bias အမျိုးအစား။ သက်ဆိုင်ရာ biases များကို training လုပ်စဉ် update လုပ်ပါမည်။
    target_modules="all-linear",  # LoRA ကို မည်သည့် modules များတွင် အသုံးပြုရန်
    task_type="CAUSAL_LM",  # Model architecture အတွက် task အမျိုးအစား
)
```

အထက်မှာ၊ model ကို မှန်ကန်တဲ့ device ကို အလိုအလျောက် assign လုပ်ဖို့ `device_map="auto"` ကို အသုံးပြုခဲ့ပါတယ်။ `device_map={"": device_index}` ကို အသုံးပြုပြီး model ကို သီးခြား device တစ်ခုကို ကိုယ်တိုင် assign လုပ်နိုင်ပါတယ်။

LoRA configuration နဲ့ `SFTTrainer` ကိုလည်း သတ်မှတ်ဖို့ လိုအပ်ပါလိမ့်မယ်။

```python
# LoRA configuration ဖြင့် SFTTrainer ကို ဖန်တီးပါ။
trainer = SFTTrainer(
    model=model,
    args=args,
    train_dataset=dataset["train"],
    peft_config=peft_config,  # LoRA configuration
    max_seq_length=max_seq_length,  # Maximum sequence length
    processing_class=tokenizer,
)
```

> [!TIP]
> ✏️ **စမ်းသပ်ကြည့်ပါ။** ယခင်အပိုင်းက သင် fine-tune လုပ်ထားတဲ့ model ကို အခြေခံပြီး LoRA နဲ့ ထပ်ပြီး fine-tune လုပ်ကြည့်ပါ။ အထက်မှာ သတ်မှတ်ခဲ့တဲ့ LoRA configuration ကို အသုံးပြုပြီး `deepseek-ai/DeepSeek-R1-Distill-Qwen-1.5B` model ကို fine-tune လုပ်ဖို့ `HuggingFaceTB/smoltalk` dataset ကို အသုံးပြုပါ။

## LoRA Adapters များကို ပေါင်းစပ်ခြင်း

LoRA ဖြင့် train လုပ်ပြီးနောက်၊ ပိုမိုလွယ်ကူစွာ deploy လုပ်နိုင်ရန် adapter weights များကို base model ထဲသို့ ပြန်လည်ပေါင်းစပ်ချင်ပါလိမ့်မယ်။ ဒါက ပေါင်းစပ်ထားတဲ့ weights တွေပါဝင်တဲ့ single model တစ်ခုကို ဖန်တီးပေးပြီး inference လုပ်စဉ် adapters တွေကို သီးခြား load လုပ်ဖို့ မလိုအပ်တော့ပါဘူး။

ပေါင်းစပ်ခြင်းလုပ်ငန်းစဉ်မှာ memory စီမံခန့်ခွဲမှုနဲ့ precision ကို ဂရုစိုက်ဖို့ လိုအပ်ပါတယ်။ base model နဲ့ adapter weights နှစ်ခုလုံးကို တစ်ပြိုင်နက်တည်း load လုပ်ရမှာဖြစ်လို့၊ လုံလောက်တဲ့ GPU/CPU memory ရှိဖို့ သေချာပါစေ။ `transformers` ထဲက `device_map="auto"` ကို အသုံးပြုရင် သင့် hardware ပေါ်မူတည်ပြီး model အတွက် မှန်ကန်တဲ့ device ကို ရှာဖွေပေးပါလိမ့်မယ်။

လုပ်ငန်းစဉ်တစ်လျှောက်လုံး consistent precision (ဥပမာ- float16) ကို ထိန်းသိမ်းပြီး၊ training လုပ်စဉ် အသုံးပြုခဲ့တဲ့ precision နဲ့ ကိုက်ညီအောင် လုပ်ဆောင်ကာ၊ ပေါင်းစပ်ထားတဲ့ model ကို deployment အတွက် တူညီတဲ့ format နဲ့ သိမ်းဆည်းပါ။

## ပေါင်းစပ်မှု အကောင်အထည်ဖော်ခြင်း (Merging Implementation)

LoRA adapter တစ်ခုကို train လုပ်ပြီးနောက်၊ adapter weights တွေကို base model ထဲသို့ ပြန်လည်ပေါင်းစပ်နိုင်ပါတယ်။ ဒါကို ဘယ်လိုလုပ်ရမလဲဆိုတာ အောက်ပါအတိုင်းပါ။

```python
import torch
from transformers import AutoModelForCausalLM
from peft import PeftModel

# 1. Base model ကို load လုပ်ပါ
base_model = AutoModelForCausalLM.from_pretrained(
    "base_model_name", torch_dtype=torch.float16, device_map="auto"
)

# 2. Adapter ပါဝင်သော PEFT model ကို load လုပ်ပါ
peft_model = PeftModel.from_pretrained(
    base_model, "path/to/adapter", torch_dtype=torch.float16
)

# 3. Adapter weights များကို base model နှင့် ပေါင်းစပ်ပါ။
merged_model = peft_model.merge_and_unload()
```

saved model မှာ size ကွာခြားမှုတွေ တွေ့ရရင်၊ tokenizer ကိုပါ save လုပ်ထားခြင်းရှိမရှိ သေချာအောင် လုပ်ပါ။

```python
# Model နဲ့ tokenizer နှစ်ခုလုံးကို save လုပ်ပါ
tokenizer = AutoTokenizer.from_pretrained("base_model_name")
merged_model.save_pretrained("path/to/save/merged_model")
tokenizer.save_pretrained("path/to/save/merged_model")
```

> [!TIP]
> ✏️ **စမ်းသပ်ကြည့်ပါ။** adapter weights တွေကို base model ထဲသို့ ပြန်လည်ပေါင်းစပ်ကြည့်ပါ။ အထက်မှာ သတ်မှတ်ခဲ့တဲ့ LoRA configuration ကို အသုံးပြုပြီး `deepseek-ai/DeepSeek-R1-Distill-Qwen-1.5B` model ကို fine-tune လုပ်ဖို့ `HuggingFaceTB/smoltalk` dataset ကို အသုံးပြုပါ။

# အရင်းအမြစ်များ (Resources)

- [LoRA: Low-Rank Adaptation of Large Language Models](https://arxiv.org/pdf/2106.09685)
- [PEFT Documentation](https://huggingface.co/docs/peft)
- [Hugging Face blog post on PEFT](https://huggingface.co/blog/peft)

## ဝေါဟာရ ရှင်းလင်းချက် (Glossary)

*   **LoRA (Low-Rank Adaptation)**: Transformer မော်ဒယ်များကဲ့သို့သော large models များကို fine-tuning လုပ်ရာတွင် ထိရောက်မှုရှိစေရန်အတွက် model ၏ layers တွေမှာ low-rank matrices တွေကို ထပ်ထည့်သည့် နည်းပညာ။ ၎င်းသည် memory အသုံးပြုမှုကို သိသိသာသာ လျှော့ချနိုင်သည်။
*   **Fine-tuning**: ကြိုတင်လေ့ကျင့်ထားပြီးသား (pre-trained) မော်ဒယ်တစ်ခုကို သီးခြားလုပ်ငန်းတစ်ခု (specific task) အတွက် အနည်းငယ်သော ဒေတာနဲ့ ထပ်မံလေ့ကျင့်ပေးခြင်းကို ဆိုလိုပါတယ်။
*   **Large Language Models (LLMs)**: လူသားဘာသာစကားကို နားလည်ပြီး ထုတ်လုပ်ပေးနိုင်တဲ့ အလွန်ကြီးမားတဲ့ Artificial Intelligence (AI) မော်ဒယ်တွေ ဖြစ်ပါတယ်။
*   **Resource Intensive**: ကွန်ပျူတာ၏ စွမ်းအား (CPU/GPU) နှင့် မှတ်ဉာဏ် (RAM/VRAM) များစွာ လိုအပ်သော လုပ်ငန်းစဉ်။
*   **Parameters**: မော်ဒယ်၏ သင်ယူနိုင်သော အစိတ်အပိုင်းများ (weights နှင့် biases)။
*   **Attention Weights**: Transformer model တွင် input sequence တစ်ခုအတွင်းရှိ token များကြား ဆက်နွယ်မှု၏ အရေးပါပုံကို ဖော်ပြသော weights များ။
*   **Optimization**: အကောင်းဆုံးရလဒ်ရရှိရန် parameters များကို ချိန်ညှိခြင်းလုပ်ငန်းစဉ်။
*   **Trainable Parameters**: လေ့ကျင့်မှုလုပ်ငန်းစဉ်အတွင်း ပြောင်းလဲနိုင်သော မော်ဒယ်၏ parameters အရေအတွက်။
*   **Parameter-Efficient Fine-Tuning (PEFT)**: Large models များကို fine-tuning လုပ်ရာတွင် trainable parameters အရေအတွက်ကို သိသိသာသာ လျှော့ချသည့် နည်းလမ်းများ။
*   **Pre-trained Model Weights**: မော်ဒယ်ကို မူလ pre-training လုပ်ငန်းစဉ်မှ သင်ယူထားသော weights များ။
*   **Freeze**: Model ၏ အချို့သော layers များ၏ weights များကို training လုပ်စဉ် မပြောင်းလဲစေရန် ပိတ်ဆို့ထားခြင်း။
*   **Rank Decomposition Matrices**: သင်္ချာပိုင်းဆိုင်ရာ matrix တစ်မျိုးဖြစ်ပြီး matrix တစ်ခုကို low-rank matrices အဖြစ် ခွဲထုတ်ခြင်းနည်းလမ်း။
*   **Model's Layers**: Neural network model တစ်ခု၏ အဆင့်များ။
*   **Weight Updates**: Training လုပ်ငန်းစဉ်အတွင်း model weights များ ပြောင်းလဲခြင်း။
*   **GPT-3 175B**: OpenAI မှ ထုတ်လုပ်ထားသော parameters ဘီလီယံ ၁၇၅ ခုပါဝင်သည့် အလွန်ကြီးမားသော Large Language Model (LLM)။
*   **GPU Memory Requirements**: GPU တွင် model တစ်ခုကို run ရန် လိုအပ်သော မှတ်ဉာဏ်ပမာဏ။
*   **Full Fine-tuning**: model ၏ parameters အားလုံးကို training လုပ်ခြင်း။
*   **Transformer Layers**: Transformer architecture တွင် ပါဝင်သော အဓိက layers များ။
*   **Adapter Weights**: LoRA မှ ထည့်သွင်းထားသော low-rank matrices ၏ weights များ။
*   **Inference**: လေ့ကျင့်ပြီးသား Artificial Intelligence (AI) မော်ဒယ်တစ်ခုကို အသုံးပြုပြီး input data ကနေ ခန့်မှန်းချက်တွေ ဒါမှမဟုတ် output တွေကို ထုတ်လုပ်တဲ့ လုပ်ငန်းစဉ်။
*   **Base Model**: Fine-tuning မလုပ်ရသေးသော သို့မဟုတ် adapter weights များ မပေါင်းစပ်ရသေးသော မူရင်း pre-trained model။
*   **Latency Overhead**: လုပ်ငန်းစဉ်တစ်ခု လုပ်ဆောင်ရန်အတွက် အချိန်ပိုကုန်ကျခြင်း။
*   **Domains**: သီးခြားနယ်ပယ်များ (ဥပမာ- medical domain, legal domain)။
*   **Memory Efficiency**: ကွန်ပျူတာ၏ RAM အသုံးပြုမှုကို လျှော့ချနိုင်ခြင်း။
*   **Lower Precision**: floating-point numbers များကို bits နည်းပါးစွာ အသုံးပြု၍ ကိုယ်စားပြုခြင်း (ဥပမာ- float16)။ ၎င်းသည် memory ကို ချွေတာသည်။
*   **Consumer GPUs**: သုံးစွဲသူများအတွက် ထုတ်လုပ်ထားသော GPU များ (ဥပမာ- NVIDIA GeForce, AMD Radeon)။
*   **PEFT Integration**: PEFT library ဖြင့် အခြား frameworks များ သို့မဟုတ် libraries များကို ပေါင်းစပ်ခြင်း။
*   **QLoRA (Quantized LoRA)**: LoRA ကို quantization နည်းပညာဖြင့် ပေါင်းစပ်ထားခြင်း။ ၎င်းသည် model weights များကို ပိုမိုနိမ့်သော precision ဖြင့် သိမ်းဆည်းခြင်းဖြင့် memory efficiency ကို ပိုမိုတိုးတက်စေသည်။
*   **Adapter Parameters**: LoRA adapters တွင် ပါဝင်သော parameters များ။
*   **Checkpoints**: မော်ဒယ်၏ weights များနှင့် အခြားဖွဲ့စည်းပုံများ (configuration) ကို သတ်မှတ်ထားသော အချိန်တစ်ခုတွင် သိမ်းဆည်းထားခြင်း။
*   **`load_adapter()`**: PEFT library မှ method တစ်ခုဖြစ်ပြီး adapter weights များကို model ထဲသို့ load လုပ်ရန်။
*   **`set_adapter()`**: PEFT library မှ method တစ်ခုဖြစ်ပြီး active adapter weights များကို သတ်မှတ်ရန်။
*   **`unload()`**: PEFT library မှ method တစ်ခုဖြစ်ပြီး LoRA modules အားလုံးကို model မှ ဖယ်ရှားရန်။
*   **`PeftModel`**: PEFT library မှ class တစ်ခုဖြစ်ပြီး model တွင် adapter layers များကို ထည့်သွင်းထားသော model ကို ကိုယ်စားပြုသည်။
*   **`PeftConfig`**: PEFT library မှ class တစ်ခုဖြစ်ပြီး PEFT နည်းလမ်းများ၏ configuration များကို သတ်မှတ်ရန်။
*   **`AutoModelForCausalLM`**: Hugging Face Transformers library မှ causal language models များကို အလိုအလျောက် load လုပ်ရန် class။
*   **`LoraConfig`**: PEFT library မှ LoRA နည်းလမ်းအတွက် configuration class။
*   **`r` (rank dimension)**: LoRA update matrices များအတွက် rank ၏ dimension။
*   **`lora_alpha` (scaling factor)**: LoRA layers များအတွက် scaling factor။
*   **`lora_dropout` (dropout probability)**: LoRA layers များအတွက် dropout probability။
*   **`bias`**: LoRA တွင် bias terms များကို train လုပ်ခြင်းရှိမရှိ ထိန်းချုပ်သော parameter။
*   **`target_modules`**: LoRA ကို မည်သည့် model modules များတွင် အသုံးပြုမည်ကို သတ်မှတ်သော parameter။
*   **`task_type`**: model architecture အတွက် task အမျိုးအစား (ဥပမာ- "CAUSAL_LM")။
*   **CAUSAL_LM (Causal Language Model)**: စာသား sequence တစ်ခု၏ နောက်ဆက်တွဲ token (စကားလုံး) ကို ခန့်မှန်းရန် လေ့ကျင့်ထားသော language model အမျိုးအစား။
*   **Training Loss**: Training လုပ်စဉ် model ၏ loss တန်ဖိုး။
*   **Validation Sets**: Training လုပ်နေစဉ် model ၏ စွမ်းဆောင်ရည်ကို အကဲဖြတ်ရန် အသုံးပြုသော dataset အပိုင်း။
*   **Overfitting**: Model တစ်ခုသည် training data ကို အလွန်အမင်း သင်ယူထားခြင်းကြောင့် မမြင်ဖူးသေးသော data များပေါ်တွင် စွမ်းဆောင်ရည် နည်းပါးခြင်း။
*   **Full Fine-tuning Baselines**: model ၏ parameters အားလုံးကို fine-tuning လုပ်ထားသော model ၏ စွမ်းဆောင်ရည်ကို နှိုင်းယှဉ်ရန်အတွက် အခြေခံရလဒ်များ။
*   **`device_map="auto"`**: Hugging Face Transformers တွင် model ကို GPU သို့မဟုတ် CPU သို့ အလိုအလျောက် assign လုပ်ရန်။
*   **`device_map={"": device_index}`**: Model ကို သီးခြား device index တစ်ခုသို့ ကိုယ်တိုင် assign လုပ်ရန်။
*   **`SFTTrainer`**: TRL library မှ `Trainer` class ၏ extension တစ်ခုဖြစ်ပြီး Supervised Fine-Tuning လုပ်ငန်းစဉ်ကို ရိုးရှင်းစေသည်။
*   **`max_seq_length`**: Model ၏ input sequence ၏ အမြင့်ဆုံး အရှည်။
*   **`processing_class`**: Tokenizer class ကို ရည်ညွှန်းသည်။
*   **`HuggingFaceTB/smoltalk`**: Hugging Face Hub ပေါ်ရှိ dataset တစ်ခု၏ identifier။
*   **`deepseek-ai/DeepSeek-R1-Distill-Qwen-1.5B`**: Hugging Face Hub ပေါ်ရှိ model တစ်ခု၏ identifier။
*   **Deployment**: trained model တစ်ခုကို အသုံးပြုသူများ လက်လှမ်းမီနိုင်သော ပတ်ဝန်းကျင်သို့ ဖြန့်ကျက်ခြင်း။
*   **Memory Management**: ကွန်ပျူတာ၏ မှတ်ဉာဏ်ကို ထိရောက်စွာ အသုံးပြုခြင်းနှင့် စီမံခန့်ခွဲခြင်း။
*   **Precision**: floating-point numbers များကို ကိုယ်စားပြုရာတွင် အသုံးပြုသော bits အရေအတွက် (ဥပမာ- float16, float32)။
*   **`torch_dtype=torch.float16`**: PyTorch တွင် tensor များ၏ data type ကို float16 အဖြစ် သတ်မှတ်ရန်။
*   **`peft_model.merge_and_unload()`**: PEFT library မှ method တစ်ခုဖြစ်ပြီး adapter weights များကို base model ထဲသို့ ပေါင်းစပ်ပြီး adapter modules များကို unload လုပ်သည်။
*   **`save_pretrained()`**: Hugging Face Transformers library မှ method တစ်ခုဖြစ်ပြီး model သို့မဟုတ် tokenizer ကို disk ထဲသို့ သိမ်းဆည်းရန်။
*   **`AutoTokenizer`**: Hugging Face Transformers library မှာ ပါဝင်တဲ့ class တစ်ခုဖြစ်ပြီး မော်ဒယ်အမည်ကို အသုံးပြုပြီး သက်ဆိုင်ရာ tokenizer ကို အလိုအလျောက် load လုပ်ပေးသည်။