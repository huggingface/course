import{s as sa,f as la,o as aa,n as ls}from"../chunks/scheduler.37c15a92.js";import{S as na,i as oa,g as T,s as i,r as u,A as ia,h as U,f as s,c as p,j as ml,u as h,x as f,k as We,y as pa,a,v as d,t as c,b as rt,d as M,w as J,e as Pl,p as Mt}from"../chunks/index.2bf4358c.js";import{T as ct}from"../chunks/Tip.363c041f.js";import{Y as ul}from"../chunks/Youtube.1e50a667.js";import{C as I}from"../chunks/CodeBlock.4f5fc1ad.js";import{C as ta}from"../chunks/CourseFloatingBanner.15ba07e6.js";import{F as ra}from"../chunks/FrameworkSwitchCourse.8d4d4ab6.js";import{H as ys}from"../chunks/Heading.8ada512a.js";function Ma(C){let l,r;return l=new ta({props:{chapter:7,classNames:"absolute z-10 right-0 top-0",notebooks:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter7/section6_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter7/section6_tf.ipynb"}]}}),{c(){u(l.$$.fragment)},l(n){h(l.$$.fragment,n)},m(n,y){d(l,n,y),r=!0},i(n){r||(M(l.$$.fragment,n),r=!0)},o(n){c(l.$$.fragment,n),r=!1},d(n){J(l,n)}}}function ca(C){let l,r;return l=new ta({props:{chapter:7,classNames:"absolute z-10 right-0 top-0",notebooks:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/en/chapter7/section6_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/en/chapter7/section6_pt.ipynb"}]}}),{c(){u(l.$$.fragment)},l(n){h(l.$$.fragment,n)},m(n,y){d(l,n,y),r=!0},i(n){r||(M(l.$$.fragment,n),r=!0)},o(n){c(l.$$.fragment,n),r=!1},d(n){J(l,n)}}}function ya(C){let l,r="Pretraining the language model will take a while. We suggest that you first run the training loop on a sample of the data by uncommenting the two partial lines above, and make sure that the training successfully completes and the models are stored. Nothing is more frustrating than a training run failing at the last step because you forgot to create a folder or because there‚Äôs a typo at the end of the training loop!";return{c(){l=T("p"),l.textContent=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-11piewf"&&(l.textContent=r)},m(n,y){a(n,l,y)},p:ls,d(n){n&&s(l)}}}function wa(C){let l,r="‚úèÔ∏è <strong>Try it out!</strong> Getting rid of all the chunks that are smaller than the context size wasn‚Äôt a big issue here because we‚Äôre using small context windows. As you increase the context size (or if you have a corpus of short documents), the fraction of chunks that are thrown away will also grow. A more efficient way to prepare the data is to join all the tokenized samples in a batch with an <code>eos_token_id</code> token in between, and then perform the chunking on the concatenated sequences. As an exercise, modify the <code>tokenize()</code> function to make use of that approach. Note that you‚Äôll want to set <code>truncation=False</code> and remove the other arguments from the tokenizer to get the full sequence of token IDs.";return{c(){l=T("p"),l.innerHTML=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-n84vqf"&&(l.innerHTML=r)},m(n,y){a(n,l,y)},p:ls,d(n){n&&s(l)}}}function ma(C){let l,r,n,y="With that configuration, we can load a new model. Note that this is the first time we don‚Äôt use the <code>from_pretrained()</code> function, since we‚Äôre actually initializing a model ourself:",g,j,$,Z,k;return l=new I({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Ub2tlbml6ZXIlMkMlMjBURkdQVDJMTUhlYWRNb2RlbCUyQyUyMEF1dG9Db25maWclMEElMEFjb25maWclMjAlM0QlMjBBdXRvQ29uZmlnLmZyb21fcHJldHJhaW5lZCglMEElMjAlMjAlMjAlMjAlMjJncHQyJTIyJTJDJTBBJTIwJTIwJTIwJTIwdm9jYWJfc2l6ZSUzRGxlbih0b2tlbml6ZXIpJTJDJTBBJTIwJTIwJTIwJTIwbl9jdHglM0Rjb250ZXh0X2xlbmd0aCUyQyUwQSUyMCUyMCUyMCUyMGJvc190b2tlbl9pZCUzRHRva2VuaXplci5ib3NfdG9rZW5faWQlMkMlMEElMjAlMjAlMjAlMjBlb3NfdG9rZW5faWQlM0R0b2tlbml6ZXIuZW9zX3Rva2VuX2lkJTJDJTBBKQ==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFGPT2LMHeadModel, AutoConfig

config = AutoConfig.from_pretrained(
    <span class="hljs-string">&quot;gpt2&quot;</span>,
    vocab_size=<span class="hljs-built_in">len</span>(tokenizer),
    n_ctx=context_length,
    bos_token_id=tokenizer.bos_token_id,
    eos_token_id=tokenizer.eos_token_id,
)`,wrap:!1}}),j=new I({props:{code:"bW9kZWwlMjAlM0QlMjBURkdQVDJMTUhlYWRNb2RlbChjb25maWcpJTBBbW9kZWwobW9kZWwuZHVtbXlfaW5wdXRzKSUyMCUyMCUyMyUyMEJ1aWxkcyUyMHRoZSUyMG1vZGVsJTBBbW9kZWwuc3VtbWFyeSgp",highlighted:`model = TFGPT2LMHeadModel(config)
model(model.dummy_inputs)  <span class="hljs-comment"># Builds the model</span>
model.summary()`,wrap:!1}}),Z=new I({props:{code:"X19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18lMEFMYXllciUyMCh0eXBlKSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyME91dHB1dCUyMFNoYXBlJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwUGFyYW0lMjAlMjMlMjAlMjAlMjAlMEElM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlM0QlMEF0cmFuc2Zvcm1lciUyMChURkdQVDJNYWluTGF5ZXIlMjBtdWx0aXBsZSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMDEyNDI0MjQzMiUyMCUwQSUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUzRCUwQVRvdGFsJTIwcGFyYW1zJTNBJTIwMTI0JTJDMjQyJTJDNDMyJTBBVHJhaW5hYmxlJTIwcGFyYW1zJTNBJTIwMTI0JTJDMjQyJTJDNDMyJTBBTm9uLXRyYWluYWJsZSUyMHBhcmFtcyUzQSUyMDAlMEFfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXw==",highlighted:`_________________________________________________________________
Layer (<span class="hljs-built_in">type</span>)                 Output Shape              Param <span class="hljs-comment">#   </span>
=================================================================
transformer (TFGPT2MainLayer multiple                  <span class="hljs-number">124242432</span> 
=================================================================
Total params: <span class="hljs-number">124</span>,<span class="hljs-number">242</span>,<span class="hljs-number">432</span>
Trainable params: <span class="hljs-number">124</span>,<span class="hljs-number">242</span>,<span class="hljs-number">432</span>
Non-trainable params: <span class="hljs-number">0</span>
_________________________________________________________________`,wrap:!1}}),{c(){u(l.$$.fragment),r=i(),n=T("p"),n.innerHTML=y,g=i(),u(j.$$.fragment),$=i(),u(Z.$$.fragment)},l(m){h(l.$$.fragment,m),r=p(m),n=U(m,"P",{"data-svelte-h":!0}),f(n)!=="svelte-1tlyd8t"&&(n.innerHTML=y),g=p(m),h(j.$$.fragment,m),$=p(m),h(Z.$$.fragment,m)},m(m,b){d(l,m,b),a(m,r,b),a(m,n,b),a(m,g,b),d(j,m,b),a(m,$,b),d(Z,m,b),k=!0},i(m){k||(M(l.$$.fragment,m),M(j.$$.fragment,m),M(Z.$$.fragment,m),k=!0)},o(m){c(l.$$.fragment,m),c(j.$$.fragment,m),c(Z.$$.fragment,m),k=!1},d(m){m&&(s(r),s(n),s(g),s($)),J(l,m),J(j,m),J(Z,m)}}}function ua(C){let l,r,n,y="With that configuration, we can load a new model. Note that this is the first time we don‚Äôt use the <code>from_pretrained()</code> function, since we‚Äôre actually initializing a model ourself:",g,j,$,Z,k;return l=new I({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Ub2tlbml6ZXIlMkMlMjBHUFQyTE1IZWFkTW9kZWwlMkMlMjBBdXRvQ29uZmlnJTBBJTBBY29uZmlnJTIwJTNEJTIwQXV0b0NvbmZpZy5mcm9tX3ByZXRyYWluZWQoJTBBJTIwJTIwJTIwJTIwJTIyZ3B0MiUyMiUyQyUwQSUyMCUyMCUyMCUyMHZvY2FiX3NpemUlM0RsZW4odG9rZW5pemVyKSUyQyUwQSUyMCUyMCUyMCUyMG5fY3R4JTNEY29udGV4dF9sZW5ndGglMkMlMEElMjAlMjAlMjAlMjBib3NfdG9rZW5faWQlM0R0b2tlbml6ZXIuYm9zX3Rva2VuX2lkJTJDJTBBJTIwJTIwJTIwJTIwZW9zX3Rva2VuX2lkJTNEdG9rZW5pemVyLmVvc190b2tlbl9pZCUyQyUwQSk=",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, GPT2LMHeadModel, AutoConfig

config = AutoConfig.from_pretrained(
    <span class="hljs-string">&quot;gpt2&quot;</span>,
    vocab_size=<span class="hljs-built_in">len</span>(tokenizer),
    n_ctx=context_length,
    bos_token_id=tokenizer.bos_token_id,
    eos_token_id=tokenizer.eos_token_id,
)`,wrap:!1}}),j=new I({props:{code:"bW9kZWwlMjAlM0QlMjBHUFQyTE1IZWFkTW9kZWwoY29uZmlnKSUwQW1vZGVsX3NpemUlMjAlM0QlMjBzdW0odC5udW1lbCgpJTIwZm9yJTIwdCUyMGluJTIwbW9kZWwucGFyYW1ldGVycygpKSUwQXByaW50KGYlMjJHUFQtMiUyMHNpemUlM0ElMjAlN0Jtb2RlbF9zaXplJTJGMTAwMCoqMiUzQS4xZiU3RE0lMjBwYXJhbWV0ZXJzJTIyKQ==",highlighted:`model = GPT2LMHeadModel(config)
model_size = <span class="hljs-built_in">sum</span>(t.numel() <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> model.parameters())
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;GPT-2 size: <span class="hljs-subst">{model_size/<span class="hljs-number">1000</span>**<span class="hljs-number">2</span>:<span class="hljs-number">.1</span>f}</span>M parameters&quot;</span>)`,wrap:!1}}),Z=new I({props:{code:"R1BULTIlMjBzaXplJTNBJTIwMTI0LjJNJTIwcGFyYW1ldGVycw==",highlighted:'GPT-<span class="hljs-number">2</span> size: <span class="hljs-number">124.2</span>M parameters',wrap:!1}}),{c(){u(l.$$.fragment),r=i(),n=T("p"),n.innerHTML=y,g=i(),u(j.$$.fragment),$=i(),u(Z.$$.fragment)},l(m){h(l.$$.fragment,m),r=p(m),n=U(m,"P",{"data-svelte-h":!0}),f(n)!=="svelte-1tlyd8t"&&(n.innerHTML=y),g=p(m),h(j.$$.fragment,m),$=p(m),h(Z.$$.fragment,m)},m(m,b){d(l,m,b),a(m,r,b),a(m,n,b),a(m,g,b),d(j,m,b),a(m,$,b),d(Z,m,b),k=!0},i(m){k||(M(l.$$.fragment,m),M(j.$$.fragment,m),M(Z.$$.fragment,m),k=!0)},o(m){c(l.$$.fragment,m),c(j.$$.fragment,m),c(Z.$$.fragment,m),k=!1},d(m){m&&(s(r),s(n),s(g),s($)),J(l,m),J(j,m),J(Z,m)}}}function ha(C){let l,r;return l=new I({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMERhdGFDb2xsYXRvckZvckxhbmd1YWdlTW9kZWxpbmclMEElMEF0b2tlbml6ZXIucGFkX3Rva2VuJTIwJTNEJTIwdG9rZW5pemVyLmVvc190b2tlbiUwQWRhdGFfY29sbGF0b3IlMjAlM0QlMjBEYXRhQ29sbGF0b3JGb3JMYW5ndWFnZU1vZGVsaW5nKHRva2VuaXplciUyQyUyMG1sbSUzREZhbHNlJTJDJTIwcmV0dXJuX3RlbnNvcnMlM0QlMjJ0ZiUyMik=",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorForLanguageModeling

tokenizer.pad_token = tokenizer.eos_token
data_collator = DataCollatorForLanguageModeling(tokenizer, mlm=<span class="hljs-literal">False</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)`,wrap:!1}}),{c(){u(l.$$.fragment)},l(n){h(l.$$.fragment,n)},m(n,y){d(l,n,y),r=!0},i(n){r||(M(l.$$.fragment,n),r=!0)},o(n){c(l.$$.fragment,n),r=!1},d(n){J(l,n)}}}function da(C){let l,r;return l=new I({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMERhdGFDb2xsYXRvckZvckxhbmd1YWdlTW9kZWxpbmclMEElMEF0b2tlbml6ZXIucGFkX3Rva2VuJTIwJTNEJTIwdG9rZW5pemVyLmVvc190b2tlbiUwQWRhdGFfY29sbGF0b3IlMjAlM0QlMjBEYXRhQ29sbGF0b3JGb3JMYW5ndWFnZU1vZGVsaW5nKHRva2VuaXplciUyQyUyMG1sbSUzREZhbHNlKQ==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorForLanguageModeling

tokenizer.pad_token = tokenizer.eos_token
data_collator = DataCollatorForLanguageModeling(tokenizer, mlm=<span class="hljs-literal">False</span>)`,wrap:!1}}),{c(){u(l.$$.fragment)},l(n){h(l.$$.fragment,n)},m(n,y){d(l,n,y),r=!0},i(n){r||(M(l.$$.fragment,n),r=!0)},o(n){c(l.$$.fragment,n),r=!1},d(n){J(l,n)}}}function Ja(C){let l,r;return l=new I({props:{code:"aW5wdXRfaWRzJTIwc2hhcGUlM0ElMjAoNSUyQyUyMDEyOCklMEFhdHRlbnRpb25fbWFzayUyMHNoYXBlJTNBJTIwKDUlMkMlMjAxMjgpJTBBbGFiZWxzJTIwc2hhcGUlM0ElMjAoNSUyQyUyMDEyOCk=",highlighted:`input_ids shape: (<span class="hljs-number">5</span>, <span class="hljs-number">128</span>)
attention_mask shape: (<span class="hljs-number">5</span>, <span class="hljs-number">128</span>)
labels shape: (<span class="hljs-number">5</span>, <span class="hljs-number">128</span>)`,wrap:!1}}),{c(){u(l.$$.fragment)},l(n){h(l.$$.fragment,n)},m(n,y){d(l,n,y),r=!0},i(n){r||(M(l.$$.fragment,n),r=!0)},o(n){c(l.$$.fragment,n),r=!1},d(n){J(l,n)}}}function Ta(C){let l,r;return l=new I({props:{code:"aW5wdXRfaWRzJTIwc2hhcGUlM0ElMjB0b3JjaC5TaXplKCU1QjUlMkMlMjAxMjglNUQpJTBBYXR0ZW50aW9uX21hc2slMjBzaGFwZSUzQSUyMHRvcmNoLlNpemUoJTVCNSUyQyUyMDEyOCU1RCklMEFsYWJlbHMlMjBzaGFwZSUzQSUyMHRvcmNoLlNpemUoJTVCNSUyQyUyMDEyOCU1RCk=",highlighted:`input_ids shape: torch.Size([<span class="hljs-number">5</span>, <span class="hljs-number">128</span>])
attention_mask shape: torch.Size([<span class="hljs-number">5</span>, <span class="hljs-number">128</span>])
labels shape: torch.Size([<span class="hljs-number">5</span>, <span class="hljs-number">128</span>])`,wrap:!1}}),{c(){u(l.$$.fragment)},l(n){h(l.$$.fragment,n)},m(n,y){d(l,n,y),r=!0},i(n){r||(M(l.$$.fragment,n),r=!0)},o(n){c(l.$$.fragment,n),r=!1},d(n){J(l,n)}}}function Ol(C){let l,r="Now we can use the <code>prepare_tf_dataset()</code> method to convert our datasets to TensorFlow datasets with the data collator we created above:",n,y,g;return y=new I({props:{code:"dGZfdHJhaW5fZGF0YXNldCUyMCUzRCUyMG1vZGVsLnByZXBhcmVfdGZfZGF0YXNldCglMEElMjAlMjAlMjAlMjB0b2tlbml6ZWRfZGF0YXNldHMlNUIlMjJ0cmFpbiUyMiU1RCUyQyUwQSUyMCUyMCUyMCUyMGNvbGxhdGVfZm4lM0RkYXRhX2NvbGxhdG9yJTJDJTBBJTIwJTIwJTIwJTIwc2h1ZmZsZSUzRFRydWUlMkMlMEElMjAlMjAlMjAlMjBiYXRjaF9zaXplJTNEMzIlMkMlMEEpJTBBdGZfZXZhbF9kYXRhc2V0JTIwJTNEJTIwbW9kZWwucHJlcGFyZV90Zl9kYXRhc2V0KCUwQSUyMCUyMCUyMCUyMHRva2VuaXplZF9kYXRhc2V0cyU1QiUyMnZhbGlkJTIyJTVEJTJDJTBBJTIwJTIwJTIwJTIwY29sbGF0ZV9mbiUzRGRhdGFfY29sbGF0b3IlMkMlMEElMjAlMjAlMjAlMjBzaHVmZmxlJTNERmFsc2UlMkMlMEElMjAlMjAlMjAlMjBiYXRjaF9zaXplJTNEMzIlMkMlMEEp",highlighted:`tf_train_dataset = model.prepare_tf_dataset(
    tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],
    collate_fn=data_collator,
    shuffle=<span class="hljs-literal">True</span>,
    batch_size=<span class="hljs-number">32</span>,
)
tf_eval_dataset = model.prepare_tf_dataset(
    tokenized_datasets[<span class="hljs-string">&quot;valid&quot;</span>],
    collate_fn=data_collator,
    shuffle=<span class="hljs-literal">False</span>,
    batch_size=<span class="hljs-number">32</span>,
)`,wrap:!1}}),{c(){l=T("p"),l.innerHTML=r,n=i(),u(y.$$.fragment)},l(j){l=U(j,"P",{"data-svelte-h":!0}),f(l)!=="svelte-13jf88u"&&(l.innerHTML=r),n=p(j),h(y.$$.fragment,j)},m(j,$){a(j,l,$),a(j,n,$),d(y,j,$),g=!0},i(j){g||(M(y.$$.fragment,j),g=!0)},o(j){c(y.$$.fragment,j),g=!1},d(j){j&&(s(l),s(n)),J(y,j)}}}function Ua(C){let l,r="‚ö†Ô∏è Shifting the inputs and labels to align them happens inside the model, so the data collator just copies the inputs to create the labels.";return{c(){l=T("p"),l.textContent=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-k25o8d"&&(l.textContent=r)},m(n,y){a(n,l,y)},p:ls,d(n){n&&s(l)}}}function fa(C){let l,r="All that‚Äôs left to do is configure the training hyperparameters and call <code>compile()</code> and <code>fit()</code>. We‚Äôll use a learning rate schedule with some warmup to improve the stability of training:",n,y,g,j,$="Now we can just call <code>model.fit()</code> and wait for training to finish. Depending on whether you run it on the full or a subset of the training set this will take 20 or 2 hours, respectively, so grab a few coffees and a good book to read! After training completes we can push the model and tokenizer to the Hub:",Z,k,m;return y=new I({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMGNyZWF0ZV9vcHRpbWl6ZXIlMEFpbXBvcnQlMjB0ZW5zb3JmbG93JTIwYXMlMjB0ZiUwQSUwQW51bV90cmFpbl9zdGVwcyUyMCUzRCUyMGxlbih0Zl90cmFpbl9kYXRhc2V0KSUwQW9wdGltaXplciUyQyUyMHNjaGVkdWxlJTIwJTNEJTIwY3JlYXRlX29wdGltaXplciglMEElMjAlMjAlMjAlMjBpbml0X2xyJTNENWUtNSUyQyUwQSUyMCUyMCUyMCUyMG51bV93YXJtdXBfc3RlcHMlM0QxXzAwMCUyQyUwQSUyMCUyMCUyMCUyMG51bV90cmFpbl9zdGVwcyUzRG51bV90cmFpbl9zdGVwcyUyQyUwQSUyMCUyMCUyMCUyMHdlaWdodF9kZWNheV9yYXRlJTNEMC4wMSUyQyUwQSklMEFtb2RlbC5jb21waWxlKG9wdGltaXplciUzRG9wdGltaXplciklMEElMEElMjMlMjBUcmFpbiUyMGluJTIwbWl4ZWQtcHJlY2lzaW9uJTIwZmxvYXQxNiUwQXRmLmtlcmFzLm1peGVkX3ByZWNpc2lvbi5zZXRfZ2xvYmFsX3BvbGljeSglMjJtaXhlZF9mbG9hdDE2JTIyKQ==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> create_optimizer
<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

num_train_steps = <span class="hljs-built_in">len</span>(tf_train_dataset)
optimizer, schedule = create_optimizer(
    init_lr=<span class="hljs-number">5e-5</span>,
    num_warmup_steps=<span class="hljs-number">1_000</span>,
    num_train_steps=num_train_steps,
    weight_decay_rate=<span class="hljs-number">0.01</span>,
)
model.<span class="hljs-built_in">compile</span>(optimizer=optimizer)

<span class="hljs-comment"># Train in mixed-precision float16</span>
tf.keras.mixed_precision.set_global_policy(<span class="hljs-string">&quot;mixed_float16&quot;</span>)`,wrap:!1}}),k=new I({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycy5rZXJhc19jYWxsYmFja3MlMjBpbXBvcnQlMjBQdXNoVG9IdWJDYWxsYmFjayUwQSUwQWNhbGxiYWNrJTIwJTNEJTIwUHVzaFRvSHViQ2FsbGJhY2sob3V0cHV0X2RpciUzRCUyMmNvZGVwYXJyb3QtZHMlMjIlMkMlMjB0b2tlbml6ZXIlM0R0b2tlbml6ZXIpJTBBJTBBbW9kZWwuZml0KHRmX3RyYWluX2RhdGFzZXQlMkMlMjB2YWxpZGF0aW9uX2RhdGElM0R0Zl9ldmFsX2RhdGFzZXQlMkMlMjBjYWxsYmFja3MlM0QlNUJjYWxsYmFjayU1RCk=",highlighted:`<span class="hljs-keyword">from</span> transformers.keras_callbacks <span class="hljs-keyword">import</span> PushToHubCallback

callback = PushToHubCallback(output_dir=<span class="hljs-string">&quot;codeparrot-ds&quot;</span>, tokenizer=tokenizer)

model.fit(tf_train_dataset, validation_data=tf_eval_dataset, callbacks=[callback])`,wrap:!1}}),{c(){l=T("p"),l.innerHTML=r,n=i(),u(y.$$.fragment),g=i(),j=T("p"),j.innerHTML=$,Z=i(),u(k.$$.fragment)},l(b){l=U(b,"P",{"data-svelte-h":!0}),f(l)!=="svelte-mj1jm"&&(l.innerHTML=r),n=p(b),h(y.$$.fragment,b),g=p(b),j=U(b,"P",{"data-svelte-h":!0}),f(j)!=="svelte-18w1tu4"&&(j.innerHTML=$),Z=p(b),h(k.$$.fragment,b)},m(b,G){a(b,l,G),a(b,n,G),d(y,b,G),a(b,g,G),a(b,j,G),a(b,Z,G),d(k,b,G),m=!0},i(b){m||(M(y.$$.fragment,b),M(k.$$.fragment,b),m=!0)},o(b){c(y.$$.fragment,b),c(k.$$.fragment,b),m=!1},d(b){b&&(s(l),s(n),s(g),s(j),s(Z)),J(y,b),J(k,b)}}}function ja(C){let l,r="All that‚Äôs left to do is configure the training arguments and fire up the <code>Trainer</code>. We‚Äôll use a cosine learning rate schedule with some warmup and an effective batch size of 256 (<code>per_device_train_batch_size</code> * <code>gradient_accumulation_steps</code>). Gradient accumulation is used when a single batch does not fit into memory, and incrementally builds up the gradient through several forward/backward passes. We‚Äôll see this in action when we create the training loop with ü§ó Accelerate.",n,y,g,j,$="Now we can just start the <code>Trainer</code> and wait for training to finish. Depending on whether you run it on the full or a subset of the training set this will take 20 or 2 hours, respectively, so grab a few coffees and a good book to read!",Z,k,m,b,G="After training completes, we can push the model and tokenizer to the Hub:",V,Q,R;return y=new I({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluZXIlMkMlMjBUcmFpbmluZ0FyZ3VtZW50cyUwQSUwQWFyZ3MlMjAlM0QlMjBUcmFpbmluZ0FyZ3VtZW50cyglMEElMjAlMjAlMjAlMjBvdXRwdXRfZGlyJTNEJTIyY29kZXBhcnJvdC1kcyUyMiUyQyUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfdHJhaW5fYmF0Y2hfc2l6ZSUzRDMyJTJDJTBBJTIwJTIwJTIwJTIwcGVyX2RldmljZV9ldmFsX2JhdGNoX3NpemUlM0QzMiUyQyUwQSUyMCUyMCUyMCUyMGV2YWx1YXRpb25fc3RyYXRlZ3klM0QlMjJzdGVwcyUyMiUyQyUwQSUyMCUyMCUyMCUyMGV2YWxfc3RlcHMlM0Q1XzAwMCUyQyUwQSUyMCUyMCUyMCUyMGxvZ2dpbmdfc3RlcHMlM0Q1XzAwMCUyQyUwQSUyMCUyMCUyMCUyMGdyYWRpZW50X2FjY3VtdWxhdGlvbl9zdGVwcyUzRDglMkMlMEElMjAlMjAlMjAlMjBudW1fdHJhaW5fZXBvY2hzJTNEMSUyQyUwQSUyMCUyMCUyMCUyMHdlaWdodF9kZWNheSUzRDAuMSUyQyUwQSUyMCUyMCUyMCUyMHdhcm11cF9zdGVwcyUzRDFfMDAwJTJDJTBBJTIwJTIwJTIwJTIwbHJfc2NoZWR1bGVyX3R5cGUlM0QlMjJjb3NpbmUlMjIlMkMlMEElMjAlMjAlMjAlMjBsZWFybmluZ19yYXRlJTNENWUtNCUyQyUwQSUyMCUyMCUyMCUyMHNhdmVfc3RlcHMlM0Q1XzAwMCUyQyUwQSUyMCUyMCUyMCUyMGZwMTYlM0RUcnVlJTJDJTBBJTIwJTIwJTIwJTIwcHVzaF90b19odWIlM0RUcnVlJTJDJTBBKSUwQSUwQXRyYWluZXIlMjAlM0QlMjBUcmFpbmVyKCUwQSUyMCUyMCUyMCUyMG1vZGVsJTNEbW9kZWwlMkMlMEElMjAlMjAlMjAlMjB0b2tlbml6ZXIlM0R0b2tlbml6ZXIlMkMlMEElMjAlMjAlMjAlMjBhcmdzJTNEYXJncyUyQyUwQSUyMCUyMCUyMCUyMGRhdGFfY29sbGF0b3IlM0RkYXRhX2NvbGxhdG9yJTJDJTBBJTIwJTIwJTIwJTIwdHJhaW5fZGF0YXNldCUzRHRva2VuaXplZF9kYXRhc2V0cyU1QiUyMnRyYWluJTIyJTVEJTJDJTBBJTIwJTIwJTIwJTIwZXZhbF9kYXRhc2V0JTNEdG9rZW5pemVkX2RhdGFzZXRzJTVCJTIydmFsaWQlMjIlNUQlMkMlMEEp",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer, TrainingArguments

args = TrainingArguments(
    output_dir=<span class="hljs-string">&quot;codeparrot-ds&quot;</span>,
    per_device_train_batch_size=<span class="hljs-number">32</span>,
    per_device_eval_batch_size=<span class="hljs-number">32</span>,
    evaluation_strategy=<span class="hljs-string">&quot;steps&quot;</span>,
    eval_steps=<span class="hljs-number">5_000</span>,
    logging_steps=<span class="hljs-number">5_000</span>,
    gradient_accumulation_steps=<span class="hljs-number">8</span>,
    num_train_epochs=<span class="hljs-number">1</span>,
    weight_decay=<span class="hljs-number">0.1</span>,
    warmup_steps=<span class="hljs-number">1_000</span>,
    lr_scheduler_type=<span class="hljs-string">&quot;cosine&quot;</span>,
    learning_rate=<span class="hljs-number">5e-4</span>,
    save_steps=<span class="hljs-number">5_000</span>,
    fp16=<span class="hljs-literal">True</span>,
    push_to_hub=<span class="hljs-literal">True</span>,
)

trainer = Trainer(
    model=model,
    tokenizer=tokenizer,
    args=args,
    data_collator=data_collator,
    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;valid&quot;</span>],
)`,wrap:!1}}),k=new I({props:{code:"dHJhaW5lci50cmFpbigp",highlighted:"trainer.train()",wrap:!1}}),Q=new I({props:{code:"dHJhaW5lci5wdXNoX3RvX2h1Yigp",highlighted:"trainer.push_to_hub()",wrap:!1}}),{c(){l=T("p"),l.innerHTML=r,n=i(),u(y.$$.fragment),g=i(),j=T("p"),j.innerHTML=$,Z=i(),u(k.$$.fragment),m=i(),b=T("p"),b.textContent=G,V=i(),u(Q.$$.fragment)},l(_){l=U(_,"P",{"data-svelte-h":!0}),f(l)!=="svelte-3hmwum"&&(l.innerHTML=r),n=p(_),h(y.$$.fragment,_),g=p(_),j=U(_,"P",{"data-svelte-h":!0}),f(j)!=="svelte-7ziduw"&&(j.innerHTML=$),Z=p(_),h(k.$$.fragment,_),m=p(_),b=U(_,"P",{"data-svelte-h":!0}),f(b)!=="svelte-16pwd35"&&(b.textContent=G),V=p(_),h(Q.$$.fragment,_)},m(_,B){a(_,l,B),a(_,n,B),d(y,_,B),a(_,g,B),a(_,j,B),a(_,Z,B),d(k,_,B),a(_,m,B),a(_,b,B),a(_,V,B),d(Q,_,B),R=!0},i(_){R||(M(y.$$.fragment,_),M(k.$$.fragment,_),M(Q.$$.fragment,_),R=!0)},o(_){c(y.$$.fragment,_),c(k.$$.fragment,_),c(Q.$$.fragment,_),R=!1},d(_){_&&(s(l),s(n),s(g),s(j),s(Z),s(m),s(b),s(V)),J(y,_),J(k,_),J(Q,_)}}}function ba(C){let l,r="‚úèÔ∏è <strong>Try it out!</strong> It only took us about 30 lines of code in addition to the <code>TrainingArguments</code> to get from raw texts to training GPT-2. Try it out with your own dataset and see if you can get good results!";return{c(){l=T("p"),l.innerHTML=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-ayzxue"&&(l.innerHTML=r)},m(n,y){a(n,l,y)},p:ls,d(n){n&&s(l)}}}function Ia(C){let l,r='üí° If you have access to a machine with multiple GPUs, you can try using a <code>MirroredStrategy</code> context to substantially speed up training. You‚Äôll need to create a <code>tf.distribute.MirroredStrategy</code> object, and make sure that any <code>to_tf_dataset()</code> or <code>prepare_tf_dataset()</code> methods as well as model creation and the call to <code>fit()</code> are all run in its <code>scope()</code> context. You can see documentation on this <a href="https://www.tensorflow.org/guide/distributed_training#use_tfdistributestrategy_with_keras_modelfit" rel="nofollow">here</a>.';return{c(){l=T("p"),l.innerHTML=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-cn7tf5"&&(l.innerHTML=r)},m(n,y){a(n,l,y)},d(n){n&&s(l)}}}function Ca(C){let l,r="üí° If you have access to a machine with multiple GPUs, try to run the code there. The <code>Trainer</code> automatically manages multiple machines, and this can speed up training tremendously.";return{c(){l=T("p"),l.innerHTML=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-156ysgv"&&(l.innerHTML=r)},m(n,y){a(n,l,y)},d(n){n&&s(l)}}}function ga(C){let l;function r(g,j){return g[0]==="pt"?Ca:Ia}let n=r(C),y=n(C);return{c(){y.c(),l=Pl()},l(g){y.l(g),l=Pl()},m(g,j){y.m(g,j),a(g,l,j)},p(g,j){n!==(n=r(g))&&(y.d(1),y=n(g),y&&(y.c(),y.m(l.parentNode,l)))},d(g){g&&s(l),y.d(g)}}}function _a(C){let l,r;return l=new I({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMHBpcGVsaW5lJTBBJTBBY291cnNlX21vZGVsJTIwJTNEJTIwVEZHUFQyTE1IZWFkTW9kZWwuZnJvbV9wcmV0cmFpbmVkKCUyMmh1Z2dpbmdmYWNlLWNvdXJzZSUyRmNvZGVwYXJyb3QtZHMlMjIpJTBBY291cnNlX3Rva2VuaXplciUyMCUzRCUyMEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKCUyMmh1Z2dpbmdmYWNlLWNvdXJzZSUyRmNvZGVwYXJyb3QtZHMlMjIpJTBBcGlwZSUyMCUzRCUyMHBpcGVsaW5lKCUwQSUyMCUyMCUyMCUyMCUyMnRleHQtZ2VuZXJhdGlvbiUyMiUyQyUyMG1vZGVsJTNEY291cnNlX21vZGVsJTJDJTIwdG9rZW5pemVyJTNEY291cnNlX3Rva2VuaXplciUyQyUyMGRldmljZSUzRDAlMEEp",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

course_model = TFGPT2LMHeadModel.from_pretrained(<span class="hljs-string">&quot;huggingface-course/codeparrot-ds&quot;</span>)
course_tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;huggingface-course/codeparrot-ds&quot;</span>)
pipe = pipeline(
    <span class="hljs-string">&quot;text-generation&quot;</span>, model=course_model, tokenizer=course_tokenizer, device=<span class="hljs-number">0</span>
)`,wrap:!1}}),{c(){u(l.$$.fragment)},l(n){h(l.$$.fragment,n)},m(n,y){d(l,n,y),r=!0},i(n){r||(M(l.$$.fragment,n),r=!0)},o(n){c(l.$$.fragment,n),r=!1},d(n){J(l,n)}}}function ka(C){let l,r;return l=new I({props:{code:"aW1wb3J0JTIwdG9yY2glMEFmcm9tJTIwdHJhbnNmb3JtZXJzJTIwaW1wb3J0JTIwcGlwZWxpbmUlMEElMEFkZXZpY2UlMjAlM0QlMjB0b3JjaC5kZXZpY2UoJTIyY3VkYSUyMiklMjBpZiUyMHRvcmNoLmN1ZGEuaXNfYXZhaWxhYmxlKCklMjBlbHNlJTIwdG9yY2guZGV2aWNlKCUyMmNwdSUyMiklMEFwaXBlJTIwJTNEJTIwcGlwZWxpbmUoJTBBJTIwJTIwJTIwJTIwJTIydGV4dC1nZW5lcmF0aW9uJTIyJTJDJTIwbW9kZWwlM0QlMjJodWdnaW5nZmFjZS1jb3Vyc2UlMkZjb2RlcGFycm90LWRzJTIyJTJDJTIwZGV2aWNlJTNEZGV2aWNlJTBBKQ==",highlighted:`<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>) <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)
pipe = pipeline(
    <span class="hljs-string">&quot;text-generation&quot;</span>, model=<span class="hljs-string">&quot;huggingface-course/codeparrot-ds&quot;</span>, device=device
)`,wrap:!1}}),{c(){u(l.$$.fragment)},l(n){h(l.$$.fragment,n)},m(n,y){d(l,n,y),r=!0},i(n){r||(M(l.$$.fragment,n),r=!0)},o(n){c(l.$$.fragment,n),r=!1},d(n){J(l,n)}}}function Za(C){let l,r="Looking at these few examples, it seems that the model has learned some of the syntax of the Python data science stack (of course, we would need to evaluate it more thoroughly before deploying the model in the real world). Sometimes it requires more customization of the model training to achieve the necessary performance for a given use case, however. For example, what if we would like to dynamically update the batch size or have a conditional training loop that skips bad examples on the fly? One option would be to subclass the <code>Trainer</code> and add the necessary changes, but sometimes it‚Äôs simpler to write the training loop from scratch. That‚Äôs where ü§ó Accelerate comes in.";return{c(){l=T("p"),l.innerHTML=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-n4fvox"&&(l.innerHTML=r)},m(n,y){a(n,l,y)},d(n){n&&s(l)}}}function $a(C){let l,r="Looking at these few examples, it seems that the model has learned some of the syntax of the Python data science stack. Of course, we would need to evaluate the model more thoroughly before deploying it in the real world, but this is still an impressive prototype.";return{c(){l=T("p"),l.textContent=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-1kfbi7i"&&(l.textContent=r)},m(n,y){a(n,l,y)},d(n){n&&s(l)}}}function ea(C){let l,r,n,y="We‚Äôve seen how to train a model with the <code>Trainer</code>, which can allow for some customization. However, sometimes we want full control over the training loop, or we want to make some exotic changes. In this case ü§ó Accelerate is a great choice, and in this section we‚Äôll go through the steps to use it to train our model. To make things more interesting, we‚Äôll also add a twist to the training loop.",g,j,$,Z,k="Since we are mainly interested in sensible autocompletion for the the data science libraries, it makes sense to give more weight to training samples that make more use of these libraries. We can easily identify these examples through the use of keywords such as <code>plt</code>, <code>pd</code>, <code>sk</code>, <code>fit</code>, and <code>predict</code>, which are the most frequent import names for <code>matplotlib.pyplot</code>, <code>pandas</code>, and <code>sklearn</code> as well as the fit/predict pattern of the latter. If these are each represented as a single token, we can easily check if they occur in the input sequence. Tokens can have a whitespace prefix, so we‚Äôll also check for those versions in the tokenizer vocabulary. To verify that it works, we‚Äôll add one test token which should be split into multiple tokens:",m,b,G,V,Q,R,_="Great, that seems to work nicely! We can now write a custom loss function that takes the input sequence, the logits, and the key tokens we just selected as inputs. First we need to align the logits and inputs: the input sequence shifted by one to the right forms the labels, since the next token is the label for the current token. We can achieve this by starting the labels from the second token of the input sequence, since the model does not make a prediction for the first token anyway. Then we cut off the last logit, as we don‚Äôt have a label for the token that follows the full input sequence. With that we can compute the loss per sample and count the occurrences of all keywords in each sample. Finally, we calculate the weighted average over all samples using the occurrences as weights. Since we don‚Äôt want to throw away all the samples that have no keywords, we add 1 to the weights:",B,x,ve,E,ws="Before we can start training with this awesome new loss function, we need to prepare a few things:",Qe,X,ms="<li>We need dataloaders to load the data in batches.</li> <li>We need to set up weight decay parameters.</li> <li>From time to time we want to evaluate, so it makes sense to wrap the evaluation code in a function.</li>",ze,A,us="Let‚Äôs start with the dataloaders. We only need to set the dataset‚Äôs format to <code>&quot;torch&quot;</code>, and then we can pass it to a PyTorch <code>DataLoader</code> with the appropriate batch size:",Ne,F,Ve,Y,hs="Next, we group the parameters so that the optimizer knows which ones will get an additional weight decay. Usually, all bias and LayerNorm weights terms are exempt from this; here‚Äôs how we can do this:",xe,H,yt,ie,Ze="Since we want to evaluate the model regularly on the validation set during training, let‚Äôs write a function for that as well. It just runs through the evaluation dataloader and gathers all the losses across processes:",Ee,S,wt,pe,$e='With the <code>evaluate()</code> function we can report loss and <a href="/course/chapter7/3">perplexity</a> at regular intervals. Next, we redefine our model to make sure we train from scratch again:',Ae,q,Fe,D,ds="We can then define our optimizer, using the function from before to split the parameters for weight decay:",Ye,L,He,K,Js="Now let‚Äôs prepare the model, optimizer, and dataloaders so we can start training:",Se,P,qe,O,De,ee,Ts="Now that we have sent our <code>train_dataloader</code> to <code>accelerator.prepare()</code>, we can use its length to compute the number of training steps. Remember that we should always do this after preparing the dataloader, as that method will change its length. We use a classic linear schedule from the learning rate to 0:",Le,te,mt,re,Ge="Lastly, to push our model to the Hub, we will need to create a <code>Repository</code> object in a working folder. First log in to the Hugging Face Hub, if you aren‚Äôt logged in already. We‚Äôll determine the repository name from the model ID we want to give our model (feel free to replace the <code>repo_name</code> with your own choice; it just needs to contain your username, which is what the function <code>get_full_repo_name()</code> does):",Ke,se,Pe,z,Oe,le,Us="Then we can clone that repository in a local folder. If it already exists, this local folder should be an existing clone of the repository we are working with:",et,ae,tt,ne,ut="We can now upload anything we save in <code>output_dir</code> by calling the <code>repo.push_to_hub()</code> method. This will help us upload the intermediate models at the end of each epoch.",Me,Be,ht="Before we train, let‚Äôs run a quick test to see if the evaluation function works properly:",ce,ye,we,me,ue,Xe,dt="Those are very high values for loss and perplexity, but that‚Äôs not surprising as we haven‚Äôt trained the model yet. With that, we have everything prepared to write the core part of the training script: the training loop. In the training loop we iterate over the dataloader and pass the batches to the model. With the logits, we can then evaluate our custom loss function. We scale the loss by the number of gradient accumulation steps so as not to create larger losses when aggregating more steps. Before we optimize, we also clip the gradients for better convergence. Finally, every few steps we evaluate the model on the evaluation set with our new <code>evaluate()</code> function:",he,Re,st,N,fs="And that‚Äôs it ‚Äî you now have your own custom training loop for causal language models such as GPT-2 that you can further customize to your needs.",lt,oe,Jt,de,Je;return l=new ys({props:{title:"Training with ü§ó Accelerate",local:"training-with-accelerate",headingTag:"h2"}}),j=new ul({props:{id:"Hm8_PgVTFuc"}}),b=new I({props:{code:"a2V5dG9rZW5faWRzJTIwJTNEJTIwJTVCJTVEJTBBZm9yJTIwa2V5d29yZCUyMGluJTIwJTVCJTBBJTIwJTIwJTIwJTIwJTIycGx0JTIyJTJDJTBBJTIwJTIwJTIwJTIwJTIycGQlMjIlMkMlMEElMjAlMjAlMjAlMjAlMjJzayUyMiUyQyUwQSUyMCUyMCUyMCUyMCUyMmZpdCUyMiUyQyUwQSUyMCUyMCUyMCUyMCUyMnByZWRpY3QlMjIlMkMlMEElMjAlMjAlMjAlMjAlMjIlMjBwbHQlMjIlMkMlMEElMjAlMjAlMjAlMjAlMjIlMjBwZCUyMiUyQyUwQSUyMCUyMCUyMCUyMCUyMiUyMHNrJTIyJTJDJTBBJTIwJTIwJTIwJTIwJTIyJTIwZml0JTIyJTJDJTBBJTIwJTIwJTIwJTIwJTIyJTIwcHJlZGljdCUyMiUyQyUwQSUyMCUyMCUyMCUyMCUyMnRlc3R0ZXN0JTIyJTJDJTBBJTVEJTNBJTBBJTIwJTIwJTIwJTIwaWRzJTIwJTNEJTIwdG9rZW5pemVyKCU1QmtleXdvcmQlNUQpLmlucHV0X2lkcyU1QjAlNUQlMEElMjAlMjAlMjAlMjBpZiUyMGxlbihpZHMpJTIwJTNEJTNEJTIwMSUzQSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGtleXRva2VuX2lkcy5hcHBlbmQoaWRzJTVCMCU1RCklMEElMjAlMjAlMjAlMjBlbHNlJTNBJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwcHJpbnQoZiUyMktleXdvcmQlMjBoYXMlMjBub3QlMjBzaW5nbGUlMjB0b2tlbiUzQSUyMCU3QmtleXdvcmQlN0QlMjIp",highlighted:`keytoken_ids = []
<span class="hljs-keyword">for</span> keyword <span class="hljs-keyword">in</span> [
    <span class="hljs-string">&quot;plt&quot;</span>,
    <span class="hljs-string">&quot;pd&quot;</span>,
    <span class="hljs-string">&quot;sk&quot;</span>,
    <span class="hljs-string">&quot;fit&quot;</span>,
    <span class="hljs-string">&quot;predict&quot;</span>,
    <span class="hljs-string">&quot; plt&quot;</span>,
    <span class="hljs-string">&quot; pd&quot;</span>,
    <span class="hljs-string">&quot; sk&quot;</span>,
    <span class="hljs-string">&quot; fit&quot;</span>,
    <span class="hljs-string">&quot; predict&quot;</span>,
    <span class="hljs-string">&quot;testtest&quot;</span>,
]:
    ids = tokenizer([keyword]).input_ids[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ids) == <span class="hljs-number">1</span>:
        keytoken_ids.append(ids[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">else</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Keyword has not single token: <span class="hljs-subst">{keyword}</span>&quot;</span>)`,wrap:!1}}),V=new I({props:{code:"J0tleXdvcmQlMjBoYXMlMjBub3QlMjBzaW5nbGUlMjB0b2tlbiUzQSUyMHRlc3R0ZXN0Jw==",highlighted:'<span class="hljs-string">&#x27;Keyword has not single token: testtest&#x27;</span>',wrap:!1}}),x=new I({props:{code:"ZnJvbSUyMHRvcmNoLm5uJTIwaW1wb3J0JTIwQ3Jvc3NFbnRyb3B5TG9zcyUwQWltcG9ydCUyMHRvcmNoJTBBJTBBJTBBZGVmJTIwa2V5dG9rZW5fd2VpZ2h0ZWRfbG9zcyhpbnB1dHMlMkMlMjBsb2dpdHMlMkMlMjBrZXl0b2tlbl9pZHMlMkMlMjBhbHBoYSUzRDEuMCklM0ElMEElMjAlMjAlMjAlMjAlMjMlMjBTaGlmdCUyMHNvJTIwdGhhdCUyMHRva2VucyUyMCUzQyUyMG4lMjBwcmVkaWN0JTIwbiUwQSUyMCUyMCUyMCUyMHNoaWZ0X2xhYmVscyUyMCUzRCUyMGlucHV0cyU1Qi4uLiUyQyUyMDElM0ElNUQuY29udGlndW91cygpJTBBJTIwJTIwJTIwJTIwc2hpZnRfbG9naXRzJTIwJTNEJTIwbG9naXRzJTVCLi4uJTJDJTIwJTNBLTElMkMlMjAlM0ElNUQuY29udGlndW91cygpJTBBJTIwJTIwJTIwJTIwJTIzJTIwQ2FsY3VsYXRlJTIwcGVyLXRva2VuJTIwbG9zcyUwQSUyMCUyMCUyMCUyMGxvc3NfZmN0JTIwJTNEJTIwQ3Jvc3NFbnRyb3B5TG9zcyhyZWR1Y2UlM0RGYWxzZSklMEElMjAlMjAlMjAlMjBsb3NzJTIwJTNEJTIwbG9zc19mY3Qoc2hpZnRfbG9naXRzLnZpZXcoLTElMkMlMjBzaGlmdF9sb2dpdHMuc2l6ZSgtMSkpJTJDJTIwc2hpZnRfbGFiZWxzLnZpZXcoLTEpKSUwQSUyMCUyMCUyMCUyMCUyMyUyMFJlc2l6ZSUyMGFuZCUyMGF2ZXJhZ2UlMjBsb3NzJTIwcGVyJTIwc2FtcGxlJTBBJTIwJTIwJTIwJTIwbG9zc19wZXJfc2FtcGxlJTIwJTNEJTIwbG9zcy52aWV3KHNoaWZ0X2xvZ2l0cy5zaXplKDApJTJDJTIwc2hpZnRfbG9naXRzLnNpemUoMSkpLm1lYW4oYXhpcyUzRDEpJTBBJTIwJTIwJTIwJTIwJTIzJTIwQ2FsY3VsYXRlJTIwYW5kJTIwc2NhbGUlMjB3ZWlnaHRpbmclMEElMjAlMjAlMjAlMjB3ZWlnaHRzJTIwJTNEJTIwdG9yY2guc3RhY2soJTVCKGlucHV0cyUyMCUzRCUzRCUyMGt0KS5mbG9hdCgpJTIwZm9yJTIwa3QlMjBpbiUyMGtleXRva2VuX2lkcyU1RCkuc3VtKCUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGF4aXMlM0QlNUIwJTJDJTIwMiU1RCUwQSUyMCUyMCUyMCUyMCklMEElMjAlMjAlMjAlMjB3ZWlnaHRzJTIwJTNEJTIwYWxwaGElMjAqJTIwKDEuMCUyMCUyQiUyMHdlaWdodHMpJTBBJTIwJTIwJTIwJTIwJTIzJTIwQ2FsY3VsYXRlJTIwd2VpZ2h0ZWQlMjBhdmVyYWdlJTBBJTIwJTIwJTIwJTIwd2VpZ2h0ZWRfbG9zcyUyMCUzRCUyMChsb3NzX3Blcl9zYW1wbGUlMjAqJTIwd2VpZ2h0cykubWVhbigpJTBBJTIwJTIwJTIwJTIwcmV0dXJuJTIwd2VpZ2h0ZWRfbG9zcw==",highlighted:`<span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> CrossEntropyLoss
<span class="hljs-keyword">import</span> torch


<span class="hljs-keyword">def</span> <span class="hljs-title function_">keytoken_weighted_loss</span>(<span class="hljs-params">inputs, logits, keytoken_ids, alpha=<span class="hljs-number">1.0</span></span>):
    <span class="hljs-comment"># Shift so that tokens &lt; n predict n</span>
    shift_labels = inputs[..., <span class="hljs-number">1</span>:].contiguous()
    shift_logits = logits[..., :-<span class="hljs-number">1</span>, :].contiguous()
    <span class="hljs-comment"># Calculate per-token loss</span>
    loss_fct = CrossEntropyLoss(reduce=<span class="hljs-literal">False</span>)
    loss = loss_fct(shift_logits.view(-<span class="hljs-number">1</span>, shift_logits.size(-<span class="hljs-number">1</span>)), shift_labels.view(-<span class="hljs-number">1</span>))
    <span class="hljs-comment"># Resize and average loss per sample</span>
    loss_per_sample = loss.view(shift_logits.size(<span class="hljs-number">0</span>), shift_logits.size(<span class="hljs-number">1</span>)).mean(axis=<span class="hljs-number">1</span>)
    <span class="hljs-comment"># Calculate and scale weighting</span>
    weights = torch.stack([(inputs == kt).<span class="hljs-built_in">float</span>() <span class="hljs-keyword">for</span> kt <span class="hljs-keyword">in</span> keytoken_ids]).<span class="hljs-built_in">sum</span>(
        axis=[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]
    )
    weights = alpha * (<span class="hljs-number">1.0</span> + weights)
    <span class="hljs-comment"># Calculate weighted average</span>
    weighted_loss = (loss_per_sample * weights).mean()
    <span class="hljs-keyword">return</span> weighted_loss`,wrap:!1}}),F=new I({props:{code:"ZnJvbSUyMHRvcmNoLnV0aWxzLmRhdGEuZGF0YWxvYWRlciUyMGltcG9ydCUyMERhdGFMb2FkZXIlMEElMEF0b2tlbml6ZWRfZGF0YXNldHMuc2V0X2Zvcm1hdCglMjJ0b3JjaCUyMiklMEF0cmFpbl9kYXRhbG9hZGVyJTIwJTNEJTIwRGF0YUxvYWRlcih0b2tlbml6ZWRfZGF0YXNldHMlNUIlMjJ0cmFpbiUyMiU1RCUyQyUyMGJhdGNoX3NpemUlM0QzMiUyQyUyMHNodWZmbGUlM0RUcnVlKSUwQWV2YWxfZGF0YWxvYWRlciUyMCUzRCUyMERhdGFMb2FkZXIodG9rZW5pemVkX2RhdGFzZXRzJTVCJTIydmFsaWQlMjIlNUQlMkMlMjBiYXRjaF9zaXplJTNEMzIp",highlighted:`<span class="hljs-keyword">from</span> torch.utils.data.dataloader <span class="hljs-keyword">import</span> DataLoader

tokenized_datasets.set_format(<span class="hljs-string">&quot;torch&quot;</span>)
train_dataloader = DataLoader(tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>], batch_size=<span class="hljs-number">32</span>, shuffle=<span class="hljs-literal">True</span>)
eval_dataloader = DataLoader(tokenized_datasets[<span class="hljs-string">&quot;valid&quot;</span>], batch_size=<span class="hljs-number">32</span>)`,wrap:!1}}),H=new I({props:{code:"d2VpZ2h0X2RlY2F5JTIwJTNEJTIwMC4xJTBBJTBBJTBBZGVmJTIwZ2V0X2dyb3VwZWRfcGFyYW1zKG1vZGVsJTJDJTIwbm9fZGVjYXklM0QlNUIlMjJiaWFzJTIyJTJDJTIwJTIyTGF5ZXJOb3JtLndlaWdodCUyMiU1RCklM0ElMEElMjAlMjAlMjAlMjBwYXJhbXNfd2l0aF93ZCUyQyUyMHBhcmFtc193aXRob3V0X3dkJTIwJTNEJTIwJTVCJTVEJTJDJTIwJTVCJTVEJTBBJTIwJTIwJTIwJTIwZm9yJTIwbiUyQyUyMHAlMjBpbiUyMG1vZGVsLm5hbWVkX3BhcmFtZXRlcnMoKSUzQSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmJTIwYW55KG5kJTIwaW4lMjBuJTIwZm9yJTIwbmQlMjBpbiUyMG5vX2RlY2F5KSUzQSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHBhcmFtc193aXRob3V0X3dkLmFwcGVuZChwKSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGVsc2UlM0ElMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBwYXJhbXNfd2l0aF93ZC5hcHBlbmQocCklMEElMjAlMjAlMjAlMjByZXR1cm4lMjAlNUIlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlN0IlMjJwYXJhbXMlMjIlM0ElMjBwYXJhbXNfd2l0aF93ZCUyQyUyMCUyMndlaWdodF9kZWNheSUyMiUzQSUyMHdlaWdodF9kZWNheSU3RCUyQyUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCU3QiUyMnBhcmFtcyUyMiUzQSUyMHBhcmFtc193aXRob3V0X3dkJTJDJTIwJTIyd2VpZ2h0X2RlY2F5JTIyJTNBJTIwMC4wJTdEJTJDJTBBJTIwJTIwJTIwJTIwJTVE",highlighted:`weight_decay = <span class="hljs-number">0.1</span>


<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_grouped_params</span>(<span class="hljs-params">model, no_decay=[<span class="hljs-string">&quot;bias&quot;</span>, <span class="hljs-string">&quot;LayerNorm.weight&quot;</span>]</span>):
    params_with_wd, params_without_wd = [], []
    <span class="hljs-keyword">for</span> n, p <span class="hljs-keyword">in</span> model.named_parameters():
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(nd <span class="hljs-keyword">in</span> n <span class="hljs-keyword">for</span> nd <span class="hljs-keyword">in</span> no_decay):
            params_without_wd.append(p)
        <span class="hljs-keyword">else</span>:
            params_with_wd.append(p)
    <span class="hljs-keyword">return</span> [
        {<span class="hljs-string">&quot;params&quot;</span>: params_with_wd, <span class="hljs-string">&quot;weight_decay&quot;</span>: weight_decay},
        {<span class="hljs-string">&quot;params&quot;</span>: params_without_wd, <span class="hljs-string">&quot;weight_decay&quot;</span>: <span class="hljs-number">0.0</span>},
    ]`,wrap:!1}}),S=new I({props:{code:"ZGVmJTIwZXZhbHVhdGUoKSUzQSUwQSUyMCUyMCUyMCUyMG1vZGVsLmV2YWwoKSUwQSUyMCUyMCUyMCUyMGxvc3NlcyUyMCUzRCUyMCU1QiU1RCUwQSUyMCUyMCUyMCUyMGZvciUyMHN0ZXAlMkMlMjBiYXRjaCUyMGluJTIwZW51bWVyYXRlKGV2YWxfZGF0YWxvYWRlciklM0ElMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjB3aXRoJTIwdG9yY2gubm9fZ3JhZCgpJTNBJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwb3V0cHV0cyUyMCUzRCUyMG1vZGVsKGJhdGNoJTVCJTIyaW5wdXRfaWRzJTIyJTVEJTJDJTIwbGFiZWxzJTNEYmF0Y2glNUIlMjJpbnB1dF9pZHMlMjIlNUQpJTBBJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwbG9zc2VzLmFwcGVuZChhY2NlbGVyYXRvci5nYXRoZXIob3V0cHV0cy5sb3NzKSklMEElMjAlMjAlMjAlMjBsb3NzJTIwJTNEJTIwdG9yY2gubWVhbih0b3JjaC5jYXQobG9zc2VzKSklMEElMjAlMjAlMjAlMjB0cnklM0ElMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBwZXJwbGV4aXR5JTIwJTNEJTIwdG9yY2guZXhwKGxvc3MpJTBBJTIwJTIwJTIwJTIwZXhjZXB0JTIwT3ZlcmZsb3dFcnJvciUzQSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHBlcnBsZXhpdHklMjAlM0QlMjBmbG9hdCglMjJpbmYlMjIpJTBBJTIwJTIwJTIwJTIwcmV0dXJuJTIwbG9zcy5pdGVtKCklMkMlMjBwZXJwbGV4aXR5Lml0ZW0oKQ==",highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>():
    model.<span class="hljs-built_in">eval</span>()
    losses = []
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(eval_dataloader):
        <span class="hljs-keyword">with</span> torch.no_grad():
            outputs = model(batch[<span class="hljs-string">&quot;input_ids&quot;</span>], labels=batch[<span class="hljs-string">&quot;input_ids&quot;</span>])

        losses.append(accelerator.gather(outputs.loss))
    loss = torch.mean(torch.cat(losses))
    <span class="hljs-keyword">try</span>:
        perplexity = torch.exp(loss)
    <span class="hljs-keyword">except</span> OverflowError:
        perplexity = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)
    <span class="hljs-keyword">return</span> loss.item(), perplexity.item()`,wrap:!1}}),q=new I({props:{code:"bW9kZWwlMjAlM0QlMjBHUFQyTE1IZWFkTW9kZWwoY29uZmlnKQ==",highlighted:"model = GPT2LMHeadModel(config)",wrap:!1}}),L=new I({props:{code:"ZnJvbSUyMHRvcmNoLm9wdGltJTIwaW1wb3J0JTIwQWRhbVclMEElMEFvcHRpbWl6ZXIlMjAlM0QlMjBBZGFtVyhnZXRfZ3JvdXBlZF9wYXJhbXMobW9kZWwpJTJDJTIwbHIlM0Q1ZS00KQ==",highlighted:`<span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> AdamW

optimizer = AdamW(get_grouped_params(model), lr=<span class="hljs-number">5e-4</span>)`,wrap:!1}}),P=new I({props:{code:"ZnJvbSUyMGFjY2VsZXJhdGUlMjBpbXBvcnQlMjBBY2NlbGVyYXRvciUwQSUwQWFjY2VsZXJhdG9yJTIwJTNEJTIwQWNjZWxlcmF0b3IoZnAxNiUzRFRydWUpJTBBJTBBbW9kZWwlMkMlMjBvcHRpbWl6ZXIlMkMlMjB0cmFpbl9kYXRhbG9hZGVyJTJDJTIwZXZhbF9kYXRhbG9hZGVyJTIwJTNEJTIwYWNjZWxlcmF0b3IucHJlcGFyZSglMEElMjAlMjAlMjAlMjBtb2RlbCUyQyUyMG9wdGltaXplciUyQyUyMHRyYWluX2RhdGFsb2FkZXIlMkMlMjBldmFsX2RhdGFsb2FkZXIlMEEp",highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator(fp16=<span class="hljs-literal">True</span>)

model, optimizer, train_dataloader, eval_dataloader = accelerator.prepare(
    model, optimizer, train_dataloader, eval_dataloader
)`,wrap:!1}}),O=new ct({props:{$$slots:{default:[Ga]},$$scope:{ctx:C}}}),te=new I({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMGdldF9zY2hlZHVsZXIlMEElMEFudW1fdHJhaW5fZXBvY2hzJTIwJTNEJTIwMSUwQW51bV91cGRhdGVfc3RlcHNfcGVyX2Vwb2NoJTIwJTNEJTIwbGVuKHRyYWluX2RhdGFsb2FkZXIpJTBBbnVtX3RyYWluaW5nX3N0ZXBzJTIwJTNEJTIwbnVtX3RyYWluX2Vwb2NocyUyMColMjBudW1fdXBkYXRlX3N0ZXBzX3Blcl9lcG9jaCUwQSUwQWxyX3NjaGVkdWxlciUyMCUzRCUyMGdldF9zY2hlZHVsZXIoJTBBJTIwJTIwJTIwJTIwbmFtZSUzRCUyMmxpbmVhciUyMiUyQyUwQSUyMCUyMCUyMCUyMG9wdGltaXplciUzRG9wdGltaXplciUyQyUwQSUyMCUyMCUyMCUyMG51bV93YXJtdXBfc3RlcHMlM0QxXzAwMCUyQyUwQSUyMCUyMCUyMCUyMG51bV90cmFpbmluZ19zdGVwcyUzRG51bV90cmFpbmluZ19zdGVwcyUyQyUwQSk=",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> get_scheduler

num_train_epochs = <span class="hljs-number">1</span>
num_update_steps_per_epoch = <span class="hljs-built_in">len</span>(train_dataloader)
num_training_steps = num_train_epochs * num_update_steps_per_epoch

lr_scheduler = get_scheduler(
    name=<span class="hljs-string">&quot;linear&quot;</span>,
    optimizer=optimizer,
    num_warmup_steps=<span class="hljs-number">1_000</span>,
    num_training_steps=num_training_steps,
)`,wrap:!1}}),se=new I({props:{code:"ZnJvbSUyMGh1Z2dpbmdmYWNlX2h1YiUyMGltcG9ydCUyMFJlcG9zaXRvcnklMkMlMjBnZXRfZnVsbF9yZXBvX25hbWUlMEElMEFtb2RlbF9uYW1lJTIwJTNEJTIwJTIyY29kZXBhcnJvdC1kcy1hY2NlbGVyYXRlJTIyJTBBcmVwb19uYW1lJTIwJTNEJTIwZ2V0X2Z1bGxfcmVwb19uYW1lKG1vZGVsX25hbWUpJTBBcmVwb19uYW1l",highlighted:`<span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> Repository, get_full_repo_name

model_name = <span class="hljs-string">&quot;codeparrot-ds-accelerate&quot;</span>
repo_name = get_full_repo_name(model_name)
repo_name`,wrap:!1}}),z=new I({props:{code:"J3NndWdnZXIlMkZjb2RlcGFycm90LWRzLWFjY2VsZXJhdGUn",highlighted:'<span class="hljs-string">&#x27;sgugger/codeparrot-ds-accelerate&#x27;</span>',wrap:!1}}),ae=new I({props:{code:"b3V0cHV0X2RpciUyMCUzRCUyMCUyMmNvZGVwYXJyb3QtZHMtYWNjZWxlcmF0ZSUyMiUwQXJlcG8lMjAlM0QlMjBSZXBvc2l0b3J5KG91dHB1dF9kaXIlMkMlMjBjbG9uZV9mcm9tJTNEcmVwb19uYW1lKQ==",highlighted:`output_dir = <span class="hljs-string">&quot;codeparrot-ds-accelerate&quot;</span>
repo = Repository(output_dir, clone_from=repo_name)`,wrap:!1}}),ye=new I({props:{code:"ZXZhbHVhdGUoKQ==",highlighted:"evaluate()",wrap:!1}}),me=new I({props:{code:"KDEwLjkzNDEyNjg1Mzk0Mjg3MSUyQyUyMDU2MDU3LjE0NDUzMTI1KQ==",highlighted:'(<span class="hljs-number">10.934126853942871</span>, <span class="hljs-number">56057.14453125</span>)',wrap:!1}}),Re=new I({props:{code:"ZnJvbSUyMHRxZG0ubm90ZWJvb2slMjBpbXBvcnQlMjB0cWRtJTBBJTBBZ3JhZGllbnRfYWNjdW11bGF0aW9uX3N0ZXBzJTIwJTNEJTIwOCUwQWV2YWxfc3RlcHMlMjAlM0QlMjA1XzAwMCUwQSUwQW1vZGVsLnRyYWluKCklMEFjb21wbGV0ZWRfc3RlcHMlMjAlM0QlMjAwJTBBZm9yJTIwZXBvY2glMjBpbiUyMHJhbmdlKG51bV90cmFpbl9lcG9jaHMpJTNBJTBBJTIwJTIwJTIwJTIwZm9yJTIwc3RlcCUyQyUyMGJhdGNoJTIwaW4lMjB0cWRtKCUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGVudW1lcmF0ZSh0cmFpbl9kYXRhbG9hZGVyJTJDJTIwc3RhcnQlM0QxKSUyQyUyMHRvdGFsJTNEbnVtX3RyYWluaW5nX3N0ZXBzJTBBJTIwJTIwJTIwJTIwKSUzQSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGxvZ2l0cyUyMCUzRCUyMG1vZGVsKGJhdGNoJTVCJTIyaW5wdXRfaWRzJTIyJTVEKS5sb2dpdHMlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBsb3NzJTIwJTNEJTIwa2V5dG9rZW5fd2VpZ2h0ZWRfbG9zcyhiYXRjaCU1QiUyMmlucHV0X2lkcyUyMiU1RCUyQyUyMGxvZ2l0cyUyQyUyMGtleXRva2VuX2lkcyklMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpZiUyMHN0ZXAlMjAlMjUlMjAxMDAlMjAlM0QlM0QlMjAwJTNBJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwYWNjZWxlcmF0b3IucHJpbnQoJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTdCJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIyc2FtcGxlcyUyMiUzQSUyMHN0ZXAlMjAqJTIwc2FtcGxlc19wZXJfc3RlcCUyQyUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMnN0ZXBzJTIyJTNBJTIwY29tcGxldGVkX3N0ZXBzJTJDJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIybG9zcyUyRnRyYWluJTIyJTNBJTIwbG9zcy5pdGVtKCklMjAqJTIwZ3JhZGllbnRfYWNjdW11bGF0aW9uX3N0ZXBzJTJDJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTdEJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwKSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGxvc3MlMjAlM0QlMjBsb3NzJTIwJTJGJTIwZ3JhZGllbnRfYWNjdW11bGF0aW9uX3N0ZXBzJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwYWNjZWxlcmF0b3IuYmFja3dhcmQobG9zcyklMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpZiUyMHN0ZXAlMjAlMjUlMjBncmFkaWVudF9hY2N1bXVsYXRpb25fc3RlcHMlMjAlM0QlM0QlMjAwJTNBJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwYWNjZWxlcmF0b3IuY2xpcF9ncmFkX25vcm1fKG1vZGVsLnBhcmFtZXRlcnMoKSUyQyUyMDEuMCklMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBvcHRpbWl6ZXIuc3RlcCgpJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwbHJfc2NoZWR1bGVyLnN0ZXAoKSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMG9wdGltaXplci56ZXJvX2dyYWQoKSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGNvbXBsZXRlZF9zdGVwcyUyMCUyQiUzRCUyMDElMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBpZiUyMChzdGVwJTIwJTI1JTIwKGV2YWxfc3RlcHMlMjAqJTIwZ3JhZGllbnRfYWNjdW11bGF0aW9uX3N0ZXBzKSklMjAlM0QlM0QlMjAwJTNBJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwZXZhbF9sb3NzJTJDJTIwcGVycGxleGl0eSUyMCUzRCUyMGV2YWx1YXRlKCklMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBhY2NlbGVyYXRvci5wcmludCglN0IlMjJsb3NzJTJGZXZhbCUyMiUzQSUyMGV2YWxfbG9zcyUyQyUyMCUyMnBlcnBsZXhpdHklMjIlM0ElMjBwZXJwbGV4aXR5JTdEKSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMG1vZGVsLnRyYWluKCklMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBhY2NlbGVyYXRvci53YWl0X2Zvcl9ldmVyeW9uZSgpJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwdW53cmFwcGVkX21vZGVsJTIwJTNEJTIwYWNjZWxlcmF0b3IudW53cmFwX21vZGVsKG1vZGVsKSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHVud3JhcHBlZF9tb2RlbC5zYXZlX3ByZXRyYWluZWQob3V0cHV0X2RpciUyQyUyMHNhdmVfZnVuY3Rpb24lM0RhY2NlbGVyYXRvci5zYXZlKSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmJTIwYWNjZWxlcmF0b3IuaXNfbWFpbl9wcm9jZXNzJTNBJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwdG9rZW5pemVyLnNhdmVfcHJldHJhaW5lZChvdXRwdXRfZGlyKSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHJlcG8ucHVzaF90b19odWIoJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwY29tbWl0X21lc3NhZ2UlM0RmJTIyVHJhaW5pbmclMjBpbiUyMHByb2dyZXNzJTIwc3RlcCUyMCU3QnN0ZXAlN0QlMjIlMkMlMjBibG9ja2luZyUzREZhbHNlJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwKQ==",highlighted:`<span class="hljs-keyword">from</span> tqdm.notebook <span class="hljs-keyword">import</span> tqdm

gradient_accumulation_steps = <span class="hljs-number">8</span>
eval_steps = <span class="hljs-number">5_000</span>

model.train()
completed_steps = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_train_epochs):
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> tqdm(
        <span class="hljs-built_in">enumerate</span>(train_dataloader, start=<span class="hljs-number">1</span>), total=num_training_steps
    ):
        logits = model(batch[<span class="hljs-string">&quot;input_ids&quot;</span>]).logits
        loss = keytoken_weighted_loss(batch[<span class="hljs-string">&quot;input_ids&quot;</span>], logits, keytoken_ids)
        <span class="hljs-keyword">if</span> step % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:
            accelerator.<span class="hljs-built_in">print</span>(
                {
                    <span class="hljs-string">&quot;samples&quot;</span>: step * samples_per_step,
                    <span class="hljs-string">&quot;steps&quot;</span>: completed_steps,
                    <span class="hljs-string">&quot;loss/train&quot;</span>: loss.item() * gradient_accumulation_steps,
                }
            )
        loss = loss / gradient_accumulation_steps
        accelerator.backward(loss)
        <span class="hljs-keyword">if</span> step % gradient_accumulation_steps == <span class="hljs-number">0</span>:
            accelerator.clip_grad_norm_(model.parameters(), <span class="hljs-number">1.0</span>)
            optimizer.step()
            lr_scheduler.step()
            optimizer.zero_grad()
            completed_steps += <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> (step % (eval_steps * gradient_accumulation_steps)) == <span class="hljs-number">0</span>:
            eval_loss, perplexity = evaluate()
            accelerator.<span class="hljs-built_in">print</span>({<span class="hljs-string">&quot;loss/eval&quot;</span>: eval_loss, <span class="hljs-string">&quot;perplexity&quot;</span>: perplexity})
            model.train()
            accelerator.wait_for_everyone()
            unwrapped_model = accelerator.unwrap_model(model)
            unwrapped_model.save_pretrained(output_dir, save_function=accelerator.save)
            <span class="hljs-keyword">if</span> accelerator.is_main_process:
                tokenizer.save_pretrained(output_dir)
                repo.push_to_hub(
                    commit_message=<span class="hljs-string">f&quot;Training in progress step <span class="hljs-subst">{step}</span>&quot;</span>, blocking=<span class="hljs-literal">False</span>
                )`,wrap:!1}}),oe=new ct({props:{$$slots:{default:[Ba]},$$scope:{ctx:C}}}),de=new ct({props:{$$slots:{default:[Xa]},$$scope:{ctx:C}}}),{c(){u(l.$$.fragment),r=i(),n=T("p"),n.innerHTML=y,g=i(),u(j.$$.fragment),$=i(),Z=T("p"),Z.innerHTML=k,m=i(),u(b.$$.fragment),G=i(),u(V.$$.fragment),Q=i(),R=T("p"),R.textContent=_,B=i(),u(x.$$.fragment),ve=i(),E=T("p"),E.textContent=ws,Qe=i(),X=T("ul"),X.innerHTML=ms,ze=i(),A=T("p"),A.innerHTML=us,Ne=i(),u(F.$$.fragment),Ve=i(),Y=T("p"),Y.textContent=hs,xe=i(),u(H.$$.fragment),yt=i(),ie=T("p"),ie.textContent=Ze,Ee=i(),u(S.$$.fragment),wt=i(),pe=T("p"),pe.innerHTML=$e,Ae=i(),u(q.$$.fragment),Fe=i(),D=T("p"),D.textContent=ds,Ye=i(),u(L.$$.fragment),He=i(),K=T("p"),K.textContent=Js,Se=i(),u(P.$$.fragment),qe=i(),u(O.$$.fragment),De=i(),ee=T("p"),ee.innerHTML=Ts,Le=i(),u(te.$$.fragment),mt=i(),re=T("p"),re.innerHTML=Ge,Ke=i(),u(se.$$.fragment),Pe=i(),u(z.$$.fragment),Oe=i(),le=T("p"),le.textContent=Us,et=i(),u(ae.$$.fragment),tt=i(),ne=T("p"),ne.innerHTML=ut,Me=i(),Be=T("p"),Be.textContent=ht,ce=i(),u(ye.$$.fragment),we=i(),u(me.$$.fragment),ue=i(),Xe=T("p"),Xe.innerHTML=dt,he=i(),u(Re.$$.fragment),st=i(),N=T("p"),N.textContent=fs,lt=i(),u(oe.$$.fragment),Jt=i(),u(de.$$.fragment)},l(t){h(l.$$.fragment,t),r=p(t),n=U(t,"P",{"data-svelte-h":!0}),f(n)!=="svelte-qf6luh"&&(n.innerHTML=y),g=p(t),h(j.$$.fragment,t),$=p(t),Z=U(t,"P",{"data-svelte-h":!0}),f(Z)!=="svelte-dv4zfi"&&(Z.innerHTML=k),m=p(t),h(b.$$.fragment,t),G=p(t),h(V.$$.fragment,t),Q=p(t),R=U(t,"P",{"data-svelte-h":!0}),f(R)!=="svelte-1xv4c43"&&(R.textContent=_),B=p(t),h(x.$$.fragment,t),ve=p(t),E=U(t,"P",{"data-svelte-h":!0}),f(E)!=="svelte-1gmwrn7"&&(E.textContent=ws),Qe=p(t),X=U(t,"UL",{"data-svelte-h":!0}),f(X)!=="svelte-zoq68e"&&(X.innerHTML=ms),ze=p(t),A=U(t,"P",{"data-svelte-h":!0}),f(A)!=="svelte-qghkub"&&(A.innerHTML=us),Ne=p(t),h(F.$$.fragment,t),Ve=p(t),Y=U(t,"P",{"data-svelte-h":!0}),f(Y)!=="svelte-asmh6m"&&(Y.textContent=hs),xe=p(t),h(H.$$.fragment,t),yt=p(t),ie=U(t,"P",{"data-svelte-h":!0}),f(ie)!=="svelte-ig8se8"&&(ie.textContent=Ze),Ee=p(t),h(S.$$.fragment,t),wt=p(t),pe=U(t,"P",{"data-svelte-h":!0}),f(pe)!=="svelte-11o4vzt"&&(pe.innerHTML=$e),Ae=p(t),h(q.$$.fragment,t),Fe=p(t),D=U(t,"P",{"data-svelte-h":!0}),f(D)!=="svelte-1n65zke"&&(D.textContent=ds),Ye=p(t),h(L.$$.fragment,t),He=p(t),K=U(t,"P",{"data-svelte-h":!0}),f(K)!=="svelte-yqp0m0"&&(K.textContent=Js),Se=p(t),h(P.$$.fragment,t),qe=p(t),h(O.$$.fragment,t),De=p(t),ee=U(t,"P",{"data-svelte-h":!0}),f(ee)!=="svelte-1409oc7"&&(ee.innerHTML=Ts),Le=p(t),h(te.$$.fragment,t),mt=p(t),re=U(t,"P",{"data-svelte-h":!0}),f(re)!=="svelte-ppazi4"&&(re.innerHTML=Ge),Ke=p(t),h(se.$$.fragment,t),Pe=p(t),h(z.$$.fragment,t),Oe=p(t),le=U(t,"P",{"data-svelte-h":!0}),f(le)!=="svelte-lt5x8r"&&(le.textContent=Us),et=p(t),h(ae.$$.fragment,t),tt=p(t),ne=U(t,"P",{"data-svelte-h":!0}),f(ne)!=="svelte-1mcbsiy"&&(ne.innerHTML=ut),Me=p(t),Be=U(t,"P",{"data-svelte-h":!0}),f(Be)!=="svelte-983pzc"&&(Be.textContent=ht),ce=p(t),h(ye.$$.fragment,t),we=p(t),h(me.$$.fragment,t),ue=p(t),Xe=U(t,"P",{"data-svelte-h":!0}),f(Xe)!=="svelte-9b8c5q"&&(Xe.innerHTML=dt),he=p(t),h(Re.$$.fragment,t),st=p(t),N=U(t,"P",{"data-svelte-h":!0}),f(N)!=="svelte-1sn049p"&&(N.textContent=fs),lt=p(t),h(oe.$$.fragment,t),Jt=p(t),h(de.$$.fragment,t)},m(t,w){d(l,t,w),a(t,r,w),a(t,n,w),a(t,g,w),d(j,t,w),a(t,$,w),a(t,Z,w),a(t,m,w),d(b,t,w),a(t,G,w),d(V,t,w),a(t,Q,w),a(t,R,w),a(t,B,w),d(x,t,w),a(t,ve,w),a(t,E,w),a(t,Qe,w),a(t,X,w),a(t,ze,w),a(t,A,w),a(t,Ne,w),d(F,t,w),a(t,Ve,w),a(t,Y,w),a(t,xe,w),d(H,t,w),a(t,yt,w),a(t,ie,w),a(t,Ee,w),d(S,t,w),a(t,wt,w),a(t,pe,w),a(t,Ae,w),d(q,t,w),a(t,Fe,w),a(t,D,w),a(t,Ye,w),d(L,t,w),a(t,He,w),a(t,K,w),a(t,Se,w),d(P,t,w),a(t,qe,w),d(O,t,w),a(t,De,w),a(t,ee,w),a(t,Le,w),d(te,t,w),a(t,mt,w),a(t,re,w),a(t,Ke,w),d(se,t,w),a(t,Pe,w),d(z,t,w),a(t,Oe,w),a(t,le,w),a(t,et,w),d(ae,t,w),a(t,tt,w),a(t,ne,w),a(t,Me,w),a(t,Be,w),a(t,ce,w),d(ye,t,w),a(t,we,w),d(me,t,w),a(t,ue,w),a(t,Xe,w),a(t,he,w),d(Re,t,w),a(t,st,w),a(t,N,w),a(t,lt,w),d(oe,t,w),a(t,Jt,w),d(de,t,w),Je=!0},i(t){Je||(M(l.$$.fragment,t),M(j.$$.fragment,t),M(b.$$.fragment,t),M(V.$$.fragment,t),M(x.$$.fragment,t),M(F.$$.fragment,t),M(H.$$.fragment,t),M(S.$$.fragment,t),M(q.$$.fragment,t),M(L.$$.fragment,t),M(P.$$.fragment,t),M(O.$$.fragment,t),M(te.$$.fragment,t),M(se.$$.fragment,t),M(z.$$.fragment,t),M(ae.$$.fragment,t),M(ye.$$.fragment,t),M(me.$$.fragment,t),M(Re.$$.fragment,t),M(oe.$$.fragment,t),M(de.$$.fragment,t),Je=!0)},o(t){c(l.$$.fragment,t),c(j.$$.fragment,t),c(b.$$.fragment,t),c(V.$$.fragment,t),c(x.$$.fragment,t),c(F.$$.fragment,t),c(H.$$.fragment,t),c(S.$$.fragment,t),c(q.$$.fragment,t),c(L.$$.fragment,t),c(P.$$.fragment,t),c(O.$$.fragment,t),c(te.$$.fragment,t),c(se.$$.fragment,t),c(z.$$.fragment,t),c(ae.$$.fragment,t),c(ye.$$.fragment,t),c(me.$$.fragment,t),c(Re.$$.fragment,t),c(oe.$$.fragment,t),c(de.$$.fragment,t),Je=!1},d(t){t&&(s(r),s(n),s(g),s($),s(Z),s(m),s(G),s(Q),s(R),s(B),s(ve),s(E),s(Qe),s(X),s(ze),s(A),s(Ne),s(Ve),s(Y),s(xe),s(yt),s(ie),s(Ee),s(wt),s(pe),s(Ae),s(Fe),s(D),s(Ye),s(He),s(K),s(Se),s(qe),s(De),s(ee),s(Le),s(mt),s(re),s(Ke),s(Pe),s(Oe),s(le),s(et),s(tt),s(ne),s(Me),s(Be),s(ce),s(we),s(ue),s(Xe),s(he),s(st),s(N),s(lt),s(Jt)),J(l,t),J(j,t),J(b,t),J(V,t),J(x,t),J(F,t),J(H,t),J(S,t),J(q,t),J(L,t),J(P,t),J(O,t),J(te,t),J(se,t),J(z,t),J(ae,t),J(ye,t),J(me,t),J(Re,t),J(oe,t),J(de,t)}}}function Ga(C){let l,r='üö® If you‚Äôre training on a TPU, you‚Äôll need to move all the code starting at the cell above into a dedicated training function. See <a href="/course/chapter3">Chapter 3</a> for more details.';return{c(){l=T("p"),l.innerHTML=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-185qbwt"&&(l.innerHTML=r)},m(n,y){a(n,l,y)},p:ls,d(n){n&&s(l)}}}function Ba(C){let l,r="‚úèÔ∏è <strong>Try it out!</strong> Either create your own custom loss function tailored to your use case, or add another custom step into the training loop.";return{c(){l=T("p"),l.innerHTML=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-mw9suu"&&(l.innerHTML=r)},m(n,y){a(n,l,y)},p:ls,d(n){n&&s(l)}}}function Xa(C){let l,r="‚úèÔ∏è <strong>Try it out!</strong> When running long training experiments it‚Äôs a good idea to log important metrics using tools such as TensorBoard or Weights &amp; Biases. Add proper logging to the training loop so you can always check how the training is going.";return{c(){l=T("p"),l.innerHTML=r},l(n){l=U(n,"P",{"data-svelte-h":!0}),f(l)!=="svelte-gp1epm"&&(l.innerHTML=r)},m(n,y){a(n,l,y)},p:ls,d(n){n&&s(l)}}}function Ra(C){let l,r,n,y,g,j,$,Z,k,m,b,G,V='Up until now, we‚Äôve mostly been using pretrained models and fine-tuning them for new use cases by reusing the weights from pretraining. As we saw in <a href="/course/chapter1">Chapter 1</a>, this is commonly referred to as <em>transfer learning</em>, and it‚Äôs a very successful strategy for applying Transformer models to most real-world use cases where labeled data is sparse. In this chapter, we‚Äôll take a different approach and train a completely new model from scratch. This is a good approach to take if you have a lot of data and it is very different from the pretraining data used for the available models. However, it also requires considerably more compute resources to pretrain a language model than just to fine-tune an existing one. Examples where it can make sense to train a new model include for datasets consisting of musical notes, molecular sequences such as DNA, or programming languages. The latter have recently gained traction thanks to tools such as TabNine and GitHub‚Äôs Copilot, powered by OpenAI‚Äôs Codex model, that can generate long sequences of code. This task of text generation is best addressed with auto-regressive or causal language models such as GPT-2.',Q,R,_="In this section we will build a scaled-down version of a code generation model: we‚Äôll focus on one-line completions instead of full functions or classes, using a subset of Python code. When working with data in Python you are in frequent contact with the Python data science stack, consisting of the <code>matplotlib</code>, <code>seaborn</code>, <code>pandas</code>, and <code>scikit-learn</code> libraries. When using those frameworks it‚Äôs common to need to look up specific commands, so it would be nice if we could use a model to complete these calls for us.",B,x,ve,E,ws='In <a href="/course/chapter6">Chapter 6</a> we created an efficient tokenizer to process Python source code, but what we still need is a large-scale dataset to pretrain a model on. Here, we‚Äôll apply our tokenizer to a corpus of Python code derived from GitHub repositories. We will then use the <code>Trainer</code> API and ü§ó Accelerate to train the model. Let‚Äôs get to it!',Qe,X,ms,ze,A,us='This is actually showcasing the model that was trained and uploaded to the Hub using the code shown in this section. You can find it <a href="https://huggingface.co/huggingface-course/codeparrot-ds?text=plt.imshow%28" rel="nofollow">here</a>. Note that since there is some randomization happening in the text generation, you will probably get a slightly different result.',Ne,F,Ve,Y,hs='Python code is abundantly available from code repositories such as GitHub, which we can use to create a dataset by scraping for every Python repository. This was the approach taken in the <a href="https://learning.oreilly.com/library/view/natural-language-processing/9781098136789/" rel="nofollow">Transformers textbook</a> to pretrain a large GPT-2 model. Using a GitHub dump of about 180 GB containing roughly 20 million Python files called <code>codeparrot</code>, the authors built a dataset that they then shared on the <a href="https://huggingface.co/datasets/transformersbook/codeparrot" rel="nofollow">Hugging Face Hub</a>.',xe,H,yt="However, training on the full corpus is time- and compute-consuming, and we only need the subset of the dataset concerned with the Python data science stack. So, let‚Äôs start by filtering the <code>codeparrot</code> dataset for all files that include any of the libraries in this stack. Because of the dataset‚Äôs size, we want to avoid downloading it; instead, we‚Äôll use the streaming feature to filter it on the fly. To help us filter the code samples using the libraries we mentioned earlier, we‚Äôll use the following function:",ie,Ze,Ee,S,wt="Let‚Äôs test it on two examples:",pe,$e,Ae,q,Fe,D,ds="We can use this to create a function that will stream the dataset and filter the elements we want:",Ye,L,He,K,Js="Then we can simply apply this function to the streaming dataset:",Se,P,qe,O,De,ee,Ts="This leaves us with about 3% of the original dataset, which is still quite sizable ‚Äî the resulting dataset is 6 GB and consists of 600,000 Python scripts!",Le,te,mt="Filtering the full dataset can take 2-3h depending on your machine and bandwidth. If you don‚Äôt want to go through this lengthy process yourself, we provide the filtered dataset on the Hub for you to download:",re,Ge,Ke,se,Pe,z,Oe,le,Us="Let‚Äôs look at an example from the dataset. We‚Äôll just show the first 200 characters of each field:",et,ae,tt,ne,ut,Me,Be="We can see that the <code>content</code> field contains the code that we want our model to train on. Now that we have a dataset, we need to prepare the texts so they‚Äôre in a format suitable for pretraining.",ht,ce,ye,we,me,ue,Xe="The first step will be to tokenize the data, so we can use it for training. Since our goal is to mainly autocomplete short function calls, we can keep the context size relatively small. This has the benefit that we can train the model much faster and it requires significantly less memory. If it is important for your application to have more context (for example, if you want the model to write unit tests based on a file with the function definition), make sure you increase that number, but also keep in mind that this comes with a greater GPU memory footprint. For now, let‚Äôs fix the context size at 128 tokens, as opposed to the 1,024 or 2,048 used in GPT-2 or GPT-3, respectively.",dt,he,Re='Most documents contain many more than 128 tokens, so simply truncating the inputs to the maximum length would eliminate a large fraction of our dataset. Instead, we‚Äôll use the <code>return_overflowing_tokens</code> option to tokenize the whole input and split it into several chunks, as we did in <a href="/course/chapter6/4">Chapter 6</a>. We‚Äôll also use the <code>return_length</code> option to return the length of each created chunk automatically. Often the last chunk will be smaller than the context size, and we‚Äôll get rid of these pieces to avoid padding issues; we don‚Äôt really need them as we have plenty of data anyway.',st,N,fs='<img class="block dark:hidden" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/chunking_texts.svg" alt="Chunking a large texts in several pieces."/> <img class="hidden dark:block" src="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter7/chunking_texts-dark.svg" alt="Chunking a large texts in several pieces."/>',lt,oe,Jt="Let‚Äôs see exactly how this works by looking at the first two examples:",de,Je,t,w,bs,Tt,hl="We can see that we get 34 segments in total from those two examples. Looking at the chunk lengths, we can see that the chunks at the ends of both documents have less than 128 tokens (117 and 41, respectively). These represent just a small fraction of the total chunks that we have, so we can safely throw them away. With the <code>overflow_to_sample_mapping</code> field, we can also reconstruct which chunks belonged to which input samples.",Is,Ut,dl='With this operation we‚Äôre using a handy feature of the <code>Dataset.map()</code> function in ü§ó Datasets, which is that it does not require one-to-one maps; as we saw in <a href="/course/chapter7/3">section 3</a>, we can create batches with more or fewer elements than the input batch. This is useful when doing operations like data augmentation or data filtering that change the number of elements. In our case, when tokenizing each element into chunks of the specified context size, we create many samples from each document. We just need to make sure to delete the existing columns, since they have a conflicting size. If we wanted to keep them, we could repeat them appropriately and return them within the <code>Dataset.map()</code> call:',Cs,ft,gs,jt,_s,bt,Jl="We now have 16.7 million examples with 128 tokens each, which corresponds to about 2.1 billion tokens in total. For reference, OpenAI‚Äôs GPT-3 and Codex models are trained on 300 and 100 billion tokens, respectively, where the Codex models are initialized from the GPT-3 checkpoints. Our goal in this section is not to compete with these models, which can generate long, coherent texts, but to create a scaled-down version providing a quick autocomplete function for data scientists.",ks,It,Tl="Now that we have the dataset ready, let‚Äôs set up the model!",Zs,nt,$s,Ct,Gs,gt,Ul="Our first step is to freshly initialize a GPT-2 model. We‚Äôll use the same configuration for our model as for the small GPT-2 model, so we load the pretrained configuration, make sure that the tokenizer size matches the model vocabulary size and pass the <code>bos</code> and <code>eos</code> (beginning and end of sequence) token IDs:",Bs,Te,Ue,as,_t,fl="Our model has 124M parameters that we‚Äôll have to tune. Before we can start training, we need to set up a data collator that will take care of creating the batches. We can use the <code>DataCollatorForLanguageModeling</code> collator, which is designed specifically for language modeling (as the name subtly suggests). Besides stacking and padding batches, it also takes care of creating the language model labels ‚Äî in causal language modeling the inputs serve as labels too (just shifted by one element), and this data collator creates them on the fly during training so we don‚Äôt need to duplicate the <code>input_ids</code>.",Xs,kt,jl="Note that <code>DataCollatorForLanguageModeling</code> supports both masked language modeling (MLM) and causal language modeling (CLM). By default it prepares data for MLM, but we can switch to CLM by setting the argument <code>mlm=False</code>:",Rs,fe,je,ns,Zt,bl="Let‚Äôs have a look at an example:",Ws,$t,vs,be,Ie,os,Gt,Il="We can see that the examples have been stacked and all the tensors have the same shape.",Qs,is,ot,zs,Bt,Cl="Now we have everything in place to actually train our model ‚Äî that wasn‚Äôt so much work after all! Before we start training we should log in to Hugging Face. If you‚Äôre working in a notebook, you can do so with the following utility function:",Ns,Xt,Vs,Rt,gl="This will display a widget where you can enter your Hugging Face login credentials.",xs,Wt,_l="If you aren‚Äôt working in a notebook, just type the following line in your terminal:",Es,vt,As,Ce,ge,ps,it,Fs,pt,Ys,Qt,Hs,zt,kl="Now is the moment of truth: let‚Äôs see how well the trained model actually works! We can see in the logs that the loss went down steadily, but to put the model to the test let‚Äôs take a look at how well it works on some prompts. To do that we‚Äôll wrap the model in a text generation <code>pipeline</code>, and we‚Äôll put it on the GPU for fast generations if there is one available:",Ss,_e,ke,rs,Nt,Zl="Let‚Äôs start with the simple task of creating a scatter plot:",qs,Vt,Ds,xt,Ls,Et,$l="The result looks correct. Does it also work for a <code>pandas</code> operation? Let‚Äôs see if we can create a <code>DataFrame</code> from two arrays:",Ks,At,Ps,Ft,Os,Yt,Gl="Nice, that‚Äôs the correct answer ‚Äî although it then inserts the column <code>x</code> again. Since the number of generated tokens is limited, the following <code>for</code> loop is cut off. Let‚Äôs see if we can do something a bit more complex and have the model help us use the <code>groupby</code> operation:",el,Ht,tl,St,sl,qt,Bl="Not bad; that‚Äôs the right way to do it. Finally, let‚Äôs see if we can also use it for <code>scikit-learn</code> and set up a Random Forest model:",ll,Dt,al,Lt,nl,Ms,cs,js,ol;g=new ra({props:{fw:C[0]}}),$=new ys({props:{title:"Training a causal language model from scratch",local:"training-a-causal-language-model-from-scratch",headingTag:"h1"}});const Xl=[ca,Ma],Kt=[];function Rl(e,o){return e[0]==="pt"?0:1}k=Rl(C),m=Kt[k]=Xl[k](C),x=new ul({props:{id:"Vpjb1lu0MDk"}}),F=new ys({props:{title:"Gathering the data",local:"gathering-the-data",headingTag:"h2"}}),Ze=new I({props:{code:"ZGVmJTIwYW55X2tleXdvcmRfaW5fc3RyaW5nKHN0cmluZyUyQyUyMGtleXdvcmRzKSUzQSUwQSUyMCUyMCUyMCUyMGZvciUyMGtleXdvcmQlMjBpbiUyMGtleXdvcmRzJTNBJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwaWYlMjBrZXl3b3JkJTIwaW4lMjBzdHJpbmclM0ElMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjByZXR1cm4lMjBUcnVlJTBBJTIwJTIwJTIwJTIwcmV0dXJuJTIwRmFsc2U=",highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">any_keyword_in_string</span>(<span class="hljs-params">string, keywords</span>):
    <span class="hljs-keyword">for</span> keyword <span class="hljs-keyword">in</span> keywords:
        <span class="hljs-keyword">if</span> keyword <span class="hljs-keyword">in</span> string:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>`,wrap:!1}}),$e=new I({props:{code:"ZmlsdGVycyUyMCUzRCUyMCU1QiUyMnBhbmRhcyUyMiUyQyUyMCUyMnNrbGVhcm4lMjIlMkMlMjAlMjJtYXRwbG90bGliJTIyJTJDJTIwJTIyc2VhYm9ybiUyMiU1RCUwQWV4YW1wbGVfMSUyMCUzRCUyMCUyMmltcG9ydCUyMG51bXB5JTIwYXMlMjBucCUyMiUwQWV4YW1wbGVfMiUyMCUzRCUyMCUyMmltcG9ydCUyMHBhbmRhcyUyMGFzJTIwcGQlMjIlMEElMEFwcmludCglMEElMjAlMjAlMjAlMjBhbnlfa2V5d29yZF9pbl9zdHJpbmcoZXhhbXBsZV8xJTJDJTIwZmlsdGVycyklMkMlMjBhbnlfa2V5d29yZF9pbl9zdHJpbmcoZXhhbXBsZV8yJTJDJTIwZmlsdGVycyklMEEp",highlighted:`filters = [<span class="hljs-string">&quot;pandas&quot;</span>, <span class="hljs-string">&quot;sklearn&quot;</span>, <span class="hljs-string">&quot;matplotlib&quot;</span>, <span class="hljs-string">&quot;seaborn&quot;</span>]
example_1 = <span class="hljs-string">&quot;import numpy as np&quot;</span>
example_2 = <span class="hljs-string">&quot;import pandas as pd&quot;</span>

<span class="hljs-built_in">print</span>(
    any_keyword_in_string(example_1, filters), any_keyword_in_string(example_2, filters)
)`,wrap:!1}}),q=new I({props:{code:"RmFsc2UlMjBUcnVl",highlighted:'<span class="hljs-literal">False</span> <span class="hljs-literal">True</span>',wrap:!1}}),L=new I({props:{code:"ZnJvbSUyMGNvbGxlY3Rpb25zJTIwaW1wb3J0JTIwZGVmYXVsdGRpY3QlMEFmcm9tJTIwdHFkbSUyMGltcG9ydCUyMHRxZG0lMEFmcm9tJTIwZGF0YXNldHMlMjBpbXBvcnQlMjBEYXRhc2V0JTBBJTBBJTBBZGVmJTIwZmlsdGVyX3N0cmVhbWluZ19kYXRhc2V0KGRhdGFzZXQlMkMlMjBmaWx0ZXJzKSUzQSUwQSUyMCUyMCUyMCUyMGZpbHRlcmVkX2RpY3QlMjAlM0QlMjBkZWZhdWx0ZGljdChsaXN0KSUwQSUyMCUyMCUyMCUyMHRvdGFsJTIwJTNEJTIwMCUwQSUyMCUyMCUyMCUyMGZvciUyMHNhbXBsZSUyMGluJTIwdHFkbShpdGVyKGRhdGFzZXQpKSUzQSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHRvdGFsJTIwJTJCJTNEJTIwMSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlmJTIwYW55X2tleXdvcmRfaW5fc3RyaW5nKHNhbXBsZSU1QiUyMmNvbnRlbnQlMjIlNUQlMkMlMjBmaWx0ZXJzKSUzQSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGZvciUyMGslMkMlMjB2JTIwaW4lMjBzYW1wbGUuaXRlbXMoKSUzQSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGZpbHRlcmVkX2RpY3QlNUJrJTVELmFwcGVuZCh2KSUwQSUyMCUyMCUyMCUyMHByaW50KGYlMjIlN0JsZW4oZmlsdGVyZWRfZGljdCU1Qidjb250ZW50JyU1RCklMkZ0b3RhbCUzQS4yJTI1JTdEJTIwb2YlMjBkYXRhJTIwYWZ0ZXIlMjBmaWx0ZXJpbmcuJTIyKSUwQSUyMCUyMCUyMCUyMHJldHVybiUyMERhdGFzZXQuZnJvbV9kaWN0KGZpbHRlcmVkX2RpY3Qp",highlighted:`<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict
<span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm
<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> Dataset


<span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_streaming_dataset</span>(<span class="hljs-params">dataset, filters</span>):
    filtered_dict = defaultdict(<span class="hljs-built_in">list</span>)
    total = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> sample <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">iter</span>(dataset)):
        total += <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> any_keyword_in_string(sample[<span class="hljs-string">&quot;content&quot;</span>], filters):
            <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> sample.items():
                filtered_dict[k].append(v)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">{<span class="hljs-built_in">len</span>(filtered_dict[<span class="hljs-string">&#x27;content&#x27;</span>])/total:<span class="hljs-number">.2</span>%}</span> of data after filtering.&quot;</span>)
    <span class="hljs-keyword">return</span> Dataset.from_dict(filtered_dict)`,wrap:!1}}),P=new I({props:{code:"JTIzJTIwVGhpcyUyMGNlbGwlMjB3aWxsJTIwdGFrZSUyMGElMjB2ZXJ5JTIwbG9uZyUyMHRpbWUlMjB0byUyMGV4ZWN1dGUlMkMlMjBzbyUyMHlvdSUyMHNob3VsZCUyMHNraXAlMjBpdCUyMGFuZCUyMGdvJTIwdG8lMEElMjMlMjB0aGUlMjBuZXh0JTIwb25lISUwQWZyb20lMjBkYXRhc2V0cyUyMGltcG9ydCUyMGxvYWRfZGF0YXNldCUwQSUwQXNwbGl0JTIwJTNEJTIwJTIydHJhaW4lMjIlMjAlMjAlMjMlMjAlMjJ2YWxpZCUyMiUwQWZpbHRlcnMlMjAlM0QlMjAlNUIlMjJwYW5kYXMlMjIlMkMlMjAlMjJza2xlYXJuJTIyJTJDJTIwJTIybWF0cGxvdGxpYiUyMiUyQyUyMCUyMnNlYWJvcm4lMjIlNUQlMEElMEFkYXRhJTIwJTNEJTIwbG9hZF9kYXRhc2V0KGYlMjJ0cmFuc2Zvcm1lcnNib29rJTJGY29kZXBhcnJvdC0lN0JzcGxpdCU3RCUyMiUyQyUyMHNwbGl0JTNEc3BsaXQlMkMlMjBzdHJlYW1pbmclM0RUcnVlKSUwQWZpbHRlcmVkX2RhdGElMjAlM0QlMjBmaWx0ZXJfc3RyZWFtaW5nX2RhdGFzZXQoZGF0YSUyQyUyMGZpbHRlcnMp",highlighted:`<span class="hljs-comment"># This cell will take a very long time to execute, so you should skip it and go to</span>
<span class="hljs-comment"># the next one!</span>
<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

split = <span class="hljs-string">&quot;train&quot;</span>  <span class="hljs-comment"># &quot;valid&quot;</span>
filters = [<span class="hljs-string">&quot;pandas&quot;</span>, <span class="hljs-string">&quot;sklearn&quot;</span>, <span class="hljs-string">&quot;matplotlib&quot;</span>, <span class="hljs-string">&quot;seaborn&quot;</span>]

data = load_dataset(<span class="hljs-string">f&quot;transformersbook/codeparrot-<span class="hljs-subst">{split}</span>&quot;</span>, split=split, streaming=<span class="hljs-literal">True</span>)
filtered_data = filter_streaming_dataset(data, filters)`,wrap:!1}}),O=new I({props:{code:"My4yNiUyNSUyMG9mJTIwZGF0YSUyMGFmdGVyJTIwZmlsdGVyaW5nLg==",highlighted:'<span class="hljs-number">3.26</span>% of data after filtering.',wrap:!1}}),Ge=new I({props:{code:"ZnJvbSUyMGRhdGFzZXRzJTIwaW1wb3J0JTIwbG9hZF9kYXRhc2V0JTJDJTIwRGF0YXNldERpY3QlMEElMEFkc190cmFpbiUyMCUzRCUyMGxvYWRfZGF0YXNldCglMjJodWdnaW5nZmFjZS1jb3Vyc2UlMkZjb2RlcGFycm90LWRzLXRyYWluJTIyJTJDJTIwc3BsaXQlM0QlMjJ0cmFpbiUyMiklMEFkc192YWxpZCUyMCUzRCUyMGxvYWRfZGF0YXNldCglMjJodWdnaW5nZmFjZS1jb3Vyc2UlMkZjb2RlcGFycm90LWRzLXZhbGlkJTIyJTJDJTIwc3BsaXQlM0QlMjJ2YWxpZGF0aW9uJTIyKSUwQSUwQXJhd19kYXRhc2V0cyUyMCUzRCUyMERhdGFzZXREaWN0KCUwQSUyMCUyMCUyMCUyMCU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMnRyYWluJTIyJTNBJTIwZHNfdHJhaW4lMkMlMjAlMjAlMjMlMjAuc2h1ZmZsZSgpLnNlbGVjdChyYW5nZSg1MDAwMCkpJTJDJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIydmFsaWQlMjIlM0ElMjBkc192YWxpZCUyQyUyMCUyMCUyMyUyMC5zaHVmZmxlKCkuc2VsZWN0KHJhbmdlKDUwMCkpJTBBJTIwJTIwJTIwJTIwJTdEJTBBKSUwQSUwQXJhd19kYXRhc2V0cw==",highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset, DatasetDict

ds_train = load_dataset(<span class="hljs-string">&quot;huggingface-course/codeparrot-ds-train&quot;</span>, split=<span class="hljs-string">&quot;train&quot;</span>)
ds_valid = load_dataset(<span class="hljs-string">&quot;huggingface-course/codeparrot-ds-valid&quot;</span>, split=<span class="hljs-string">&quot;validation&quot;</span>)

raw_datasets = DatasetDict(
    {
        <span class="hljs-string">&quot;train&quot;</span>: ds_train,  <span class="hljs-comment"># .shuffle().select(range(50000)),</span>
        <span class="hljs-string">&quot;valid&quot;</span>: ds_valid,  <span class="hljs-comment"># .shuffle().select(range(500))</span>
    }
)

raw_datasets`,wrap:!1}}),se=new I({props:{code:"RGF0YXNldERpY3QoJTdCJTBBJTIwJTIwJTIwJTIwdHJhaW4lM0ElMjBEYXRhc2V0KCU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGZlYXR1cmVzJTNBJTIwJTVCJ3JlcG9fbmFtZSclMkMlMjAncGF0aCclMkMlMjAnY29waWVzJyUyQyUyMCdzaXplJyUyQyUyMCdjb250ZW50JyUyQyUyMCdsaWNlbnNlJyU1RCUyQyUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMG51bV9yb3dzJTNBJTIwNjA2NzIwJTBBJTIwJTIwJTIwJTIwJTdEKSUwQSUyMCUyMCUyMCUyMHZhbGlkJTNBJTIwRGF0YXNldCglN0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBmZWF0dXJlcyUzQSUyMCU1QidyZXBvX25hbWUnJTJDJTIwJ3BhdGgnJTJDJTIwJ2NvcGllcyclMkMlMjAnc2l6ZSclMkMlMjAnY29udGVudCclMkMlMjAnbGljZW5zZSclNUQlMkMlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBudW1fcm93cyUzQSUyMDMzMjIlMEElMjAlMjAlMjAlMjAlN0QpJTBBJTdEKQ==",highlighted:`DatasetDict({
    train: Dataset({
        features: [<span class="hljs-string">&#x27;repo_name&#x27;</span>, <span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-string">&#x27;copies&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;license&#x27;</span>],
        num_rows: <span class="hljs-number">606720</span>
    })
    valid: Dataset({
        features: [<span class="hljs-string">&#x27;repo_name&#x27;</span>, <span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-string">&#x27;copies&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;license&#x27;</span>],
        num_rows: <span class="hljs-number">3322</span>
    })
})`,wrap:!1}}),z=new ct({props:{$$slots:{default:[ya]},$$scope:{ctx:C}}}),ae=new I({props:{code:"Zm9yJTIwa2V5JTIwaW4lMjByYXdfZGF0YXNldHMlNUIlMjJ0cmFpbiUyMiU1RCU1QjAlNUQlM0ElMEElMjAlMjAlMjAlMjBwcmludChmJTIyJTdCa2V5LnVwcGVyKCklN0QlM0ElMjAlN0JyYXdfZGF0YXNldHMlNUIndHJhaW4nJTVEJTVCMCU1RCU1QmtleSU1RCU1QiUzQTIwMCU1RCU3RCUyMik=",highlighted:`<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>]:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">{key.upper()}</span>: <span class="hljs-subst">{raw_datasets[<span class="hljs-string">&#x27;train&#x27;</span>][<span class="hljs-number">0</span>][key][:<span class="hljs-number">200</span>]}</span>&quot;</span>)`,wrap:!1}}),ne=new I({props:{code:"J1JFUE9fTkFNRSUzQSUyMGttaWtlJTJGc2Npa2l0LWxlYXJuJyUwQSdQQVRIJTNBJTIwc2tsZWFybiUyRnV0aWxzJTJGX19pbml0X18ucHknJTBBJ0NPUElFUyUzQSUyMDMnJTBBJ1NJWkUlM0ElMjAxMDA5NCclMEEnJydDT05URU5UJTNBJTIwJTIyJTIyJTIyJTBBVGhlJTIwJTNBbW9kJTNBJTYwc2tsZWFybi51dGlscyU2MCUyMG1vZHVsZSUyMGluY2x1ZGVzJTIwdmFyaW91cyUyMHV0aWxpdGVzLiUwQSUyMiUyMiUyMiUwQSUwQWZyb20lMjBjb2xsZWN0aW9ucyUyMGltcG9ydCUyMFNlcXVlbmNlJTBBJTBBaW1wb3J0JTIwbnVtcHklMjBhcyUyMG5wJTBBZnJvbSUyMHNjaXB5LnNwYXJzZSUyMGltcG9ydCUyMGlzc3BhcnNlJTBBaW1wb3J0JTIwd2FybmluZ3MlMEElMEFmcm9tJTIwLm11cm11cmhhc2glMjBpbXBvcnQlMjBtdXJtJTBBTElDRU5TRSUzQSUyMGJzZC0zLWNsYXVzZScnJw==",highlighted:`<span class="hljs-string">&#x27;REPO_NAME: kmike/scikit-learn&#x27;</span>
<span class="hljs-string">&#x27;PATH: sklearn/utils/__init__.py&#x27;</span>
<span class="hljs-string">&#x27;COPIES: 3&#x27;</span>
<span class="hljs-string">&#x27;SIZE: 10094&#x27;</span>
<span class="hljs-string">&#x27;&#x27;&#x27;CONTENT: &quot;&quot;&quot;
The :mod:\`sklearn.utils\` module includes various utilites.
&quot;&quot;&quot;

from collections import Sequence

import numpy as np
from scipy.sparse import issparse
import warnings

from .murmurhash import murm
LICENSE: bsd-3-clause&#x27;&#x27;&#x27;</span>`,wrap:!1}}),ce=new ys({props:{title:"Preparing the dataset",local:"preparing-the-dataset",headingTag:"h2"}}),we=new ul({props:{id:"ma1TrR7gE7I"}}),Je=new I({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Ub2tlbml6ZXIlMEElMEFjb250ZXh0X2xlbmd0aCUyMCUzRCUyMDEyOCUwQXRva2VuaXplciUyMCUzRCUyMEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKCUyMmh1Z2dpbmdmYWNlLWNvdXJzZSUyRmNvZGUtc2VhcmNoLW5ldC10b2tlbml6ZXIlMjIpJTBBJTBBb3V0cHV0cyUyMCUzRCUyMHRva2VuaXplciglMEElMjAlMjAlMjAlMjByYXdfZGF0YXNldHMlNUIlMjJ0cmFpbiUyMiU1RCU1QiUzQTIlNUQlNUIlMjJjb250ZW50JTIyJTVEJTJDJTBBJTIwJTIwJTIwJTIwdHJ1bmNhdGlvbiUzRFRydWUlMkMlMEElMjAlMjAlMjAlMjBtYXhfbGVuZ3RoJTNEY29udGV4dF9sZW5ndGglMkMlMEElMjAlMjAlMjAlMjByZXR1cm5fb3ZlcmZsb3dpbmdfdG9rZW5zJTNEVHJ1ZSUyQyUwQSUyMCUyMCUyMCUyMHJldHVybl9sZW5ndGglM0RUcnVlJTJDJTBBKSUwQSUwQXByaW50KGYlMjJJbnB1dCUyMElEcyUyMGxlbmd0aCUzQSUyMCU3QmxlbihvdXRwdXRzJTVCJ2lucHV0X2lkcyclNUQpJTdEJTIyKSUwQXByaW50KGYlMjJJbnB1dCUyMGNodW5rJTIwbGVuZ3RocyUzQSUyMCU3QihvdXRwdXRzJTVCJ2xlbmd0aCclNUQpJTdEJTIyKSUwQXByaW50KGYlMjJDaHVuayUyMG1hcHBpbmclM0ElMjAlN0JvdXRwdXRzJTVCJ292ZXJmbG93X3RvX3NhbXBsZV9tYXBwaW5nJyU1RCU3RCUyMik=",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

context_length = <span class="hljs-number">128</span>
tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;huggingface-course/code-search-net-tokenizer&quot;</span>)

outputs = tokenizer(
    raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][:<span class="hljs-number">2</span>][<span class="hljs-string">&quot;content&quot;</span>],
    truncation=<span class="hljs-literal">True</span>,
    max_length=context_length,
    return_overflowing_tokens=<span class="hljs-literal">True</span>,
    return_length=<span class="hljs-literal">True</span>,
)

<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Input IDs length: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(outputs[<span class="hljs-string">&#x27;input_ids&#x27;</span>])}</span>&quot;</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Input chunk lengths: <span class="hljs-subst">{(outputs[<span class="hljs-string">&#x27;length&#x27;</span>])}</span>&quot;</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Chunk mapping: <span class="hljs-subst">{outputs[<span class="hljs-string">&#x27;overflow_to_sample_mapping&#x27;</span>]}</span>&quot;</span>)`,wrap:!1}}),w=new I({props:{code:"SW5wdXQlMjBJRHMlMjBsZW5ndGglM0ElMjAzNCUwQUlucHV0JTIwY2h1bmslMjBsZW5ndGhzJTNBJTIwJTVCMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTE3JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwMTI4JTJDJTIwNDElNUQlMEFDaHVuayUyMG1hcHBpbmclM0ElMjAlNUIwJTJDJTIwMCUyQyUyMDAlMkMlMjAwJTJDJTIwMCUyQyUyMDAlMkMlMjAwJTJDJTIwMCUyQyUyMDAlMkMlMjAwJTJDJTIwMCUyQyUyMDAlMkMlMjAwJTJDJTIwMCUyQyUyMDAlMkMlMjAwJTJDJTIwMCUyQyUyMDAlMkMlMjAwJTJDJTIwMCUyQyUyMDElMkMlMjAxJTJDJTIwMSUyQyUyMDElMkMlMjAxJTJDJTIwMSUyQyUyMDElMkMlMjAxJTJDJTIwMSUyQyUyMDElMkMlMjAxJTJDJTIwMSUyQyUyMDElMkMlMjAxJTVE",highlighted:`Input IDs length: <span class="hljs-number">34</span>
Input chunk lengths: [<span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">117</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">41</span>]
Chunk mapping: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]`,wrap:!1}}),ft=new I({props:{code:"ZGVmJTIwdG9rZW5pemUoZWxlbWVudCklM0ElMEElMjAlMjAlMjAlMjBvdXRwdXRzJTIwJTNEJTIwdG9rZW5pemVyKCUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGVsZW1lbnQlNUIlMjJjb250ZW50JTIyJTVEJTJDJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwdHJ1bmNhdGlvbiUzRFRydWUlMkMlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBtYXhfbGVuZ3RoJTNEY29udGV4dF9sZW5ndGglMkMlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjByZXR1cm5fb3ZlcmZsb3dpbmdfdG9rZW5zJTNEVHJ1ZSUyQyUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMHJldHVybl9sZW5ndGglM0RUcnVlJTJDJTBBJTIwJTIwJTIwJTIwKSUwQSUyMCUyMCUyMCUyMGlucHV0X2JhdGNoJTIwJTNEJTIwJTVCJTVEJTBBJTIwJTIwJTIwJTIwZm9yJTIwbGVuZ3RoJTJDJTIwaW5wdXRfaWRzJTIwaW4lMjB6aXAob3V0cHV0cyU1QiUyMmxlbmd0aCUyMiU1RCUyQyUyMG91dHB1dHMlNUIlMjJpbnB1dF9pZHMlMjIlNUQpJTNBJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwaWYlMjBsZW5ndGglMjAlM0QlM0QlMjBjb250ZXh0X2xlbmd0aCUzQSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGlucHV0X2JhdGNoLmFwcGVuZChpbnB1dF9pZHMpJTBBJTIwJTIwJTIwJTIwcmV0dXJuJTIwJTdCJTIyaW5wdXRfaWRzJTIyJTNBJTIwaW5wdXRfYmF0Y2glN0QlMEElMEElMEF0b2tlbml6ZWRfZGF0YXNldHMlMjAlM0QlMjByYXdfZGF0YXNldHMubWFwKCUwQSUyMCUyMCUyMCUyMHRva2VuaXplJTJDJTIwYmF0Y2hlZCUzRFRydWUlMkMlMjByZW1vdmVfY29sdW1ucyUzRHJhd19kYXRhc2V0cyU1QiUyMnRyYWluJTIyJTVELmNvbHVtbl9uYW1lcyUwQSklMEF0b2tlbml6ZWRfZGF0YXNldHM=",highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize</span>(<span class="hljs-params">element</span>):
    outputs = tokenizer(
        element[<span class="hljs-string">&quot;content&quot;</span>],
        truncation=<span class="hljs-literal">True</span>,
        max_length=context_length,
        return_overflowing_tokens=<span class="hljs-literal">True</span>,
        return_length=<span class="hljs-literal">True</span>,
    )
    input_batch = []
    <span class="hljs-keyword">for</span> length, input_ids <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(outputs[<span class="hljs-string">&quot;length&quot;</span>], outputs[<span class="hljs-string">&quot;input_ids&quot;</span>]):
        <span class="hljs-keyword">if</span> length == context_length:
            input_batch.append(input_ids)
    <span class="hljs-keyword">return</span> {<span class="hljs-string">&quot;input_ids&quot;</span>: input_batch}


tokenized_datasets = raw_datasets.<span class="hljs-built_in">map</span>(
    tokenize, batched=<span class="hljs-literal">True</span>, remove_columns=raw_datasets[<span class="hljs-string">&quot;train&quot;</span>].column_names
)
tokenized_datasets`,wrap:!1}}),jt=new I({props:{code:"RGF0YXNldERpY3QoJTdCJTBBJTIwJTIwJTIwJTIwdHJhaW4lM0ElMjBEYXRhc2V0KCU3QiUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMGZlYXR1cmVzJTNBJTIwJTVCJ2lucHV0X2lkcyclNUQlMkMlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBudW1fcm93cyUzQSUyMDE2NzAyMDYxJTBBJTIwJTIwJTIwJTIwJTdEKSUwQSUyMCUyMCUyMCUyMHZhbGlkJTNBJTIwRGF0YXNldCglN0IlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjBmZWF0dXJlcyUzQSUyMCU1QidpbnB1dF9pZHMnJTVEJTJDJTBBJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwbnVtX3Jvd3MlM0ElMjA5MzE2NCUwQSUyMCUyMCUyMCUyMCU3RCklMEElN0Qp",highlighted:`DatasetDict({
    train: Dataset({
        features: [<span class="hljs-string">&#x27;input_ids&#x27;</span>],
        num_rows: <span class="hljs-number">16702061</span>
    })
    valid: Dataset({
        features: [<span class="hljs-string">&#x27;input_ids&#x27;</span>],
        num_rows: <span class="hljs-number">93164</span>
    })
})`,wrap:!1}}),nt=new ct({props:{$$slots:{default:[wa]},$$scope:{ctx:C}}}),Ct=new ys({props:{title:"Initializing a new model",local:"initializing-a-new-model",headingTag:"h2"}});const Wl=[ua,ma],Pt=[];function vl(e,o){return e[0]==="pt"?0:1}Te=vl(C),Ue=Pt[Te]=Wl[Te](C);const Ql=[da,ha],Ot=[];function zl(e,o){return e[0]==="pt"?0:1}fe=zl(C),je=Ot[fe]=Ql[fe](C),$t=new I({props:{code:"b3V0JTIwJTNEJTIwZGF0YV9jb2xsYXRvciglNUJ0b2tlbml6ZWRfZGF0YXNldHMlNUIlMjJ0cmFpbiUyMiU1RCU1QmklNUQlMjBmb3IlMjBpJTIwaW4lMjByYW5nZSg1KSU1RCklMEFmb3IlMjBrZXklMjBpbiUyMG91dCUzQSUwQSUyMCUyMCUyMCUyMHByaW50KGYlMjIlN0JrZXklN0QlMjBzaGFwZSUzQSUyMCU3Qm91dCU1QmtleSU1RC5zaGFwZSU3RCUyMik=",highlighted:`out = data_collator([tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>][i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)])
<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> out:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">{key}</span> shape: <span class="hljs-subst">{out[key].shape}</span>&quot;</span>)`,wrap:!1}});const Nl=[Ta,Ja],es=[];function Vl(e,o){return e[0]==="pt"?0:1}be=Vl(C),Ie=es[be]=Nl[be](C);let W=C[0]==="tf"&&Ol();ot=new ct({props:{warning:!0,$$slots:{default:[Ua]},$$scope:{ctx:C}}}),Xt=new I({props:{code:"ZnJvbSUyMGh1Z2dpbmdmYWNlX2h1YiUyMGltcG9ydCUyMG5vdGVib29rX2xvZ2luJTBBJTBBbm90ZWJvb2tfbG9naW4oKQ==",highlighted:`<span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> notebook_login

notebook_login()`,wrap:!1}}),vt=new I({props:{code:"aHVnZ2luZ2ZhY2UtY2xpJTIwbG9naW4=",highlighted:"huggingface-cli login",wrap:!1}});const xl=[ja,fa],ts=[];function El(e,o){return e[0]==="pt"?0:1}Ce=El(C),ge=ts[Ce]=xl[Ce](C),it=new ct({props:{$$slots:{default:[ba]},$$scope:{ctx:C}}}),pt=new ct({props:{$$slots:{default:[ga]},$$scope:{ctx:C}}}),Qt=new ys({props:{title:"Code generation with a pipeline",local:"code-generation-with-a-pipeline",headingTag:"h2"}});const Al=[ka,_a],ss=[];function Fl(e,o){return e[0]==="pt"?0:1}_e=Fl(C),ke=ss[_e]=Al[_e](C),Vt=new I({props:{code:"dHh0JTIwJTNEJTIwJTIyJTIyJTIyJTVDJTBBJTIzJTIwY3JlYXRlJTIwc29tZSUyMGRhdGElMEF4JTIwJTNEJTIwbnAucmFuZG9tLnJhbmRuKDEwMCklMEF5JTIwJTNEJTIwbnAucmFuZG9tLnJhbmRuKDEwMCklMEElMEElMjMlMjBjcmVhdGUlMjBzY2F0dGVyJTIwcGxvdCUyMHdpdGglMjB4JTJDJTIweSUwQSUyMiUyMiUyMiUwQXByaW50KHBpcGUodHh0JTJDJTIwbnVtX3JldHVybl9zZXF1ZW5jZXMlM0QxKSU1QjAlNUQlNUIlMjJnZW5lcmF0ZWRfdGV4dCUyMiU1RCk=",highlighted:`txt = <span class="hljs-string">&quot;&quot;&quot;\\
# create some data
x = np.random.randn(100)
y = np.random.randn(100)

# create scatter plot with x, y
&quot;&quot;&quot;</span>
<span class="hljs-built_in">print</span>(pipe(txt, num_return_sequences=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;generated_text&quot;</span>])`,wrap:!1}}),xt=new I({props:{code:"JTIzJTIwY3JlYXRlJTIwc29tZSUyMGRhdGElMEF4JTIwJTNEJTIwbnAucmFuZG9tLnJhbmRuKDEwMCklMEF5JTIwJTNEJTIwbnAucmFuZG9tLnJhbmRuKDEwMCklMEElMEElMjMlMjBjcmVhdGUlMjBzY2F0dGVyJTIwcGxvdCUyMHdpdGglMjB4JTJDJTIweSUwQXBsdC5zY2F0dGVyKHglMkMlMjB5KSUwQSUwQSUyMyUyMGNyZWF0ZSUyMHNjYXR0ZXI=",highlighted:`<span class="hljs-comment"># create some data</span>
x = np.random.randn(<span class="hljs-number">100</span>)
y = np.random.randn(<span class="hljs-number">100</span>)

<span class="hljs-comment"># create scatter plot with x, y</span>
plt.scatter(x, y)

<span class="hljs-comment"># create scatter</span>`,wrap:!1}}),At=new I({props:{code:"dHh0JTIwJTNEJTIwJTIyJTIyJTIyJTVDJTBBJTIzJTIwY3JlYXRlJTIwc29tZSUyMGRhdGElMEF4JTIwJTNEJTIwbnAucmFuZG9tLnJhbmRuKDEwMCklMEF5JTIwJTNEJTIwbnAucmFuZG9tLnJhbmRuKDEwMCklMEElMEElMjMlMjBjcmVhdGUlMjBkYXRhZnJhbWUlMjBmcm9tJTIweCUyMGFuZCUyMHklMEElMjIlMjIlMjIlMEFwcmludChwaXBlKHR4dCUyQyUyMG51bV9yZXR1cm5fc2VxdWVuY2VzJTNEMSklNUIwJTVEJTVCJTIyZ2VuZXJhdGVkX3RleHQlMjIlNUQp",highlighted:`txt = <span class="hljs-string">&quot;&quot;&quot;\\
# create some data
x = np.random.randn(100)
y = np.random.randn(100)

# create dataframe from x and y
&quot;&quot;&quot;</span>
<span class="hljs-built_in">print</span>(pipe(txt, num_return_sequences=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;generated_text&quot;</span>])`,wrap:!1}}),Ft=new I({props:{code:"JTIzJTIwY3JlYXRlJTIwc29tZSUyMGRhdGElMEF4JTIwJTNEJTIwbnAucmFuZG9tLnJhbmRuKDEwMCklMEF5JTIwJTNEJTIwbnAucmFuZG9tLnJhbmRuKDEwMCklMEElMEElMjMlMjBjcmVhdGUlMjBkYXRhZnJhbWUlMjBmcm9tJTIweCUyMGFuZCUyMHklMEFkZiUyMCUzRCUyMHBkLkRhdGFGcmFtZSglN0IneCclM0ElMjB4JTJDJTIwJ3knJTNBJTIweSU3RCklMEFkZi5pbnNlcnQoMCUyQyd4JyUyQyUyMHgpJTBBZm9y",highlighted:`<span class="hljs-comment"># create some data</span>
x = np.random.randn(<span class="hljs-number">100</span>)
y = np.random.randn(<span class="hljs-number">100</span>)

<span class="hljs-comment"># create dataframe from x and y</span>
df = pd.DataFrame({<span class="hljs-string">&#x27;x&#x27;</span>: x, <span class="hljs-string">&#x27;y&#x27;</span>: y})
df.insert(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;x&#x27;</span>, x)
<span class="hljs-keyword">for</span>`,wrap:!1}}),Ht=new I({props:{code:"dHh0JTIwJTNEJTIwJTIyJTIyJTIyJTVDJTBBJTIzJTIwZGF0YWZyYW1lJTIwd2l0aCUyMHByb2Zlc3Npb24lMkMlMjBpbmNvbWUlMjBhbmQlMjBuYW1lJTBBZGYlMjAlM0QlMjBwZC5EYXRhRnJhbWUoJTdCJ3Byb2Zlc3Npb24nJTNBJTIweCUyQyUyMCdpbmNvbWUnJTNBeSUyQyUyMCduYW1lJyUzQSUyMHolN0QpJTBBJTBBJTIzJTIwY2FsY3VsYXRlJTIwdGhlJTIwbWVhbiUyMGluY29tZSUyMHBlciUyMHByb2Zlc3Npb24lMEElMjIlMjIlMjIlMEFwcmludChwaXBlKHR4dCUyQyUyMG51bV9yZXR1cm5fc2VxdWVuY2VzJTNEMSklNUIwJTVEJTVCJTIyZ2VuZXJhdGVkX3RleHQlMjIlNUQp",highlighted:`txt = <span class="hljs-string">&quot;&quot;&quot;\\
# dataframe with profession, income and name
df = pd.DataFrame({&#x27;profession&#x27;: x, &#x27;income&#x27;:y, &#x27;name&#x27;: z})

# calculate the mean income per profession
&quot;&quot;&quot;</span>
<span class="hljs-built_in">print</span>(pipe(txt, num_return_sequences=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;generated_text&quot;</span>])`,wrap:!1}}),St=new I({props:{code:"JTIzJTIwZGF0YWZyYW1lJTIwd2l0aCUyMHByb2Zlc3Npb24lMkMlMjBpbmNvbWUlMjBhbmQlMjBuYW1lJTBBZGYlMjAlM0QlMjBwZC5EYXRhRnJhbWUoJTdCJ3Byb2Zlc3Npb24nJTNBJTIweCUyQyUyMCdpbmNvbWUnJTNBeSUyQyUyMCduYW1lJyUzQSUyMHolN0QpJTBBJTBBJTIzJTIwY2FsY3VsYXRlJTIwdGhlJTIwbWVhbiUyMGluY29tZSUyMHBlciUyMHByb2Zlc3Npb24lMEFwcm9mZXNzaW9uJTIwJTNEJTIwZGYuZ3JvdXBieSglNUIncHJvZmVzc2lvbiclNUQpLm1lYW4oKSUwQSUwQSUyMyUyMGNvbXB1dGUlMjB0aGU=",highlighted:`<span class="hljs-comment"># dataframe with profession, income and name</span>
df = pd.DataFrame({<span class="hljs-string">&#x27;profession&#x27;</span>: x, <span class="hljs-string">&#x27;income&#x27;</span>:y, <span class="hljs-string">&#x27;name&#x27;</span>: z})

<span class="hljs-comment"># calculate the mean income per profession</span>
profession = df.groupby([<span class="hljs-string">&#x27;profession&#x27;</span>]).mean()

<span class="hljs-comment"># compute the</span>`,wrap:!1}}),Dt=new I({props:{code:"dHh0JTIwJTNEJTIwJTIyJTIyJTIyJTBBJTIzJTIwaW1wb3J0JTIwcmFuZG9tJTIwZm9yZXN0JTIwcmVncmVzc29yJTIwZnJvbSUyMHNjaWtpdC1sZWFybiUwQWZyb20lMjBza2xlYXJuLmVuc2VtYmxlJTIwaW1wb3J0JTIwUmFuZG9tRm9yZXN0UmVncmVzc29yJTBBJTBBJTIzJTIwZml0JTIwcmFuZG9tJTIwZm9yZXN0JTIwbW9kZWwlMjB3aXRoJTIwMzAwJTIwZXN0aW1hdG9ycyUyMG9uJTIwWCUyQyUyMHklM0ElMEElMjIlMjIlMjIlMEFwcmludChwaXBlKHR4dCUyQyUyMG51bV9yZXR1cm5fc2VxdWVuY2VzJTNEMSklNUIwJTVEJTVCJTIyZ2VuZXJhdGVkX3RleHQlMjIlNUQp",highlighted:`txt = <span class="hljs-string">&quot;&quot;&quot;
# import random forest regressor from scikit-learn
from sklearn.ensemble import RandomForestRegressor

# fit random forest model with 300 estimators on X, y:
&quot;&quot;&quot;</span>
<span class="hljs-built_in">print</span>(pipe(txt, num_return_sequences=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;generated_text&quot;</span>])`,wrap:!1}}),Lt=new I({props:{code:"JTIzJTIwaW1wb3J0JTIwcmFuZG9tJTIwZm9yZXN0JTIwcmVncmVzc29yJTIwZnJvbSUyMHNjaWtpdC1sZWFybiUwQWZyb20lMjBza2xlYXJuLmVuc2VtYmxlJTIwaW1wb3J0JTIwUmFuZG9tRm9yZXN0UmVncmVzc29yJTBBJTBBJTIzJTIwZml0JTIwcmFuZG9tJTIwZm9yZXN0JTIwbW9kZWwlMjB3aXRoJTIwMzAwJTIwZXN0aW1hdG9ycyUyMG9uJTIwWCUyQyUyMHklM0ElMEFyZiUyMCUzRCUyMFJhbmRvbUZvcmVzdFJlZ3Jlc3NvcihuX2VzdGltYXRvcnMlM0QzMDAlMkMlMjByYW5kb21fc3RhdGUlM0RyYW5kb21fc3RhdGUlMkMlMjBtYXhfZGVwdGglM0QzKSUwQXJmLmZpdChYJTJDJTIweSklMEFyZg==",highlighted:`<span class="hljs-comment"># import random forest regressor from scikit-learn</span>
<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor

<span class="hljs-comment"># fit random forest model with 300 estimators on X, y:</span>
rf = RandomForestRegressor(n_estimators=<span class="hljs-number">300</span>, random_state=random_state, max_depth=<span class="hljs-number">3</span>)
rf.fit(X, y)
rf`,wrap:!1}});function Yl(e,o){return e[0]==="tf"?$a:Za}let il=Yl(C),at=il(C),v=C[0]==="pt"&&ea(C);return{c(){l=T("meta"),r=i(),n=T("p"),y=i(),u(g.$$.fragment),j=i(),u($.$$.fragment),Z=i(),m.c(),b=i(),G=T("p"),G.innerHTML=V,Q=i(),R=T("p"),R.innerHTML=_,B=i(),u(x.$$.fragment),ve=i(),E=T("p"),E.innerHTML=ws,Qe=i(),X=T("iframe"),ze=i(),A=T("p"),A.innerHTML=us,Ne=i(),u(F.$$.fragment),Ve=i(),Y=T("p"),Y.innerHTML=hs,xe=i(),H=T("p"),H.innerHTML=yt,ie=i(),u(Ze.$$.fragment),Ee=i(),S=T("p"),S.textContent=wt,pe=i(),u($e.$$.fragment),Ae=i(),u(q.$$.fragment),Fe=i(),D=T("p"),D.textContent=ds,Ye=i(),u(L.$$.fragment),He=i(),K=T("p"),K.textContent=Js,Se=i(),u(P.$$.fragment),qe=i(),u(O.$$.fragment),De=i(),ee=T("p"),ee.textContent=Ts,Le=i(),te=T("p"),te.textContent=mt,re=i(),u(Ge.$$.fragment),Ke=i(),u(se.$$.fragment),Pe=i(),u(z.$$.fragment),Oe=i(),le=T("p"),le.textContent=Us,et=i(),u(ae.$$.fragment),tt=i(),u(ne.$$.fragment),ut=i(),Me=T("p"),Me.innerHTML=Be,ht=i(),u(ce.$$.fragment),ye=i(),u(we.$$.fragment),me=i(),ue=T("p"),ue.textContent=Xe,dt=i(),he=T("p"),he.innerHTML=Re,st=i(),N=T("div"),N.innerHTML=fs,lt=i(),oe=T("p"),oe.textContent=Jt,de=i(),u(Je.$$.fragment),t=i(),u(w.$$.fragment),bs=i(),Tt=T("p"),Tt.innerHTML=hl,Is=i(),Ut=T("p"),Ut.innerHTML=dl,Cs=i(),u(ft.$$.fragment),gs=i(),u(jt.$$.fragment),_s=i(),bt=T("p"),bt.textContent=Jl,ks=i(),It=T("p"),It.textContent=Tl,Zs=i(),u(nt.$$.fragment),$s=i(),u(Ct.$$.fragment),Gs=i(),gt=T("p"),gt.innerHTML=Ul,Bs=i(),Ue.c(),as=i(),_t=T("p"),_t.innerHTML=fl,Xs=i(),kt=T("p"),kt.innerHTML=jl,Rs=i(),je.c(),ns=i(),Zt=T("p"),Zt.textContent=bl,Ws=i(),u($t.$$.fragment),vs=i(),Ie.c(),os=i(),Gt=T("p"),Gt.textContent=Il,Qs=i(),W&&W.c(),is=i(),u(ot.$$.fragment),zs=i(),Bt=T("p"),Bt.textContent=Cl,Ns=i(),u(Xt.$$.fragment),Vs=i(),Rt=T("p"),Rt.textContent=gl,xs=i(),Wt=T("p"),Wt.textContent=_l,Es=i(),u(vt.$$.fragment),As=i(),ge.c(),ps=i(),u(it.$$.fragment),Fs=i(),u(pt.$$.fragment),Ys=i(),u(Qt.$$.fragment),Hs=i(),zt=T("p"),zt.innerHTML=kl,Ss=i(),ke.c(),rs=i(),Nt=T("p"),Nt.textContent=Zl,qs=i(),u(Vt.$$.fragment),Ds=i(),u(xt.$$.fragment),Ls=i(),Et=T("p"),Et.innerHTML=$l,Ks=i(),u(At.$$.fragment),Ps=i(),u(Ft.$$.fragment),Os=i(),Yt=T("p"),Yt.innerHTML=Gl,el=i(),u(Ht.$$.fragment),tl=i(),u(St.$$.fragment),sl=i(),qt=T("p"),qt.innerHTML=Bl,ll=i(),u(Dt.$$.fragment),al=i(),u(Lt.$$.fragment),nl=i(),at.c(),Ms=i(),v&&v.c(),cs=i(),js=T("p"),this.h()},l(e){const o=ia("svelte-u9bgzb",document.head);l=U(o,"META",{name:!0,content:!0}),o.forEach(s),r=p(e),n=U(e,"P",{}),ml(n).forEach(s),y=p(e),h(g.$$.fragment,e),j=p(e),h($.$$.fragment,e),Z=p(e),m.l(e),b=p(e),G=U(e,"P",{"data-svelte-h":!0}),f(G)!=="svelte-n23fcu"&&(G.innerHTML=V),Q=p(e),R=U(e,"P",{"data-svelte-h":!0}),f(R)!=="svelte-1pnwlne"&&(R.innerHTML=_),B=p(e),h(x.$$.fragment,e),ve=p(e),E=U(e,"P",{"data-svelte-h":!0}),f(E)!=="svelte-196thle"&&(E.innerHTML=ws),Qe=p(e),X=U(e,"IFRAME",{src:!0,frameborder:!0,height:!0,title:!0,class:!0,allow:!0,sandbox:!0}),ml(X).forEach(s),ze=p(e),A=U(e,"P",{"data-svelte-h":!0}),f(A)!=="svelte-ab9fd4"&&(A.innerHTML=us),Ne=p(e),h(F.$$.fragment,e),Ve=p(e),Y=U(e,"P",{"data-svelte-h":!0}),f(Y)!=="svelte-tpjiv"&&(Y.innerHTML=hs),xe=p(e),H=U(e,"P",{"data-svelte-h":!0}),f(H)!=="svelte-c22pqj"&&(H.innerHTML=yt),ie=p(e),h(Ze.$$.fragment,e),Ee=p(e),S=U(e,"P",{"data-svelte-h":!0}),f(S)!=="svelte-1dvnz8o"&&(S.textContent=wt),pe=p(e),h($e.$$.fragment,e),Ae=p(e),h(q.$$.fragment,e),Fe=p(e),D=U(e,"P",{"data-svelte-h":!0}),f(D)!=="svelte-1aeifay"&&(D.textContent=ds),Ye=p(e),h(L.$$.fragment,e),He=p(e),K=U(e,"P",{"data-svelte-h":!0}),f(K)!=="svelte-1ekmk11"&&(K.textContent=Js),Se=p(e),h(P.$$.fragment,e),qe=p(e),h(O.$$.fragment,e),De=p(e),ee=U(e,"P",{"data-svelte-h":!0}),f(ee)!=="svelte-bf1ont"&&(ee.textContent=Ts),Le=p(e),te=U(e,"P",{"data-svelte-h":!0}),f(te)!=="svelte-zq0s8o"&&(te.textContent=mt),re=p(e),h(Ge.$$.fragment,e),Ke=p(e),h(se.$$.fragment,e),Pe=p(e),h(z.$$.fragment,e),Oe=p(e),le=U(e,"P",{"data-svelte-h":!0}),f(le)!=="svelte-yay142"&&(le.textContent=Us),et=p(e),h(ae.$$.fragment,e),tt=p(e),h(ne.$$.fragment,e),ut=p(e),Me=U(e,"P",{"data-svelte-h":!0}),f(Me)!=="svelte-tg22kr"&&(Me.innerHTML=Be),ht=p(e),h(ce.$$.fragment,e),ye=p(e),h(we.$$.fragment,e),me=p(e),ue=U(e,"P",{"data-svelte-h":!0}),f(ue)!=="svelte-snql8t"&&(ue.textContent=Xe),dt=p(e),he=U(e,"P",{"data-svelte-h":!0}),f(he)!=="svelte-4oqi89"&&(he.innerHTML=Re),st=p(e),N=U(e,"DIV",{class:!0,"data-svelte-h":!0}),f(N)!=="svelte-1mf8pz"&&(N.innerHTML=fs),lt=p(e),oe=U(e,"P",{"data-svelte-h":!0}),f(oe)!=="svelte-1k3fmn9"&&(oe.textContent=Jt),de=p(e),h(Je.$$.fragment,e),t=p(e),h(w.$$.fragment,e),bs=p(e),Tt=U(e,"P",{"data-svelte-h":!0}),f(Tt)!=="svelte-4fmrv9"&&(Tt.innerHTML=hl),Is=p(e),Ut=U(e,"P",{"data-svelte-h":!0}),f(Ut)!=="svelte-1ro02u6"&&(Ut.innerHTML=dl),Cs=p(e),h(ft.$$.fragment,e),gs=p(e),h(jt.$$.fragment,e),_s=p(e),bt=U(e,"P",{"data-svelte-h":!0}),f(bt)!=="svelte-4o3hzi"&&(bt.textContent=Jl),ks=p(e),It=U(e,"P",{"data-svelte-h":!0}),f(It)!=="svelte-17t6lwy"&&(It.textContent=Tl),Zs=p(e),h(nt.$$.fragment,e),$s=p(e),h(Ct.$$.fragment,e),Gs=p(e),gt=U(e,"P",{"data-svelte-h":!0}),f(gt)!=="svelte-1hjqc59"&&(gt.innerHTML=Ul),Bs=p(e),Ue.l(e),as=p(e),_t=U(e,"P",{"data-svelte-h":!0}),f(_t)!=="svelte-1hk8ix6"&&(_t.innerHTML=fl),Xs=p(e),kt=U(e,"P",{"data-svelte-h":!0}),f(kt)!=="svelte-z4ltmo"&&(kt.innerHTML=jl),Rs=p(e),je.l(e),ns=p(e),Zt=U(e,"P",{"data-svelte-h":!0}),f(Zt)!=="svelte-d5rqk1"&&(Zt.textContent=bl),Ws=p(e),h($t.$$.fragment,e),vs=p(e),Ie.l(e),os=p(e),Gt=U(e,"P",{"data-svelte-h":!0}),f(Gt)!=="svelte-1qzksrg"&&(Gt.textContent=Il),Qs=p(e),W&&W.l(e),is=p(e),h(ot.$$.fragment,e),zs=p(e),Bt=U(e,"P",{"data-svelte-h":!0}),f(Bt)!=="svelte-1vtzchd"&&(Bt.textContent=Cl),Ns=p(e),h(Xt.$$.fragment,e),Vs=p(e),Rt=U(e,"P",{"data-svelte-h":!0}),f(Rt)!=="svelte-1ied0vh"&&(Rt.textContent=gl),xs=p(e),Wt=U(e,"P",{"data-svelte-h":!0}),f(Wt)!=="svelte-648vlf"&&(Wt.textContent=_l),Es=p(e),h(vt.$$.fragment,e),As=p(e),ge.l(e),ps=p(e),h(it.$$.fragment,e),Fs=p(e),h(pt.$$.fragment,e),Ys=p(e),h(Qt.$$.fragment,e),Hs=p(e),zt=U(e,"P",{"data-svelte-h":!0}),f(zt)!=="svelte-cktwb7"&&(zt.innerHTML=kl),Ss=p(e),ke.l(e),rs=p(e),Nt=U(e,"P",{"data-svelte-h":!0}),f(Nt)!=="svelte-14oror3"&&(Nt.textContent=Zl),qs=p(e),h(Vt.$$.fragment,e),Ds=p(e),h(xt.$$.fragment,e),Ls=p(e),Et=U(e,"P",{"data-svelte-h":!0}),f(Et)!=="svelte-1htu6p0"&&(Et.innerHTML=$l),Ks=p(e),h(At.$$.fragment,e),Ps=p(e),h(Ft.$$.fragment,e),Os=p(e),Yt=U(e,"P",{"data-svelte-h":!0}),f(Yt)!=="svelte-ls0a4d"&&(Yt.innerHTML=Gl),el=p(e),h(Ht.$$.fragment,e),tl=p(e),h(St.$$.fragment,e),sl=p(e),qt=U(e,"P",{"data-svelte-h":!0}),f(qt)!=="svelte-15s17ie"&&(qt.innerHTML=Bl),ll=p(e),h(Dt.$$.fragment,e),al=p(e),h(Lt.$$.fragment,e),nl=p(e),at.l(e),Ms=p(e),v&&v.l(e),cs=p(e),js=U(e,"P",{}),ml(js).forEach(s),this.h()},h(){We(l,"name","hf:doc:metadata"),We(l,"content",Wa),la(X.src,ms="https://course-demos-codeparrot-ds.hf.space")||We(X,"src",ms),We(X,"frameborder","0"),We(X,"height","300"),We(X,"title","Gradio app"),We(X,"class","block dark:hidden container p-0 flex-grow space-iframe"),We(X,"allow","accelerometer; ambient-light-sensor; autoplay; battery; camera; document-domain; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; oversized-images; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr ; wake-lock; xr-spatial-tracking"),We(X,"sandbox","allow-forms allow-modals allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-downloads"),We(N,"class","flex justify-center")},m(e,o){pa(document.head,l),a(e,r,o),a(e,n,o),a(e,y,o),d(g,e,o),a(e,j,o),d($,e,o),a(e,Z,o),Kt[k].m(e,o),a(e,b,o),a(e,G,o),a(e,Q,o),a(e,R,o),a(e,B,o),d(x,e,o),a(e,ve,o),a(e,E,o),a(e,Qe,o),a(e,X,o),a(e,ze,o),a(e,A,o),a(e,Ne,o),d(F,e,o),a(e,Ve,o),a(e,Y,o),a(e,xe,o),a(e,H,o),a(e,ie,o),d(Ze,e,o),a(e,Ee,o),a(e,S,o),a(e,pe,o),d($e,e,o),a(e,Ae,o),d(q,e,o),a(e,Fe,o),a(e,D,o),a(e,Ye,o),d(L,e,o),a(e,He,o),a(e,K,o),a(e,Se,o),d(P,e,o),a(e,qe,o),d(O,e,o),a(e,De,o),a(e,ee,o),a(e,Le,o),a(e,te,o),a(e,re,o),d(Ge,e,o),a(e,Ke,o),d(se,e,o),a(e,Pe,o),d(z,e,o),a(e,Oe,o),a(e,le,o),a(e,et,o),d(ae,e,o),a(e,tt,o),d(ne,e,o),a(e,ut,o),a(e,Me,o),a(e,ht,o),d(ce,e,o),a(e,ye,o),d(we,e,o),a(e,me,o),a(e,ue,o),a(e,dt,o),a(e,he,o),a(e,st,o),a(e,N,o),a(e,lt,o),a(e,oe,o),a(e,de,o),d(Je,e,o),a(e,t,o),d(w,e,o),a(e,bs,o),a(e,Tt,o),a(e,Is,o),a(e,Ut,o),a(e,Cs,o),d(ft,e,o),a(e,gs,o),d(jt,e,o),a(e,_s,o),a(e,bt,o),a(e,ks,o),a(e,It,o),a(e,Zs,o),d(nt,e,o),a(e,$s,o),d(Ct,e,o),a(e,Gs,o),a(e,gt,o),a(e,Bs,o),Pt[Te].m(e,o),a(e,as,o),a(e,_t,o),a(e,Xs,o),a(e,kt,o),a(e,Rs,o),Ot[fe].m(e,o),a(e,ns,o),a(e,Zt,o),a(e,Ws,o),d($t,e,o),a(e,vs,o),es[be].m(e,o),a(e,os,o),a(e,Gt,o),a(e,Qs,o),W&&W.m(e,o),a(e,is,o),d(ot,e,o),a(e,zs,o),a(e,Bt,o),a(e,Ns,o),d(Xt,e,o),a(e,Vs,o),a(e,Rt,o),a(e,xs,o),a(e,Wt,o),a(e,Es,o),d(vt,e,o),a(e,As,o),ts[Ce].m(e,o),a(e,ps,o),d(it,e,o),a(e,Fs,o),d(pt,e,o),a(e,Ys,o),d(Qt,e,o),a(e,Hs,o),a(e,zt,o),a(e,Ss,o),ss[_e].m(e,o),a(e,rs,o),a(e,Nt,o),a(e,qs,o),d(Vt,e,o),a(e,Ds,o),d(xt,e,o),a(e,Ls,o),a(e,Et,o),a(e,Ks,o),d(At,e,o),a(e,Ps,o),d(Ft,e,o),a(e,Os,o),a(e,Yt,o),a(e,el,o),d(Ht,e,o),a(e,tl,o),d(St,e,o),a(e,sl,o),a(e,qt,o),a(e,ll,o),d(Dt,e,o),a(e,al,o),d(Lt,e,o),a(e,nl,o),at.m(e,o),a(e,Ms,o),v&&v.m(e,o),a(e,cs,o),a(e,js,o),ol=!0},p(e,[o]){const Hl={};o&1&&(Hl.fw=e[0]),g.$set(Hl);let pl=k;k=Rl(e),k!==pl&&(Mt(),c(Kt[pl],1,1,()=>{Kt[pl]=null}),rt(),m=Kt[k],m||(m=Kt[k]=Xl[k](e),m.c()),M(m,1),m.m(b.parentNode,b));const Sl={};o&2&&(Sl.$$scope={dirty:o,ctx:e}),z.$set(Sl);const ql={};o&2&&(ql.$$scope={dirty:o,ctx:e}),nt.$set(ql);let rl=Te;Te=vl(e),Te!==rl&&(Mt(),c(Pt[rl],1,1,()=>{Pt[rl]=null}),rt(),Ue=Pt[Te],Ue||(Ue=Pt[Te]=Wl[Te](e),Ue.c()),M(Ue,1),Ue.m(as.parentNode,as));let Ml=fe;fe=zl(e),fe!==Ml&&(Mt(),c(Ot[Ml],1,1,()=>{Ot[Ml]=null}),rt(),je=Ot[fe],je||(je=Ot[fe]=Ql[fe](e),je.c()),M(je,1),je.m(ns.parentNode,ns));let cl=be;be=Vl(e),be!==cl&&(Mt(),c(es[cl],1,1,()=>{es[cl]=null}),rt(),Ie=es[be],Ie||(Ie=es[be]=Nl[be](e),Ie.c()),M(Ie,1),Ie.m(os.parentNode,os)),e[0]==="tf"?W?o&1&&M(W,1):(W=Ol(),W.c(),M(W,1),W.m(is.parentNode,is)):W&&(Mt(),c(W,1,1,()=>{W=null}),rt());const Dl={};o&2&&(Dl.$$scope={dirty:o,ctx:e}),ot.$set(Dl);let yl=Ce;Ce=El(e),Ce!==yl&&(Mt(),c(ts[yl],1,1,()=>{ts[yl]=null}),rt(),ge=ts[Ce],ge||(ge=ts[Ce]=xl[Ce](e),ge.c()),M(ge,1),ge.m(ps.parentNode,ps));const Ll={};o&2&&(Ll.$$scope={dirty:o,ctx:e}),it.$set(Ll);const Kl={};o&3&&(Kl.$$scope={dirty:o,ctx:e}),pt.$set(Kl);let wl=_e;_e=Fl(e),_e!==wl&&(Mt(),c(ss[wl],1,1,()=>{ss[wl]=null}),rt(),ke=ss[_e],ke||(ke=ss[_e]=Al[_e](e),ke.c()),M(ke,1),ke.m(rs.parentNode,rs)),il!==(il=Yl(e))&&(at.d(1),at=il(e),at&&(at.c(),at.m(Ms.parentNode,Ms))),e[0]==="pt"?v?o&1&&M(v,1):(v=ea(e),v.c(),M(v,1),v.m(cs.parentNode,cs)):v&&(Mt(),c(v,1,1,()=>{v=null}),rt())},i(e){ol||(M(g.$$.fragment,e),M($.$$.fragment,e),M(m),M(x.$$.fragment,e),M(F.$$.fragment,e),M(Ze.$$.fragment,e),M($e.$$.fragment,e),M(q.$$.fragment,e),M(L.$$.fragment,e),M(P.$$.fragment,e),M(O.$$.fragment,e),M(Ge.$$.fragment,e),M(se.$$.fragment,e),M(z.$$.fragment,e),M(ae.$$.fragment,e),M(ne.$$.fragment,e),M(ce.$$.fragment,e),M(we.$$.fragment,e),M(Je.$$.fragment,e),M(w.$$.fragment,e),M(ft.$$.fragment,e),M(jt.$$.fragment,e),M(nt.$$.fragment,e),M(Ct.$$.fragment,e),M(Ue),M(je),M($t.$$.fragment,e),M(Ie),M(W),M(ot.$$.fragment,e),M(Xt.$$.fragment,e),M(vt.$$.fragment,e),M(ge),M(it.$$.fragment,e),M(pt.$$.fragment,e),M(Qt.$$.fragment,e),M(ke),M(Vt.$$.fragment,e),M(xt.$$.fragment,e),M(At.$$.fragment,e),M(Ft.$$.fragment,e),M(Ht.$$.fragment,e),M(St.$$.fragment,e),M(Dt.$$.fragment,e),M(Lt.$$.fragment,e),M(v),ol=!0)},o(e){c(g.$$.fragment,e),c($.$$.fragment,e),c(m),c(x.$$.fragment,e),c(F.$$.fragment,e),c(Ze.$$.fragment,e),c($e.$$.fragment,e),c(q.$$.fragment,e),c(L.$$.fragment,e),c(P.$$.fragment,e),c(O.$$.fragment,e),c(Ge.$$.fragment,e),c(se.$$.fragment,e),c(z.$$.fragment,e),c(ae.$$.fragment,e),c(ne.$$.fragment,e),c(ce.$$.fragment,e),c(we.$$.fragment,e),c(Je.$$.fragment,e),c(w.$$.fragment,e),c(ft.$$.fragment,e),c(jt.$$.fragment,e),c(nt.$$.fragment,e),c(Ct.$$.fragment,e),c(Ue),c(je),c($t.$$.fragment,e),c(Ie),c(W),c(ot.$$.fragment,e),c(Xt.$$.fragment,e),c(vt.$$.fragment,e),c(ge),c(it.$$.fragment,e),c(pt.$$.fragment,e),c(Qt.$$.fragment,e),c(ke),c(Vt.$$.fragment,e),c(xt.$$.fragment,e),c(At.$$.fragment,e),c(Ft.$$.fragment,e),c(Ht.$$.fragment,e),c(St.$$.fragment,e),c(Dt.$$.fragment,e),c(Lt.$$.fragment,e),c(v),ol=!1},d(e){e&&(s(r),s(n),s(y),s(j),s(Z),s(b),s(G),s(Q),s(R),s(B),s(ve),s(E),s(Qe),s(X),s(ze),s(A),s(Ne),s(Ve),s(Y),s(xe),s(H),s(ie),s(Ee),s(S),s(pe),s(Ae),s(Fe),s(D),s(Ye),s(He),s(K),s(Se),s(qe),s(De),s(ee),s(Le),s(te),s(re),s(Ke),s(Pe),s(Oe),s(le),s(et),s(tt),s(ut),s(Me),s(ht),s(ye),s(me),s(ue),s(dt),s(he),s(st),s(N),s(lt),s(oe),s(de),s(t),s(bs),s(Tt),s(Is),s(Ut),s(Cs),s(gs),s(_s),s(bt),s(ks),s(It),s(Zs),s($s),s(Gs),s(gt),s(Bs),s(as),s(_t),s(Xs),s(kt),s(Rs),s(ns),s(Zt),s(Ws),s(vs),s(os),s(Gt),s(Qs),s(is),s(zs),s(Bt),s(Ns),s(Vs),s(Rt),s(xs),s(Wt),s(Es),s(As),s(ps),s(Fs),s(Ys),s(Hs),s(zt),s(Ss),s(rs),s(Nt),s(qs),s(Ds),s(Ls),s(Et),s(Ks),s(Ps),s(Os),s(Yt),s(el),s(tl),s(sl),s(qt),s(ll),s(al),s(nl),s(Ms),s(cs),s(js)),s(l),J(g,e),J($,e),Kt[k].d(e),J(x,e),J(F,e),J(Ze,e),J($e,e),J(q,e),J(L,e),J(P,e),J(O,e),J(Ge,e),J(se,e),J(z,e),J(ae,e),J(ne,e),J(ce,e),J(we,e),J(Je,e),J(w,e),J(ft,e),J(jt,e),J(nt,e),J(Ct,e),Pt[Te].d(e),Ot[fe].d(e),J($t,e),es[be].d(e),W&&W.d(e),J(ot,e),J(Xt,e),J(vt,e),ts[Ce].d(e),J(it,e),J(pt,e),J(Qt,e),ss[_e].d(e),J(Vt,e),J(xt,e),J(At,e),J(Ft,e),J(Ht,e),J(St,e),J(Dt,e),J(Lt,e),at.d(e),v&&v.d(e)}}}const Wa='{"title":"Training a causal language model from scratch","local":"training-a-causal-language-model-from-scratch","sections":[{"title":"Gathering the data","local":"gathering-the-data","sections":[],"depth":2},{"title":"Preparing the dataset","local":"preparing-the-dataset","sections":[],"depth":2},{"title":"Initializing a new model","local":"initializing-a-new-model","sections":[],"depth":2},{"title":"Code generation with a pipeline","local":"code-generation-with-a-pipeline","sections":[],"depth":2},{"title":"Training with ü§ó Accelerate","local":"training-with-accelerate","sections":[],"depth":2}],"depth":1}';function va(C,l,r){let n="pt";return aa(()=>{const y=new URLSearchParams(window.location.search);r(0,n=y.get("fw")||"pt")}),[n]}class Ya extends na{constructor(l){super(),oa(this,l,va,Ra,sa,{})}}export{Ya as component};
